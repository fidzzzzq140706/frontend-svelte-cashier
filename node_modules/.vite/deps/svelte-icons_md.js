import {
  IconBase_default,
  MdAddShoppingCart_default
} from "./chunk-7U2BBFMM.js";
import "./chunk-DAWX4V3F.js";
import {
  SvelteComponentDev,
  add_location,
  assign,
  attr_dev,
  children,
  claim_component,
  claim_space,
  claim_svg_element,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  exclude_internal_props,
  get_spread_object,
  get_spread_update,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  space,
  svg_element,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-NAJ5ZQWL.js";
import "./chunk-VXTFDJS3.js";
import "./chunk-2B2CG5KL.js";

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/Md3DRotation.svelte
var file = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/Md3DRotation.svelte";
function create_default_slot(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.52 21.48C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32zm.89-6.52c-.19 0-.37-.03-.52-.08-.16-.06-.29-.13-.4-.24-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44s.42-.43.55-.72c.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56-.05-.18-.12-.35-.23-.51-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31.2-.09.37-.2.52-.33.15-.13.27-.27.37-.42.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96-.12-.28-.29-.51-.51-.69-.2-.19-.47-.33-.77-.43C9.1 8.05 8.76 8 8.39 8c-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45s.14-.25.25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49-.05.15-.14.27-.25.37-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09H7.5v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33zm8.55-5.92c-.32-.33-.7-.59-1.14-.77-.43-.18-.92-.27-1.46-.27H12v8h2.3c.55 0 1.06-.09 1.51-.27.45-.18.84-.43 1.16-.76.32-.33.57-.73.74-1.19.17-.47.26-.99.26-1.57v-.4c0-.58-.09-1.1-.26-1.57-.18-.47-.43-.87-.75-1.2zm-.39 3.16c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91V9.12h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4zM12 0l-.66.03 3.81 3.81 1.33-1.33c3.27 1.55 5.61 4.72 5.96 8.48h1.5C23.44 4.84 18.29 0 12 0z");
      add_location(path, file, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Md3DRotation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var Md3DRotation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Md3DRotation",
      options,
      id: create_fragment.name
    });
  }
};
var Md3DRotation_default = Md3DRotation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessibility.svelte
var file2 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessibility.svelte";
function create_default_slot2(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z");
      add_location(path, file2, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccessibility", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccessibility = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccessibility",
      options,
      id: create_fragment2.name
    });
  }
};
var MdAccessibility_default = MdAccessibility;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessible.svelte
var file3 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessible.svelte";
function create_default_slot3(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file3, 4, 10, 151);
      attr_dev(path1, "d", "M19 13v-2c-1.54.02-3.09-.75-4.07-1.83l-1.29-1.43c-.17-.19-.38-.34-.61-.45-.01 0-.01-.01-.02-.01H13c-.35-.2-.75-.3-1.19-.26C10.76 7.11 10 8.04 10 9.09V15c0 1.1.9 2 2 2h5v5h2v-5.5c0-1.1-.9-2-2-2h-3v-3.45c1.29 1.07 3.25 1.94 5 1.95zm-6.17 5c-.41 1.16-1.52 2-2.83 2-1.66 0-3-1.34-3-3 0-1.31.84-2.41 2-2.83V12.1c-2.28.46-4 2.48-4 4.9 0 2.76 2.24 5 5 5 2.42 0 4.44-1.72 4.9-4h-2.07z");
      add_location(path1, file3, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccessible", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccessible = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccessible",
      options,
      id: create_fragment3.name
    });
  }
};
var MdAccessible_default = MdAccessible;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountBalance.svelte
var file4 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountBalance.svelte";
function create_default_slot4(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 10v7h3v-7H4zm6 0v7h3v-7h-3zM2 22h19v-3H2v3zm14-12v7h3v-7h-3zm-4.5-9L2 6v2h19V6l-9.5-5z");
      add_location(path, file4, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccountBalance", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccountBalance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccountBalance",
      options,
      id: create_fragment4.name
    });
  }
};
var MdAccountBalance_default = MdAccountBalance;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountBalanceWallet.svelte
var file5 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountBalanceWallet.svelte";
function create_default_slot5(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file5, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccountBalanceWallet", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccountBalanceWallet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccountBalanceWallet",
      options,
      id: create_fragment5.name
    });
  }
};
var MdAccountBalanceWallet_default = MdAccountBalanceWallet;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountBox.svelte
var file6 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountBox.svelte";
function create_default_slot6(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.11 0-2 .9-2 2zm12 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3zm-9 8c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1H6v-1z");
      add_location(path, file6, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccountBox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccountBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccountBox",
      options,
      id: create_fragment6.name
    });
  }
};
var MdAccountBox_default = MdAccountBox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountCircle.svelte
var file7 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccountCircle.svelte";
function create_default_slot7(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z");
      add_location(path, file7, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccountCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccountCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccountCircle",
      options,
      id: create_fragment7.name
    });
  }
};
var MdAccountCircle_default = MdAccountCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarm.svelte
var file8 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarm.svelte";
function create_default_slot8(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file8, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAlarm", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAlarm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAlarm",
      options,
      id: create_fragment8.name
    });
  }
};
var MdAlarm_default = MdAlarm;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarmAdd.svelte
var file9 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarmAdd.svelte";
function create_default_slot9(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3H8v2h3v3h2v-3h3v-2h-3V9z");
      add_location(path, file9, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAlarmAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAlarmAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAlarmAdd",
      options,
      id: create_fragment9.name
    });
  }
};
var MdAlarmAdd_default = MdAlarmAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarmOff.svelte
var file10 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarmOff.svelte";
function create_default_slot10(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 6c3.87 0 7 3.13 7 7 0 .84-.16 1.65-.43 2.4l1.52 1.52c.58-1.19.91-2.51.91-3.92 0-4.97-4.03-9-9-9-1.41 0-2.73.33-3.92.91L9.6 6.43C10.35 6.16 11.16 6 12 6zm10-.28l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM2.92 2.29L1.65 3.57 2.98 4.9l-1.11.93 1.42 1.42 1.11-.94.8.8C3.83 8.69 3 10.75 3 13c0 4.97 4.02 9 9 9 2.25 0 4.31-.83 5.89-2.2l2.2 2.2 1.27-1.27L3.89 3.27l-.97-.98zm13.55 16.1C15.26 19.39 13.7 20 12 20c-3.87 0-7-3.13-7-7 0-1.7.61-3.26 1.61-4.47l9.86 9.86zM8.02 3.28L6.6 1.86l-.86.71 1.42 1.42.86-.71z");
      add_location(path, file10, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAlarmOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAlarmOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAlarmOff",
      options,
      id: create_fragment10.name
    });
  }
};
var MdAlarmOff_default = MdAlarmOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarmOn.svelte
var file11 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlarmOn.svelte";
function create_default_slot11(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-1.46-5.47L8.41 12.4l-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95z");
      add_location(path, file11, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAlarmOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAlarmOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAlarmOn",
      options,
      id: create_fragment11.name
    });
  }
};
var MdAlarmOn_default = MdAlarmOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAllOut.svelte
var file12 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAllOut.svelte";
function create_default_slot12(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.21 4.16l4 4v-4zm4 12l-4 4h4zm-12 4l-4-4v4zm-4-12l4-4h-4zm12.95-.95c-2.73-2.73-7.17-2.73-9.9 0s-2.73 7.17 0 9.9 7.17 2.73 9.9 0 2.73-7.16 0-9.9zm-1.1 8.8c-2.13 2.13-5.57 2.13-7.7 0s-2.13-5.57 0-7.7 5.57-2.13 7.7 0 2.13 5.57 0 7.7z");
      add_location(path, file12, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAllOut", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAllOut = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAllOut",
      options,
      id: create_fragment12.name
    });
  }
};
var MdAllOut_default = MdAllOut;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAndroid.svelte
var file13 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAndroid.svelte";
function create_default_slot13(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h1c.55 0 1-.45 1-1V8H6v10zM3.5 8C2.67 8 2 8.67 2 9.5v7c0 .83.67 1.5 1.5 1.5S5 17.33 5 16.5v-7C5 8.67 4.33 8 3.5 8zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48C13.85 1.23 12.95 1 12 1c-.96 0-1.86.23-2.66.63L7.85.15c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31C6.97 3.26 6 5.01 6 7h12c0-1.99-.97-3.75-2.47-4.84zM10 5H9V4h1v1zm5 0h-1V4h1v1z");
      add_location(path, file13, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAndroid", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAndroid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAndroid",
      options,
      id: create_fragment13.name
    });
  }
};
var MdAndroid_default = MdAndroid;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAnnouncement.svelte
var file14 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAnnouncement.svelte";
function create_default_slot14(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z");
      add_location(path, file14, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAnnouncement", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAnnouncement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAnnouncement",
      options,
      id: create_fragment14.name
    });
  }
};
var MdAnnouncement_default = MdAnnouncement;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAspectRatio.svelte
var file15 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAspectRatio.svelte";
function create_default_slot15(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z");
      add_location(path, file15, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAspectRatio", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAspectRatio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAspectRatio",
      options,
      id: create_fragment15.name
    });
  }
};
var MdAspectRatio_default = MdAspectRatio;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssessment.svelte
var file16 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssessment.svelte";
function create_default_slot16(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z");
      add_location(path, file16, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssessment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssessment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssessment",
      options,
      id: create_fragment16.name
    });
  }
};
var MdAssessment_default = MdAssessment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignment.svelte
var file17 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignment.svelte";
function create_default_slot17(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z");
      add_location(path, file17, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssignment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssignment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssignment",
      options,
      id: create_fragment17.name
    });
  }
};
var MdAssignment_default = MdAssignment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentInd.svelte
var file18 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentInd.svelte";
function create_default_slot18(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 4c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1V19z");
      add_location(path, file18, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssignmentInd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssignmentInd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssignmentInd",
      options,
      id: create_fragment18.name
    });
  }
};
var MdAssignmentInd_default = MdAssignmentInd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentLate.svelte
var file19 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentLate.svelte";
function create_default_slot19(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-6 15h-2v-2h2v2zm0-4h-2V8h2v6zm-1-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z");
      add_location(path, file19, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssignmentLate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssignmentLate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssignmentLate",
      options,
      id: create_fragment19.name
    });
  }
};
var MdAssignmentLate_default = MdAssignmentLate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentReturn.svelte
var file20 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentReturn.svelte";
function create_default_slot20(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm4 12h-4v3l-5-5 5-5v3h4v4z");
      add_location(path, file20, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssignmentReturn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssignmentReturn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssignmentReturn",
      options,
      id: create_fragment20.name
    });
  }
};
var MdAssignmentReturn_default = MdAssignmentReturn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentReturned.svelte
var file21 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentReturned.svelte";
function create_default_slot21(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 15l-5-5h3V9h4v4h3l-5 5z");
      add_location(path, file21, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssignmentReturned", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssignmentReturned = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssignmentReturned",
      options,
      id: create_fragment21.name
    });
  }
};
var MdAssignmentReturned_default = MdAssignmentReturned;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentTurnedIn.svelte
var file22 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssignmentTurnedIn.svelte";
function create_default_slot22(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-2 14l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z");
      add_location(path, file22, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssignmentTurnedIn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssignmentTurnedIn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssignmentTurnedIn",
      options,
      id: create_fragment22.name
    });
  }
};
var MdAssignmentTurnedIn_default = MdAssignmentTurnedIn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAutorenew.svelte
var file23 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAutorenew.svelte";
function create_default_slot23(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z");
      add_location(path, file23, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAutorenew", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAutorenew = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAutorenew",
      options,
      id: create_fragment23.name
    });
  }
};
var MdAutorenew_default = MdAutorenew;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBackup.svelte
var file24 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBackup.svelte";
function create_default_slot24(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z");
      add_location(path, file24, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBackup", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBackup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBackup",
      options,
      id: create_fragment24.name
    });
  }
};
var MdBackup_default = MdBackup;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBook.svelte
var file25 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBook.svelte";
function create_default_slot25(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z");
      add_location(path, file25, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBook", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBook = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBook",
      options,
      id: create_fragment25.name
    });
  }
};
var MdBook_default = MdBook;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBookmark.svelte
var file26 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBookmark.svelte";
function create_default_slot26(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z");
      add_location(path, file26, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBookmark", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBookmark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBookmark",
      options,
      id: create_fragment26.name
    });
  }
};
var MdBookmark_default = MdBookmark;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBookmarkBorder.svelte
var file27 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBookmarkBorder.svelte";
function create_default_slot27(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z");
      add_location(path, file27, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBookmarkBorder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBookmarkBorder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBookmarkBorder",
      options,
      id: create_fragment27.name
    });
  }
};
var MdBookmarkBorder_default = MdBookmarkBorder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBugReport.svelte
var file28 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBugReport.svelte";
function create_default_slot28(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z");
      add_location(path, file28, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot28.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot28] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBugReport", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBugReport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBugReport",
      options,
      id: create_fragment28.name
    });
  }
};
var MdBugReport_default = MdBugReport;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBuild.svelte
var file29 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBuild.svelte";
function create_default_slot29(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z");
      add_location(path, file29, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot29.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot29] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBuild", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBuild = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBuild",
      options,
      id: create_fragment29.name
    });
  }
};
var MdBuild_default = MdBuild;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCached.svelte
var file30 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCached.svelte";
function create_default_slot30(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z");
      add_location(path, file30, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot30.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot30] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCached", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCached = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCached",
      options,
      id: create_fragment30.name
    });
  }
};
var MdCached_default = MdCached;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraEnhance.svelte
var file31 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraEnhance.svelte";
function create_default_slot31(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-1l1.25-2.75L16 13l-2.75-1.25L12 9l-1.25 2.75L8 13l2.75 1.25z");
      add_location(path, file31, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot31.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot31] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCameraEnhance", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCameraEnhance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCameraEnhance",
      options,
      id: create_fragment31.name
    });
  }
};
var MdCameraEnhance_default = MdCameraEnhance;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCardGiftcard.svelte
var file32 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCardGiftcard.svelte";
function create_default_slot32(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z");
      add_location(path, file32, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot32.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot32] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCardGiftcard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCardGiftcard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCardGiftcard",
      options,
      id: create_fragment32.name
    });
  }
};
var MdCardGiftcard_default = MdCardGiftcard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCardMembership.svelte
var file33 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCardMembership.svelte";
function create_default_slot33(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h4v5l4-2 4 2v-5h4c1.11 0 2-.89 2-2V4c0-1.11-.89-2-2-2zm0 13H4v-2h16v2zm0-5H4V4h16v6z");
      add_location(path, file33, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot33.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot33] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCardMembership", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCardMembership = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCardMembership",
      options,
      id: create_fragment33.name
    });
  }
};
var MdCardMembership_default = MdCardMembership;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCardTravel.svelte
var file34 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCardTravel.svelte";
function create_default_slot34(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-3V4c0-1.11-.89-2-2-2H9c-1.11 0-2 .89-2 2v2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zM9 4h6v2H9V4zm11 15H4v-2h16v2zm0-5H4V8h3v2h2V8h6v2h2V8h3v6z");
      add_location(path, file34, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot34.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot34] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCardTravel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCardTravel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCardTravel",
      options,
      id: create_fragment34.name
    });
  }
};
var MdCardTravel_default = MdCardTravel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChangeHistory.svelte
var file35 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChangeHistory.svelte";
function create_default_slot35(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 7.77L18.39 18H5.61L12 7.77M12 4L2 20h20L12 4z");
      add_location(path, file35, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot35.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot35] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChangeHistory", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChangeHistory = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChangeHistory",
      options,
      id: create_fragment35.name
    });
  }
};
var MdChangeHistory_default = MdChangeHistory;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheckCircle.svelte
var file36 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheckCircle.svelte";
function create_default_slot36(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
      add_location(path, file36, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot36.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot36] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCheckCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCheckCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCheckCircle",
      options,
      id: create_fragment36.name
    });
  }
};
var MdCheckCircle_default = MdCheckCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChromeReaderMode.svelte
var file37 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChromeReaderMode.svelte";
function create_default_slot37(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 12h7v1.5h-7zm0-2.5h7V11h-7zm0 5h7V16h-7zM21 4H3c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 15h-9V6h9v13z");
      add_location(path, file37, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot37.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot37] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChromeReaderMode", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChromeReaderMode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChromeReaderMode",
      options,
      id: create_fragment37.name
    });
  }
};
var MdChromeReaderMode_default = MdChromeReaderMode;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClass.svelte
var file38 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClass.svelte";
function create_default_slot38(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z");
      add_location(path, file38, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot38.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot38] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdClass", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdClass = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdClass",
      options,
      id: create_fragment38.name
    });
  }
};
var MdClass_default = MdClass;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCode.svelte
var file39 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCode.svelte";
function create_default_slot39(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z");
      add_location(path, file39, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot39.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot39] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCode", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCode",
      options,
      id: create_fragment39.name
    });
  }
};
var MdCode_default = MdCode;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCompareArrows.svelte
var file40 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCompareArrows.svelte";
function create_default_slot40(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.01 14H2v2h7.01v3L13 15l-3.99-4v3zm5.98-1v-3H22V8h-7.01V5L11 9l3.99 4z");
      add_location(path, file40, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot40.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot40] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCompareArrows", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCompareArrows = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCompareArrows",
      options,
      id: create_fragment40.name
    });
  }
};
var MdCompareArrows_default = MdCompareArrows;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCopyright.svelte
var file41 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCopyright.svelte";
function create_default_slot41(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.08 10.86c.05-.33.16-.62.3-.87s.34-.46.59-.62c.24-.15.54-.22.91-.23.23.01.44.05.63.13.2.09.38.21.52.36s.25.33.34.53.13.42.14.64h1.79c-.02-.47-.11-.9-.28-1.29s-.4-.73-.7-1.01-.66-.5-1.08-.66-.88-.23-1.39-.23c-.65 0-1.22.11-1.7.34s-.88.53-1.2.92-.56.84-.71 1.36S8 11.29 8 11.87v.27c0 .58.08 1.12.23 1.64s.39.97.71 1.35.72.69 1.2.91 1.05.34 1.7.34c.47 0 .91-.08 1.32-.23s.77-.36 1.08-.63.56-.58.74-.94.29-.74.3-1.15h-1.79c-.01.21-.06.4-.15.58s-.21.33-.36.46-.32.23-.52.3c-.19.07-.39.09-.6.1-.36-.01-.66-.08-.89-.23-.25-.16-.45-.37-.59-.62s-.25-.55-.3-.88-.08-.67-.08-1v-.27c0-.35.03-.68.08-1.01zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file41, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot41.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot41] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCopyright", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCopyright = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCopyright",
      options,
      id: create_fragment41.name
    });
  }
};
var MdCopyright_default = MdCopyright;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCreditCard.svelte
var file42 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCreditCard.svelte";
function create_default_slot42(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z");
      add_location(path, file42, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot42.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot42] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCreditCard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCreditCard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCreditCard",
      options,
      id: create_fragment42.name
    });
  }
};
var MdCreditCard_default = MdCreditCard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDashboard.svelte
var file43 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDashboard.svelte";
function create_default_slot43(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z");
      add_location(path, file43, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot43.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot43] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDashboard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDashboard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDashboard",
      options,
      id: create_fragment43.name
    });
  }
};
var MdDashboard_default = MdDashboard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDateRange.svelte
var file44 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDateRange.svelte";
function create_default_slot44(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z");
      add_location(path, file44, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot44.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot44] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDateRange", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDateRange = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDateRange",
      options,
      id: create_fragment44.name
    });
  }
};
var MdDateRange_default = MdDateRange;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDelete.svelte
var file45 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDelete.svelte";
function create_default_slot45(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z");
      add_location(path, file45, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot45.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot45] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDelete", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDelete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDelete",
      options,
      id: create_fragment45.name
    });
  }
};
var MdDelete_default = MdDelete;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeleteForever.svelte
var file46 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeleteForever.svelte";
function create_default_slot46(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z");
      add_location(path, file46, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot46.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment46(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot46] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDeleteForever", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDeleteForever = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDeleteForever",
      options,
      id: create_fragment46.name
    });
  }
};
var MdDeleteForever_default = MdDeleteForever;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDescription.svelte
var file47 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDescription.svelte";
function create_default_slot47(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z");
      add_location(path, file47, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot47.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot47] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDescription", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDescription = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDescription",
      options,
      id: create_fragment47.name
    });
  }
};
var MdDescription_default = MdDescription;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDns.svelte
var file48 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDns.svelte";
function create_default_slot48(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zM7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file48, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot48.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot48] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDns", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDns = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDns",
      options,
      id: create_fragment48.name
    });
  }
};
var MdDns_default = MdDns;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDone.svelte
var file49 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDone.svelte";
function create_default_slot49(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z");
      add_location(path, file49, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot49.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot49] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDone",
      options,
      id: create_fragment49.name
    });
  }
};
var MdDone_default = MdDone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoneAll.svelte
var file50 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoneAll.svelte";
function create_default_slot50(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z");
      add_location(path, file50, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot50.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot50] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDoneAll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDoneAll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDoneAll",
      options,
      id: create_fragment50.name
    });
  }
};
var MdDoneAll_default = MdDoneAll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDonutLarge.svelte
var file51 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDonutLarge.svelte";
function create_default_slot51(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 5.08V2c-5 .5-9 4.81-9 10s4 9.5 9 10v-3.08c-3-.48-6-3.4-6-6.92s3-6.44 6-6.92zM18.97 11H22c-.47-5-4-8.53-9-9v3.08C16 5.51 18.54 8 18.97 11zM13 18.92V22c5-.47 8.53-4 9-9h-3.03c-.43 3-2.97 5.49-5.97 5.92z");
      add_location(path, file51, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot51.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment51(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot51] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDonutLarge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDonutLarge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDonutLarge",
      options,
      id: create_fragment51.name
    });
  }
};
var MdDonutLarge_default = MdDonutLarge;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDonutSmall.svelte
var file52 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDonutSmall.svelte";
function create_default_slot52(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 9.16V2c-5 .5-9 4.79-9 10s4 9.5 9 10v-7.16c-1-.41-2-1.52-2-2.84s1-2.43 2-2.84zM14.86 11H22c-.48-4.75-4-8.53-9-9v7.16c1 .3 1.52.98 1.86 1.84zM13 14.84V22c5-.47 8.52-4.25 9-9h-7.14c-.34.86-.86 1.54-1.86 1.84z");
      add_location(path, file52, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot52.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment52(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot52] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDonutSmall", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDonutSmall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDonutSmall",
      options,
      id: create_fragment52.name
    });
  }
};
var MdDonutSmall_default = MdDonutSmall;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEject.svelte
var file53 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEject.svelte";
function create_default_slot53(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 17h14v2H5zm7-12L5.33 15h13.34z");
      add_location(path, file53, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot53.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot53] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEject", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEject",
      options,
      id: create_fragment53.name
    });
  }
};
var MdEject_default = MdEject;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEuroSymbol.svelte
var file54 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEuroSymbol.svelte";
function create_default_slot54(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 18.5c-2.51 0-4.68-1.42-5.76-3.5H15v-2H8.58c-.05-.33-.08-.66-.08-1s.03-.67.08-1H15V9H9.24C10.32 6.92 12.5 5.5 15 5.5c1.61 0 3.09.59 4.23 1.57L21 5.3C19.41 3.87 17.3 3 15 3c-3.92 0-7.24 2.51-8.48 6H3v2h3.06c-.04.33-.06.66-.06 1 0 .34.02.67.06 1H3v2h3.52c1.24 3.49 4.56 6 8.48 6 2.31 0 4.41-.87 6-2.3l-1.78-1.77c-1.13.98-2.6 1.57-4.22 1.57z");
      add_location(path, file54, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot54.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot54] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEuroSymbol", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEuroSymbol = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEuroSymbol",
      options,
      id: create_fragment54.name
    });
  }
};
var MdEuroSymbol_default = MdEuroSymbol;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEvent.svelte
var file55 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEvent.svelte";
function create_default_slot55(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z");
      add_location(path, file55, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot55.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot55] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEvent", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEvent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEvent",
      options,
      id: create_fragment55.name
    });
  }
};
var MdEvent_default = MdEvent;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventSeat.svelte
var file56 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventSeat.svelte";
function create_default_slot56(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 18v3h3v-3h10v3h3v-6H4zm15-8h3v3h-3zM2 10h3v3H2zm15 3H7V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v8z");
      add_location(path, file56, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot56.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot56] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEventSeat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEventSeat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEventSeat",
      options,
      id: create_fragment56.name
    });
  }
};
var MdEventSeat_default = MdEventSeat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExitToApp.svelte
var file57 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExitToApp.svelte";
function create_default_slot57(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
      add_location(path, file57, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot57.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot57] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExitToApp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExitToApp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExitToApp",
      options,
      id: create_fragment57.name
    });
  }
};
var MdExitToApp_default = MdExitToApp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExplore.svelte
var file58 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExplore.svelte";
function create_default_slot58(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm2.19 12.19L6 18l3.81-8.19L18 6l-3.81 8.19z");
      add_location(path, file58, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot58.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment58(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot58] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExplore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExplore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExplore",
      options,
      id: create_fragment58.name
    });
  }
};
var MdExplore_default = MdExplore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExtension.svelte
var file59 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExtension.svelte";
function create_default_slot59(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z");
      add_location(path, file59, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot59.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot59] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExtension", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExtension = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExtension",
      options,
      id: create_fragment59.name
    });
  }
};
var MdExtension_default = MdExtension;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFace.svelte
var file60 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFace.svelte";
function create_default_slot60(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z");
      add_location(path, file60, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot60.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot60] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFace", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFace = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFace",
      options,
      id: create_fragment60.name
    });
  }
};
var MdFace_default = MdFace;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFavorite.svelte
var file61 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFavorite.svelte";
function create_default_slot61(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z");
      add_location(path, file61, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot61.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment61(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot61] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFavorite", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFavorite = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFavorite",
      options,
      id: create_fragment61.name
    });
  }
};
var MdFavorite_default = MdFavorite;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFavoriteBorder.svelte
var file62 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFavoriteBorder.svelte";
function create_default_slot62(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z");
      add_location(path, file62, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot62.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot62] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFavoriteBorder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFavoriteBorder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFavoriteBorder",
      options,
      id: create_fragment62.name
    });
  }
};
var MdFavoriteBorder_default = MdFavoriteBorder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFeedback.svelte
var file63 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFeedback.svelte";
function create_default_slot63(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z");
      add_location(path, file63, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot63.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment63(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot63] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFeedback", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFeedback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFeedback",
      options,
      id: create_fragment63.name
    });
  }
};
var MdFeedback_default = MdFeedback;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFindInPage.svelte
var file64 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFindInPage.svelte";
function create_default_slot64(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 19.59V8l-6-6H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L20 19.59zM9 13c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z");
      add_location(path, file64, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot64.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot64] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFindInPage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFindInPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFindInPage",
      options,
      id: create_fragment64.name
    });
  }
};
var MdFindInPage_default = MdFindInPage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFindReplace.svelte
var file65 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFindReplace.svelte";
function create_default_slot65(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05C14.68 4.78 12.93 4 11 4c-3.53 0-6.43 2.61-6.92 6H6.1c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14H15.9c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05C7.32 17.22 9.07 18 11 18c1.55 0 2.98-.51 4.14-1.36L20 21.49 21.49 20l-4.85-4.86z");
      add_location(path, file65, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot65.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment65(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot65] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFindReplace", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFindReplace = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFindReplace",
      options,
      id: create_fragment65.name
    });
  }
};
var MdFindReplace_default = MdFindReplace;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFingerprint.svelte
var file66 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFingerprint.svelte";
function create_default_slot66(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.81 4.47c-.08 0-.16-.02-.23-.06C15.66 3.42 14 3 12.01 3c-1.98 0-3.86.47-5.57 1.41-.24.13-.54.04-.68-.2-.13-.24-.04-.55.2-.68C7.82 2.52 9.86 2 12.01 2c2.13 0 3.99.47 6.03 1.52.25.13.34.43.21.67-.09.18-.26.28-.44.28zM3.5 9.72c-.1 0-.2-.03-.29-.09-.23-.16-.28-.47-.12-.7.99-1.4 2.25-2.5 3.75-3.27C9.98 4.04 14 4.03 17.15 5.65c1.5.77 2.76 1.86 3.75 3.25.16.22.11.54-.12.7-.23.16-.54.11-.7-.12-.9-1.26-2.04-2.25-3.39-2.94-2.87-1.47-6.54-1.47-9.4.01-1.36.7-2.5 1.7-3.4 2.96-.08.14-.23.21-.39.21zm6.25 12.07c-.13 0-.26-.05-.35-.15-.87-.87-1.34-1.43-2.01-2.64-.69-1.23-1.05-2.73-1.05-4.34 0-2.97 2.54-5.39 5.66-5.39s5.66 2.42 5.66 5.39c0 .28-.22.5-.5.5s-.5-.22-.5-.5c0-2.42-2.09-4.39-4.66-4.39-2.57 0-4.66 1.97-4.66 4.39 0 1.44.32 2.77.93 3.85.64 1.15 1.08 1.64 1.85 2.42.19.2.19.51 0 .71-.11.1-.24.15-.37.15zm7.17-1.85c-1.19 0-2.24-.3-3.1-.89-1.49-1.01-2.38-2.65-2.38-4.39 0-.28.22-.5.5-.5s.5.22.5.5c0 1.41.72 2.74 1.94 3.56.71.48 1.54.71 2.54.71.24 0 .64-.03 1.04-.1.27-.05.53.13.58.41.05.27-.13.53-.41.58-.57.11-1.07.12-1.21.12zM14.91 22c-.04 0-.09-.01-.13-.02-1.59-.44-2.63-1.03-3.72-2.1-1.4-1.39-2.17-3.24-2.17-5.22 0-1.62 1.38-2.94 3.08-2.94 1.7 0 3.08 1.32 3.08 2.94 0 1.07.93 1.94 2.08 1.94s2.08-.87 2.08-1.94c0-3.77-3.25-6.83-7.25-6.83-2.84 0-5.44 1.58-6.61 4.03-.39.81-.59 1.76-.59 2.8 0 .78.07 2.01.67 3.61.1.26-.03.55-.29.64-.26.1-.55-.04-.64-.29-.49-1.31-.73-2.61-.73-3.96 0-1.2.23-2.29.68-3.24 1.33-2.79 4.28-4.6 7.51-4.6 4.55 0 8.25 3.51 8.25 7.83 0 1.62-1.38 2.94-3.08 2.94s-3.08-1.32-3.08-2.94c0-1.07-.93-1.94-2.08-1.94s-2.08.87-2.08 1.94c0 1.71.66 3.31 1.87 4.51.95.94 1.86 1.46 3.27 1.85.27.07.42.35.35.61-.05.23-.26.38-.47.38z");
      add_location(path, file66, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot66.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot66] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFingerprint", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFingerprint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFingerprint",
      options,
      id: create_fragment66.name
    });
  }
};
var MdFingerprint_default = MdFingerprint;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlightLand.svelte
var file67 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlightLand.svelte";
function create_default_slot67(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2.5 19h19v2h-19zm7.18-5.73l4.35 1.16 5.31 1.42c.8.21 1.62-.26 1.84-1.06.21-.8-.26-1.62-1.06-1.84l-5.31-1.42-2.76-9.02L10.12 2v8.28L5.15 8.95l-.93-2.32-1.45-.39v5.17l1.6.43 5.31 1.43z");
      add_location(path, file67, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot67.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot67] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlightLand", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlightLand = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlightLand",
      options,
      id: create_fragment67.name
    });
  }
};
var MdFlightLand_default = MdFlightLand;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlightTakeoff.svelte
var file68 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlightTakeoff.svelte";
function create_default_slot68(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2.5 19h19v2h-19zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.92 10l-6.9-6.43-1.93.51 4.14 7.17-4.97 1.33-1.97-1.54-1.45.39 1.82 3.16.77 1.33 1.6-.43 5.31-1.42 4.35-1.16L21 11.49c.81-.23 1.28-1.05 1.07-1.85z");
      add_location(path, file68, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot68.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment68(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot68] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlightTakeoff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlightTakeoff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlightTakeoff",
      options,
      id: create_fragment68.name
    });
  }
};
var MdFlightTakeoff_default = MdFlightTakeoff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlipToBack.svelte
var file69 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlipToBack.svelte";
function create_default_slot69(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 7H7v2h2V7zm0 4H7v2h2v-2zm0-8c-1.11 0-2 .9-2 2h2V3zm4 12h-2v2h2v-2zm6-12v2h2c0-1.1-.9-2-2-2zm-6 0h-2v2h2V3zM9 17v-2H7c0 1.1.89 2 2 2zm10-4h2v-2h-2v2zm0-4h2V7h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zM5 7H3v12c0 1.1.89 2 2 2h12v-2H5V7zm10-2h2V3h-2v2zm0 12h2v-2h-2v2z");
      add_location(path, file69, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot69.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot69] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlipToBack", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlipToBack = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlipToBack",
      options,
      id: create_fragment69.name
    });
  }
};
var MdFlipToBack_default = MdFlipToBack;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlipToFront.svelte
var file70 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlipToFront.svelte";
function create_default_slot70(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3c0 1.1.89 2 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9c-1.11 0-2 .9-2 2v10c0 1.1.89 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z");
      add_location(path, file70, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot70.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot70] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlipToFront", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlipToFront = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlipToFront",
      options,
      id: create_fragment70.name
    });
  }
};
var MdFlipToFront_default = MdFlipToFront;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGTranslate.svelte
var file71 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGTranslate.svelte";
function create_default_slot71(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 5h-9.12L10 2H4c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h7l1 3h8c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zM7.17 14.59c-2.25 0-4.09-1.83-4.09-4.09s1.83-4.09 4.09-4.09c1.04 0 1.99.37 2.74 1.07l.07.06-1.23 1.18-.06-.05c-.29-.27-.78-.59-1.52-.59-1.31 0-2.38 1.09-2.38 2.42s1.07 2.42 2.38 2.42c1.37 0 1.96-.87 2.12-1.46H7.08V9.91h3.95l.01.07c.04.21.05.4.05.61 0 2.35-1.61 4-3.92 4zm6.03-1.71c.33.6.74 1.18 1.19 1.7l-.54.53-.65-2.23zm.77-.76h-.99l-.31-1.04h3.99s-.34 1.31-1.56 2.74c-.52-.62-.89-1.23-1.13-1.7zM21 20c0 .55-.45 1-1 1h-7l2-2-.81-2.77.92-.92L17.79 18l.73-.73-2.71-2.68c.9-1.03 1.6-2.25 1.92-3.51H19v-1.04h-3.64V9h-1.04v1.04h-1.96L11.18 6H20c.55 0 1 .45 1 1v13z");
      add_location(path, file71, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot71.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment71(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot71] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGTranslate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGTranslate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGTranslate",
      options,
      id: create_fragment71.name
    });
  }
};
var MdGTranslate_default = MdGTranslate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGavel.svelte
var file72 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGavel.svelte";
function create_default_slot72(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 21h12v2H1zM5.245 8.07l2.83-2.827 14.14 14.142-2.828 2.828zM12.317 1l5.657 5.656-2.83 2.83-5.654-5.66zM3.825 9.485l5.657 5.657-2.828 2.828-5.657-5.657z");
      add_location(path, file72, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot72.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment72(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot72] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGavel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGavel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGavel",
      options,
      id: create_fragment72.name
    });
  }
};
var MdGavel_default = MdGavel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGetApp.svelte
var file73 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGetApp.svelte";
function create_default_slot73(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z");
      add_location(path, file73, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot73.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot73] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGetApp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGetApp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGetApp",
      options,
      id: create_fragment73.name
    });
  }
};
var MdGetApp_default = MdGetApp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGif.svelte
var file74 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGif.svelte";
function create_default_slot74(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.5 9H13v6h-1.5zM9 9H6c-.6 0-1 .5-1 1v4c0 .5.4 1 1 1h3c.6 0 1-.5 1-1v-2H8.5v1.5h-2v-3H10V10c0-.5-.4-1-1-1zm10 1.5V9h-4.5v6H16v-2h2v-1.5h-2v-1z");
      add_location(path, file74, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot74.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot74] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGif", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGif = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGif",
      options,
      id: create_fragment74.name
    });
  }
};
var MdGif_default = MdGif;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGrade.svelte
var file75 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGrade.svelte";
function create_default_slot75(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z");
      add_location(path, file75, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot75.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment75(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot75] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGrade", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGrade = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGrade",
      options,
      id: create_fragment75.name
    });
  }
};
var MdGrade_default = MdGrade;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGroupWork.svelte
var file76 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGroupWork.svelte";
function create_default_slot76(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM8 17.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM9.5 8c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8zm6.5 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z");
      add_location(path, file76, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot76.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment76(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot76] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGroupWork", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGroupWork = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGroupWork",
      options,
      id: create_fragment76.name
    });
  }
};
var MdGroupWork_default = MdGroupWork;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHelp.svelte
var file77 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHelp.svelte";
function create_default_slot77(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z");
      add_location(path, file77, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot77.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot77] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHelp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHelp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHelp",
      options,
      id: create_fragment77.name
    });
  }
};
var MdHelp_default = MdHelp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHelpOutline.svelte
var file78 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHelpOutline.svelte";
function create_default_slot78(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z");
      add_location(path, file78, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot78.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot78] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHelpOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHelpOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHelpOutline",
      options,
      id: create_fragment78.name
    });
  }
};
var MdHelpOutline_default = MdHelpOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHighlightOff.svelte
var file79 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHighlightOff.svelte";
function create_default_slot79(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file79, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot79.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot79] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHighlightOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHighlightOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHighlightOff",
      options,
      id: create_fragment79.name
    });
  }
};
var MdHighlightOff_default = MdHighlightOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHistory.svelte
var file80 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHistory.svelte";
function create_default_slot80(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z");
      add_location(path, file80, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot80.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot80] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHistory", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHistory = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHistory",
      options,
      id: create_fragment80.name
    });
  }
};
var MdHistory_default = MdHistory;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHome.svelte
var file81 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHome.svelte";
function create_default_slot81(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z");
      add_location(path, file81, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot81.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment81(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot81] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHome", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHome = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHome",
      options,
      id: create_fragment81.name
    });
  }
};
var MdHome_default = MdHome;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHourglassEmpty.svelte
var file82 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHourglassEmpty.svelte";
function create_default_slot82(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6zm10 14.5V20H8v-3.5l4-4 4 4zm-4-5l-4-4V4h8v3.5l-4 4z");
      add_location(path, file82, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot82.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment82(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot82] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHourglassEmpty", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHourglassEmpty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHourglassEmpty",
      options,
      id: create_fragment82.name
    });
  }
};
var MdHourglassEmpty_default = MdHourglassEmpty;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHourglassFull.svelte
var file83 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHourglassFull.svelte";
function create_default_slot83(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6z");
      add_location(path, file83, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot83.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot83] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHourglassFull", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHourglassFull = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHourglassFull",
      options,
      id: create_fragment83.name
    });
  }
};
var MdHourglassFull_default = MdHourglassFull;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHttp.svelte
var file84 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHttp.svelte";
function create_default_slot84(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4.5 11h-2V9H1v6h1.5v-2.5h2V15H6V9H4.5v2zm2.5-.5h1.5V15H10v-4.5h1.5V9H7v1.5zm5.5 0H14V15h1.5v-4.5H17V9h-4.5v1.5zm9-1.5H18v6h1.5v-2h2c.8 0 1.5-.7 1.5-1.5v-1c0-.8-.7-1.5-1.5-1.5zm0 2.5h-2v-1h2v1z");
      add_location(path, file84, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot84.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot84] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHttp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHttp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHttp",
      options,
      id: create_fragment84.name
    });
  }
};
var MdHttp_default = MdHttp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHttps.svelte
var file85 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHttps.svelte";
function create_default_slot85(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z");
      add_location(path, file85, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot85.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot85] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHttps", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHttps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHttps",
      options,
      id: create_fragment85.name
    });
  }
};
var MdHttps_default = MdHttps;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImportantDevices.svelte
var file86 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImportantDevices.svelte";
function create_default_slot86(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 11.01L18 11c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-9c0-.55-.45-.99-1-.99zM23 20h-5v-7h5v7zM20 2H2C.89 2 0 2.89 0 4v12c0 1.1.89 2 2 2h7v2H7v2h8v-2h-2v-2h2v-2H2V4h18v5h2V4c0-1.11-.9-2-2-2zm-8.03 7L11 6l-.97 3H7l2.47 1.76-.94 2.91 2.47-1.8 2.47 1.8-.94-2.91L15 9h-3.03z");
      add_location(path, file86, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot86.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment86(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot86] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdImportantDevices", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdImportantDevices = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdImportantDevices",
      options,
      id: create_fragment86.name
    });
  }
};
var MdImportantDevices_default = MdImportantDevices;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInfo.svelte
var file87 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInfo.svelte";
function create_default_slot87(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z");
      add_location(path, file87, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot87.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot87] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInfo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInfo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInfo",
      options,
      id: create_fragment87.name
    });
  }
};
var MdInfo_default = MdInfo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInfoOutline.svelte
var file88 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInfoOutline.svelte";
function create_default_slot88(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z");
      add_location(path, file88, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot88.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot88] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInfoOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInfoOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInfoOutline",
      options,
      id: create_fragment88.name
    });
  }
};
var MdInfoOutline_default = MdInfoOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInput.svelte
var file89 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInput.svelte";
function create_default_slot89(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z");
      add_location(path, file89, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot89.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment89(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot89] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInput", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInput",
      options,
      id: create_fragment89.name
    });
  }
};
var MdInput_default = MdInput;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInvertColors.svelte
var file90 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInvertColors.svelte";
function create_default_slot90(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.66 7.93L12 2.27 6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58c2.05 0 4.1-.78 5.66-2.34 3.12-3.12 3.12-8.19 0-11.31zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z");
      add_location(path, file90, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot90.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot90] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInvertColors", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInvertColors = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInvertColors",
      options,
      id: create_fragment90.name
    });
  }
};
var MdInvertColors_default = MdInvertColors;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLabel.svelte
var file91 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLabel.svelte";
function create_default_slot91(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z");
      add_location(path, file91, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot91.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot91] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLabel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLabel",
      options,
      id: create_fragment91.name
    });
  }
};
var MdLabel_default = MdLabel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLabelOutline.svelte
var file92 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLabelOutline.svelte";
function create_default_slot92(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16zM16 17H5V7h11l3.55 5L16 17z");
      add_location(path, file92, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot92.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot92] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLabelOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLabelOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLabelOutline",
      options,
      id: create_fragment92.name
    });
  }
};
var MdLabelOutline_default = MdLabelOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLanguage.svelte
var file93 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLanguage.svelte";
function create_default_slot93(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z");
      add_location(path, file93, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot93.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment93(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot93] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance93($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLanguage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLanguage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLanguage",
      options,
      id: create_fragment93.name
    });
  }
};
var MdLanguage_default = MdLanguage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaunch.svelte
var file94 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaunch.svelte";
function create_default_slot94(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z");
      add_location(path, file94, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot94.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment94(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot94] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance94($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLaunch", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLaunch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLaunch",
      options,
      id: create_fragment94.name
    });
  }
};
var MdLaunch_default = MdLaunch;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLightbulbOutline.svelte
var file95 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLightbulbOutline.svelte";
function create_default_slot95(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z");
      add_location(path, file95, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot95.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot95] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance95($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLightbulbOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLightbulbOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLightbulbOutline",
      options,
      id: create_fragment95.name
    });
  }
};
var MdLightbulbOutline_default = MdLightbulbOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLineStyle.svelte
var file96 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLineStyle.svelte";
function create_default_slot96(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 16h5v-2H3v2zm6.5 0h5v-2h-5v2zm6.5 0h5v-2h-5v2zM3 20h2v-2H3v2zm4 0h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM3 12h8v-2H3v2zm10 0h8v-2h-8v2zM3 4v4h18V4H3z");
      add_location(path, file96, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot96.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment96(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot96] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance96($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLineStyle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLineStyle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLineStyle",
      options,
      id: create_fragment96.name
    });
  }
};
var MdLineStyle_default = MdLineStyle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLineWeight.svelte
var file97 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLineWeight.svelte";
function create_default_slot97(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 17h18v-2H3v2zm0 3h18v-1H3v1zm0-7h18v-3H3v3zm0-9v4h18V4H3z");
      add_location(path, file97, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot97.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment97(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot97] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance97($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLineWeight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLineWeight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLineWeight",
      options,
      id: create_fragment97.name
    });
  }
};
var MdLineWeight_default = MdLineWeight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdList.svelte
var file98 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdList.svelte";
function create_default_slot98(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z");
      add_location(path, file98, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot98.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment98(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot98] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance98($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdList", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdList",
      options,
      id: create_fragment98.name
    });
  }
};
var MdList_default = MdList;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLock.svelte
var file99 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLock.svelte";
function create_default_slot99(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z");
      add_location(path, file99, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot99.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment99(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot99] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance99($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLock",
      options,
      id: create_fragment99.name
    });
  }
};
var MdLock_default = MdLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLockOpen.svelte
var file100 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLockOpen.svelte";
function create_default_slot100(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z");
      add_location(path, file100, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot100.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment100(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot100] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance100($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLockOpen", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLockOpen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLockOpen",
      options,
      id: create_fragment100.name
    });
  }
};
var MdLockOpen_default = MdLockOpen;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLockOutline.svelte
var file101 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLockOutline.svelte";
function create_default_slot101(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H8.9V6zM18 20H6V10h12v10z");
      add_location(path, file101, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot101.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment101(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot101] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance101($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLockOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLockOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance101, create_fragment101, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLockOutline",
      options,
      id: create_fragment101.name
    });
  }
};
var MdLockOutline_default = MdLockOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLoyalty.svelte
var file102 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLoyalty.svelte";
function create_default_slot102(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7zm11.77 8.27L13 19.54l-4.27-4.27C8.28 14.81 8 14.19 8 13.5c0-1.38 1.12-2.5 2.5-2.5.69 0 1.32.28 1.77.74l.73.72.73-.73c.45-.45 1.08-.73 1.77-.73 1.38 0 2.5 1.12 2.5 2.5 0 .69-.28 1.32-.73 1.77z");
      add_location(path, file102, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot102.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment102(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot102] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance102($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLoyalty", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLoyalty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance102, create_fragment102, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLoyalty",
      options,
      id: create_fragment102.name
    });
  }
};
var MdLoyalty_default = MdLoyalty;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMarkunreadMailbox.svelte
var file103 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMarkunreadMailbox.svelte";
function create_default_slot103(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6H10v6H8V4h6V0H6v6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z");
      add_location(path, file103, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot103.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment103(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot103] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment103.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance103($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMarkunreadMailbox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMarkunreadMailbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance103, create_fragment103, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMarkunreadMailbox",
      options,
      id: create_fragment103.name
    });
  }
};
var MdMarkunreadMailbox_default = MdMarkunreadMailbox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMotorcycle.svelte
var file104 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMotorcycle.svelte";
function create_default_slot104(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.44 9.03L15.41 5H11v2h3.59l2 2H5c-2.8 0-5 2.2-5 5s2.2 5 5 5c2.46 0 4.45-1.69 4.9-4h1.65l2.77-2.77c-.21.54-.32 1.14-.32 1.77 0 2.8 2.2 5 5 5s5-2.2 5-5c0-2.65-1.97-4.77-4.56-4.97zM7.82 15C7.4 16.15 6.28 17 5 17c-1.63 0-3-1.37-3-3s1.37-3 3-3c1.28 0 2.4.85 2.82 2H5v2h2.82zM19 17c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z");
      add_location(path, file104, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot104.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment104(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot104] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment104.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance104($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMotorcycle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMotorcycle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance104, create_fragment104, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMotorcycle",
      options,
      id: create_fragment104.name
    });
  }
};
var MdMotorcycle_default = MdMotorcycle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNoteAdd.svelte
var file105 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNoteAdd.svelte";
function create_default_slot105(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z");
      add_location(path, file105, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot105.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment105(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot105] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment105.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance105($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNoteAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNoteAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance105, create_fragment105, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNoteAdd",
      options,
      id: create_fragment105.name
    });
  }
};
var MdNoteAdd_default = MdNoteAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOfflinePin.svelte
var file106 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOfflinePin.svelte";
function create_default_slot106(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm5 16H7v-2h10v2zm-6.7-4L7 10.7l1.4-1.4 1.9 1.9 5.3-5.3L17 7.3 10.3 14z");
      add_location(path, file106, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot106.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment106(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot106] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment106.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance106($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdOfflinePin", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdOfflinePin = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance106, create_fragment106, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdOfflinePin",
      options,
      id: create_fragment106.name
    });
  }
};
var MdOfflinePin_default = MdOfflinePin;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpacity.svelte
var file107 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpacity.svelte";
function create_default_slot107(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.66 8L12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z");
      add_location(path, file107, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot107.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment107(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot107] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment107.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance107($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdOpacity", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdOpacity = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance107, create_fragment107, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdOpacity",
      options,
      id: create_fragment107.name
    });
  }
};
var MdOpacity_default = MdOpacity;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpenInBrowser.svelte
var file108 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpenInBrowser.svelte";
function create_default_slot108(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h4v-2H5V8h14v10h-4v2h4c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm-7 6l-4 4h3v6h2v-6h3l-4-4z");
      add_location(path, file108, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot108.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment108(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot108] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment108.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance108($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdOpenInBrowser", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdOpenInBrowser = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance108, create_fragment108, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdOpenInBrowser",
      options,
      id: create_fragment108.name
    });
  }
};
var MdOpenInBrowser_default = MdOpenInBrowser;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpenInNew.svelte
var file109 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpenInNew.svelte";
function create_default_slot109(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z");
      add_location(path, file109, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot109.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment109(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot109] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment109.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance109($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdOpenInNew", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdOpenInNew = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance109, create_fragment109, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdOpenInNew",
      options,
      id: create_fragment109.name
    });
  }
};
var MdOpenInNew_default = MdOpenInNew;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpenWith.svelte
var file110 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOpenWith.svelte";
function create_default_slot110(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z");
      add_location(path, file110, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot110.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment110(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot110] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment110.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance110($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdOpenWith", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdOpenWith = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance110, create_fragment110, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdOpenWith",
      options,
      id: create_fragment110.name
    });
  }
};
var MdOpenWith_default = MdOpenWith;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPageview.svelte
var file111 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPageview.svelte";
function create_default_slot111(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.5 9C10.12 9 9 10.12 9 11.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5S12.88 9 11.5 9zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-3.21 14.21l-2.91-2.91c-.69.44-1.51.7-2.39.7C9.01 16 7 13.99 7 11.5S9.01 7 11.5 7 16 9.01 16 11.5c0 .88-.26 1.69-.7 2.39l2.91 2.9-1.42 1.42z");
      add_location(path, file111, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot111.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment111(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot111] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment111.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance111($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPageview", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPageview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance111, create_fragment111, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPageview",
      options,
      id: create_fragment111.name
    });
  }
};
var MdPageview_default = MdPageview;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanTool.svelte
var file112 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanTool.svelte";
function create_default_slot112(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z");
      add_location(path, file112, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot112.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment112(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot112] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment112.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance112($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPanTool", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPanTool = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance112, create_fragment112, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPanTool",
      options,
      id: create_fragment112.name
    });
  }
};
var MdPanTool_default = MdPanTool;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPayment.svelte
var file113 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPayment.svelte";
function create_default_slot113(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z");
      add_location(path, file113, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot113.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment113(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot113] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment113.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance113($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPayment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPayment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance113, create_fragment113, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPayment",
      options,
      id: create_fragment113.name
    });
  }
};
var MdPayment_default = MdPayment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermCameraMic.svelte
var file114 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermCameraMic.svelte";
function create_default_slot114(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v-2.09c-2.83-.48-5-2.94-5-5.91h2c0 2.21 1.79 4 4 4s4-1.79 4-4h2c0 2.97-2.17 5.43-5 5.91V21h7c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-6 8c0 1.1-.9 2-2 2s-2-.9-2-2V9c0-1.1.9-2 2-2s2 .9 2 2v4z");
      add_location(path, file114, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot114.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment114(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot114] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment114.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance114($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermCameraMic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermCameraMic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance114, create_fragment114, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermCameraMic",
      options,
      id: create_fragment114.name
    });
  }
};
var MdPermCameraMic_default = MdPermCameraMic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermContactCalendar.svelte
var file115 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermContactCalendar.svelte";
function create_default_slot115(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z");
      add_location(path, file115, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot115.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment115(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot115] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment115.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance115($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermContactCalendar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermContactCalendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance115, create_fragment115, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermContactCalendar",
      options,
      id: create_fragment115.name
    });
  }
};
var MdPermContactCalendar_default = MdPermContactCalendar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermDataSetting.svelte
var file116 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermDataSetting.svelte";
function create_default_slot116(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.99 11.5c.34 0 .67.03 1 .07L20 0 0 20h11.56c-.04-.33-.07-.66-.07-1 0-4.14 3.36-7.5 7.5-7.5zm3.71 7.99c.02-.16.04-.32.04-.49 0-.17-.01-.33-.04-.49l1.06-.83c.09-.08.12-.21.06-.32l-1-1.73c-.06-.11-.19-.15-.31-.11l-1.24.5c-.26-.2-.54-.37-.85-.49l-.19-1.32c-.01-.12-.12-.21-.24-.21h-2c-.12 0-.23.09-.25.21l-.19 1.32c-.3.13-.59.29-.85.49l-1.24-.5c-.11-.04-.24 0-.31.11l-1 1.73c-.06.11-.04.24.06.32l1.06.83c-.02.16-.03.32-.03.49 0 .17.01.33.03.49l-1.06.83c-.09.08-.12.21-.06.32l1 1.73c.06.11.19.15.31.11l1.24-.5c.26.2.54.37.85.49l.19 1.32c.02.12.12.21.25.21h2c.12 0 .23-.09.25-.21l.19-1.32c.3-.13.59-.29.84-.49l1.25.5c.11.04.24 0 .31-.11l1-1.73c.06-.11.03-.24-.06-.32l-1.07-.83zm-3.71 1.01c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file116, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot116.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment116(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot116] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment116.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance116($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermDataSetting", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermDataSetting = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance116, create_fragment116, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermDataSetting",
      options,
      id: create_fragment116.name
    });
  }
};
var MdPermDataSetting_default = MdPermDataSetting;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermDeviceInformation.svelte
var file117 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermDeviceInformation.svelte";
function create_default_slot117(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 7h-2v2h2V7zm0 4h-2v6h2v-6zm4-9.99L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z");
      add_location(path, file117, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot117.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment117(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot117] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment117.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance117($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermDeviceInformation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermDeviceInformation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance117, create_fragment117, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermDeviceInformation",
      options,
      id: create_fragment117.name
    });
  }
};
var MdPermDeviceInformation_default = MdPermDeviceInformation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermIdentity.svelte
var file118 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermIdentity.svelte";
function create_default_slot118(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z");
      add_location(path, file118, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot118.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment118(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot118] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment118.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance118($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermIdentity", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermIdentity = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance118, create_fragment118, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermIdentity",
      options,
      id: create_fragment118.name
    });
  }
};
var MdPermIdentity_default = MdPermIdentity;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermMedia.svelte
var file119 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermMedia.svelte";
function create_default_slot119(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 6H0v5h.01L0 20c0 1.1.9 2 2 2h18v-2H2V6zm20-2h-8l-2-2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7 15l4.5-6 3.5 4.51 2.5-3.01L21 15H7z");
      add_location(path, file119, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot119.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment119(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot119] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment119.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance119($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermMedia", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermMedia = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance119, create_fragment119, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermMedia",
      options,
      id: create_fragment119.name
    });
  }
};
var MdPermMedia_default = MdPermMedia;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermPhoneMsg.svelte
var file120 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermPhoneMsg.svelte";
function create_default_slot120(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM12 3v10l3-3h6V3h-9z");
      add_location(path, file120, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot120.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment120(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot120] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment120.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance120($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermPhoneMsg", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermPhoneMsg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance120, create_fragment120, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermPhoneMsg",
      options,
      id: create_fragment120.name
    });
  }
};
var MdPermPhoneMsg_default = MdPermPhoneMsg;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermScanWifi.svelte
var file121 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPermScanWifi.svelte";
function create_default_slot121(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3C6.95 3 3.15 4.85 0 7.23L12 22 24 7.25C20.85 4.87 17.05 3 12 3zm1 13h-2v-6h2v6zm-2-8V6h2v2h-2z");
      add_location(path, file121, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot121.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment121(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot121] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment121.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance121($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPermScanWifi", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPermScanWifi = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance121, create_fragment121, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPermScanWifi",
      options,
      id: create_fragment121.name
    });
  }
};
var MdPermScanWifi_default = MdPermScanWifi;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPets.svelte
var file122 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPets.svelte";
function create_default_slot122(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  let t2;
  let path3;
  let t3;
  let path4;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      t2 = space();
      path3 = svg_element("path");
      t3 = space();
      path4 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      t2 = claim_space(nodes);
      path3 = claim_svg_element(nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      t3 = claim_space(nodes);
      path4 = claim_svg_element(nodes, "path", { d: true });
      children(path4).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file122, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file122, 5, 0, 174);
      attr_dev(path2, "d", "undefined");
      add_location(path2, file122, 6, 0, 197);
      attr_dev(path3, "d", "undefined");
      add_location(path3, file122, 7, 0, 220);
      attr_dev(path4, "d", "M17.34 14.86c-.87-1.02-1.6-1.89-2.48-2.91-.46-.54-1.05-1.08-1.75-1.32-.11-.04-.22-.07-.33-.09-.25-.04-.52-.04-.78-.04s-.53 0-.79.05c-.11.02-.22.05-.33.09-.7.24-1.28.78-1.75 1.32-.87 1.02-1.6 1.89-2.48 2.91-1.31 1.31-2.92 2.76-2.62 4.79.29 1.02 1.02 2.03 2.33 2.32.73.15 3.06-.44 5.54-.44h.18c2.48 0 4.81.58 5.54.44 1.31-.29 2.04-1.31 2.33-2.32.31-2.04-1.3-3.49-2.61-4.8z");
      add_location(path4, file122, 8, 0, 243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, path3, anchor);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, path4, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
        detach_dev(t2);
        detach_dev(path3);
        detach_dev(t3);
        detach_dev(path4);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot122.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment122(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot122] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment122.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance122($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPets", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPets = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance122, create_fragment122, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPets",
      options,
      id: create_fragment122.name
    });
  }
};
var MdPets_default = MdPets;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPictureInPicture.svelte
var file123 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPictureInPicture.svelte";
function create_default_slot123(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 7h-8v6h8V7zm2-4H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z");
      add_location(path, file123, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot123.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment123(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot123] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment123.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance123($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPictureInPicture", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPictureInPicture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance123, create_fragment123, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPictureInPicture",
      options,
      id: create_fragment123.name
    });
  }
};
var MdPictureInPicture_default = MdPictureInPicture;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPictureInPictureAlt.svelte
var file124 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPictureInPictureAlt.svelte";
function create_default_slot124(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z");
      add_location(path, file124, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot124.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment124(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot124] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment124.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance124($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPictureInPictureAlt", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPictureInPictureAlt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance124, create_fragment124, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPictureInPictureAlt",
      options,
      id: create_fragment124.name
    });
  }
};
var MdPictureInPictureAlt_default = MdPictureInPictureAlt;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayForWork.svelte
var file125 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayForWork.svelte";
function create_default_slot125(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 5v5.59H7.5l4.5 4.5 4.5-4.5H13V5h-2zm-5 9c0 3.31 2.69 6 6 6s6-2.69 6-6h-2c0 2.21-1.79 4-4 4s-4-1.79-4-4H6z");
      add_location(path, file125, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot125.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment125(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot125] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment125.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance125($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlayForWork", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlayForWork = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance125, create_fragment125, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlayForWork",
      options,
      id: create_fragment125.name
    });
  }
};
var MdPlayForWork_default = MdPlayForWork;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPolymer.svelte
var file126 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPolymer.svelte";
function create_default_slot126(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 4h-4L7.11 16.63 4.5 12 9 4H5L.5 12 5 20h4l7.89-12.63L19.5 12 15 20h4l4.5-8z");
      add_location(path, file126, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot126.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment126(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot126] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment126.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance126($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPolymer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPolymer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance126, create_fragment126, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPolymer",
      options,
      id: create_fragment126.name
    });
  }
};
var MdPolymer_default = MdPolymer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPowerSettingsNew.svelte
var file127 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPowerSettingsNew.svelte";
function create_default_slot127(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z");
      add_location(path, file127, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot127.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment127(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot127] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment127.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance127($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPowerSettingsNew", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPowerSettingsNew = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance127, create_fragment127, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPowerSettingsNew",
      options,
      id: create_fragment127.name
    });
  }
};
var MdPowerSettingsNew_default = MdPowerSettingsNew;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPregnantWoman.svelte
var file128 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPregnantWoman.svelte";
function create_default_slot128(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zm7 9c-.01-1.34-.83-2.51-2-3 0-1.66-1.34-3-3-3s-3 1.34-3 3v7h2v5h3v-5h3v-4z");
      add_location(path, file128, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot128.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment128(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot128] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment128.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance128($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPregnantWoman", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPregnantWoman = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance128, create_fragment128, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPregnantWoman",
      options,
      id: create_fragment128.name
    });
  }
};
var MdPregnantWoman_default = MdPregnantWoman;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPrint.svelte
var file129 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPrint.svelte";
function create_default_slot129(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z");
      add_location(path, file129, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot129.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment129(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot129] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment129.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance129($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPrint", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPrint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance129, create_fragment129, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPrint",
      options,
      id: create_fragment129.name
    });
  }
};
var MdPrint_default = MdPrint;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueryBuilder.svelte
var file130 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueryBuilder.svelte";
function create_default_slot130(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z");
      add_location(path, file130, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot130.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment130(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot130] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment130.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance130($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdQueryBuilder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdQueryBuilder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance130, create_fragment130, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdQueryBuilder",
      options,
      id: create_fragment130.name
    });
  }
};
var MdQueryBuilder_default = MdQueryBuilder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQuestionAnswer.svelte
var file131 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQuestionAnswer.svelte";
function create_default_slot131(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z");
      add_location(path, file131, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot131.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment131(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot131] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment131.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance131($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdQuestionAnswer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdQuestionAnswer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance131, create_fragment131, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdQuestionAnswer",
      options,
      id: create_fragment131.name
    });
  }
};
var MdQuestionAnswer_default = MdQuestionAnswer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReceipt.svelte
var file132 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReceipt.svelte";
function create_default_slot132(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 17H6v-2h12v2zm0-4H6v-2h12v2zm0-4H6V7h12v2zM3 22l1.5-1.5L6 22l1.5-1.5L9 22l1.5-1.5L12 22l1.5-1.5L15 22l1.5-1.5L18 22l1.5-1.5L21 22V2l-1.5 1.5L18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2 4.5 3.5 3 2v20z");
      add_location(path, file132, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot132.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment132(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot132] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment132.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance132($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReceipt", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReceipt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance132, create_fragment132, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReceipt",
      options,
      id: create_fragment132.name
    });
  }
};
var MdReceipt_default = MdReceipt;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRecordVoiceOver.svelte
var file133 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRecordVoiceOver.svelte";
function create_default_slot133(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file133, 4, 10, 151);
      attr_dev(path1, "d", "M9 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4zm7.76-9.64l-1.68 1.69c.84 1.18.84 2.71 0 3.89l1.68 1.69c2.02-2.02 2.02-5.07 0-7.27zM20.07 2l-1.63 1.63c2.77 3.02 2.77 7.56 0 10.74L20.07 16c3.9-3.89 3.91-9.95 0-14z");
      add_location(path1, file133, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot133.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment133(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot133] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment133.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance133($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRecordVoiceOver", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRecordVoiceOver = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance133, create_fragment133, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRecordVoiceOver",
      options,
      id: create_fragment133.name
    });
  }
};
var MdRecordVoiceOver_default = MdRecordVoiceOver;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRedeem.svelte
var file134 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRedeem.svelte";
function create_default_slot134(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z");
      add_location(path, file134, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot134.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment134(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot134] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment134.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance134($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRedeem", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRedeem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance134, create_fragment134, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRedeem",
      options,
      id: create_fragment134.name
    });
  }
};
var MdRedeem_default = MdRedeem;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveShoppingCart.svelte
var file135 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveShoppingCart.svelte";
function create_default_slot135(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.73 22.73L2.77 2.77 2 2l-.73-.73L0 2.54l4.39 4.39 2.21 4.66-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h7.46l1.38 1.38c-.5.36-.83.95-.83 1.62 0 1.1.89 2 1.99 2 .67 0 1.26-.33 1.62-.84L21.46 24l1.27-1.27zM7.42 15c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h2.36l2 2H7.42zm8.13-2c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H6.54l9.01 9zM7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2z");
      add_location(path, file135, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot135.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment135(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot135] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment135.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance135($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRemoveShoppingCart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRemoveShoppingCart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance135, create_fragment135, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRemoveShoppingCart",
      options,
      id: create_fragment135.name
    });
  }
};
var MdRemoveShoppingCart_default = MdRemoveShoppingCart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReorder.svelte
var file136 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReorder.svelte";
function create_default_slot136(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z");
      add_location(path, file136, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot136.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment136(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot136] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment136.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance136($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReorder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReorder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance136, create_fragment136, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReorder",
      options,
      id: create_fragment136.name
    });
  }
};
var MdReorder_default = MdReorder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReportProblem.svelte
var file137 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReportProblem.svelte";
function create_default_slot137(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z");
      add_location(path, file137, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot137.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment137(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot137] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment137.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance137($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReportProblem", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReportProblem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance137, create_fragment137, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReportProblem",
      options,
      id: create_fragment137.name
    });
  }
};
var MdReportProblem_default = MdReportProblem;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestore.svelte
var file138 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestore.svelte";
function create_default_slot138(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z");
      add_location(path, file138, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot138.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment138(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot138] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment138.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance138($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRestore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRestore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance138, create_fragment138, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRestore",
      options,
      id: create_fragment138.name
    });
  }
};
var MdRestore_default = MdRestore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestorePage.svelte
var file139 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestorePage.svelte";
function create_default_slot139(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm-2 16c-2.05 0-3.81-1.24-4.58-3h1.71c.63.9 1.68 1.5 2.87 1.5 1.93 0 3.5-1.57 3.5-3.5S13.93 9.5 12 9.5c-1.35 0-2.52.78-3.1 1.9l1.6 1.6h-4V9l1.3 1.3C8.69 8.92 10.23 8 12 8c2.76 0 5 2.24 5 5s-2.24 5-5 5z");
      add_location(path, file139, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot139.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment139(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot139] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment139.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance139($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRestorePage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRestorePage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance139, create_fragment139, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRestorePage",
      options,
      id: create_fragment139.name
    });
  }
};
var MdRestorePage_default = MdRestorePage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRoom.svelte
var file140 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRoom.svelte";
function create_default_slot140(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z");
      add_location(path, file140, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot140.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment140(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot140] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment140.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance140($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRoom", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRoom = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance140, create_fragment140, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRoom",
      options,
      id: create_fragment140.name
    });
  }
};
var MdRoom_default = MdRoom;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRoundedCorner.svelte
var file141 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRoundedCorner.svelte";
function create_default_slot141(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 19h2v2h-2v-2zm0-2h2v-2h-2v2zM3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm0-4h2V3H3v2zm4 0h2V3H7v2zm8 16h2v-2h-2v2zm-4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm-8 0h2v-2H7v2zm-4 0h2v-2H3v2zM21 8c0-2.76-2.24-5-5-5h-5v2h5c1.65 0 3 1.35 3 3v5h2V8z");
      add_location(path, file141, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot141.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment141(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot141] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment141.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance141($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRoundedCorner", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRoundedCorner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance141, create_fragment141, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRoundedCorner",
      options,
      id: create_fragment141.name
    });
  }
};
var MdRoundedCorner_default = MdRoundedCorner;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRowing.svelte
var file142 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRowing.svelte";
function create_default_slot142(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8.5 14.5L4 19l1.5 1.5L9 17h2l-2.5-2.5zM15 1c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 20.01L18 24l-2.99-3.01V19.5l-7.1-7.09c-.31.05-.61.07-.91.07v-2.16c1.66.03 3.61-.87 4.67-2.04l1.4-1.55c.19-.21.43-.38.69-.5.29-.14.62-.23.96-.23h.03C15.99 6.01 17 7.02 17 8.26v5.75c0 .84-.35 1.61-.92 2.16l-3.58-3.58v-2.27c-.63.52-1.43 1.02-2.29 1.39L16.5 18H18l3 3.01z");
      add_location(path, file142, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot142.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment142(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot142] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment142.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance142($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRowing", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRowing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance142, create_fragment142, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRowing",
      options,
      id: create_fragment142.name
    });
  }
};
var MdRowing_default = MdRowing;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSchedule.svelte
var file143 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSchedule.svelte";
function create_default_slot143(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z");
      add_location(path, file143, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot143.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment143(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot143] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment143.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance143($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSchedule", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSchedule = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance143, create_fragment143, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSchedule",
      options,
      id: create_fragment143.name
    });
  }
};
var MdSchedule_default = MdSchedule;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSearch.svelte
var file144 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSearch.svelte";
function create_default_slot144(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z");
      add_location(path, file144, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot144.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment144(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot144] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment144.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance144($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSearch", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance144, create_fragment144, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSearch",
      options,
      id: create_fragment144.name
    });
  }
};
var MdSearch_default = MdSearch;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettings.svelte
var file145 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettings.svelte";
function create_default_slot145(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z");
      add_location(path, file145, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot145.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment145(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot145] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment145.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance145($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettings", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettings = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance145, create_fragment145, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettings",
      options,
      id: create_fragment145.name
    });
  }
};
var MdSettings_default = MdSettings;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsApplications.svelte
var file146 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsApplications.svelte";
function create_default_slot146(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42c-.09-.15-.05-.34.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16c-.13-.11-.17-.3-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z");
      add_location(path, file146, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot146.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment146(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot146] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment146.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance146($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsApplications", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsApplications = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance146, create_fragment146, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsApplications",
      options,
      id: create_fragment146.name
    });
  }
};
var MdSettingsApplications_default = MdSettingsApplications;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsBackupRestore.svelte
var file147 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsBackupRestore.svelte";
function create_default_slot147(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 12c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-9c-4.97 0-9 4.03-9 9H0l4 4 4-4H5c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.44C8.04 20.3 9.94 21 12 21c4.97 0 9-4.03 9-9s-4.03-9-9-9z");
      add_location(path, file147, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot147.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment147(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot147] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment147.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance147($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsBackupRestore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsBackupRestore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance147, create_fragment147, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsBackupRestore",
      options,
      id: create_fragment147.name
    });
  }
};
var MdSettingsBackupRestore_default = MdSettingsBackupRestore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsBluetooth.svelte
var file148 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsBluetooth.svelte";
function create_default_slot148(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 24h2v-2h-2v2zm-4 0h2v-2H7v2zm8 0h2v-2h-2v2zm2.71-18.29L12 0h-1v7.59L6.41 3 5 4.41 10.59 10 5 15.59 6.41 17 11 12.41V20h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 3.83l1.88 1.88L13 7.59V3.83zm1.88 10.46L13 16.17v-3.76l1.88 1.88z");
      add_location(path, file148, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot148.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment148(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot148] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment148.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance148($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsBluetooth", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsBluetooth = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance148, create_fragment148, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsBluetooth",
      options,
      id: create_fragment148.name
    });
  }
};
var MdSettingsBluetooth_default = MdSettingsBluetooth;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsBrightness.svelte
var file149 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsBrightness.svelte";
function create_default_slot149(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02zM8 16h2.5l1.5 1.5 1.5-1.5H16v-2.5l1.5-1.5-1.5-1.5V8h-2.5L12 6.5 10.5 8H8v2.5L6.5 12 8 13.5V16zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3V9z");
      add_location(path, file149, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot149.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment149(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot149] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment149.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance149($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsBrightness", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsBrightness = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance149, create_fragment149, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsBrightness",
      options,
      id: create_fragment149.name
    });
  }
};
var MdSettingsBrightness_default = MdSettingsBrightness;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsCell.svelte
var file150 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsCell.svelte";
function create_default_slot150(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM16 .01L8 0C6.9 0 6 .9 6 2v16c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V2c0-1.1-.9-1.99-2-1.99zM16 16H8V4h8v12z");
      add_location(path, file150, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot150.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment150(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot150] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment150.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance150($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsCell", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance150, create_fragment150, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsCell",
      options,
      id: create_fragment150.name
    });
  }
};
var MdSettingsCell_default = MdSettingsCell;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsEthernet.svelte
var file151 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsEthernet.svelte";
function create_default_slot151(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.77 6.76L6.23 5.48.82 12l5.41 6.52 1.54-1.28L3.42 12l4.35-5.24zM7 13h2v-2H7v2zm10-2h-2v2h2v-2zm-6 2h2v-2h-2v2zm6.77-7.52l-1.54 1.28L20.58 12l-4.35 5.24 1.54 1.28L23.18 12l-5.41-6.52z");
      add_location(path, file151, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot151.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment151(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot151] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment151.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance151($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsEthernet", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsEthernet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance151, create_fragment151, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsEthernet",
      options,
      id: create_fragment151.name
    });
  }
};
var MdSettingsEthernet_default = MdSettingsEthernet;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputAntenna.svelte
var file152 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputAntenna.svelte";
function create_default_slot152(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5S9.5 10.62 9.5 12c0 1.02.62 1.9 1.5 2.29v3.3L7.59 21 9 22.41l3-3 3 3L16.41 21 13 17.59v-3.3zM12 1C5.93 1 1 5.93 1 12h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z");
      add_location(path, file152, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot152.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment152(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot152] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment152.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance152($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsInputAntenna", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsInputAntenna = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance152, create_fragment152, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsInputAntenna",
      options,
      id: create_fragment152.name
    });
  }
};
var MdSettingsInputAntenna_default = MdSettingsInputAntenna;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputComponent.svelte
var file153 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputComponent.svelte";
function create_default_slot153(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z");
      add_location(path, file153, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot153.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment153(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot153] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment153.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance153($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsInputComponent", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsInputComponent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance153, create_fragment153, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsInputComponent",
      options,
      id: create_fragment153.name
    });
  }
};
var MdSettingsInputComponent_default = MdSettingsInputComponent;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputComposite.svelte
var file154 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputComposite.svelte";
function create_default_slot154(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z");
      add_location(path, file154, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot154.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment154(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot154] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment154.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance154($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsInputComposite", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsInputComposite = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance154, create_fragment154, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsInputComposite",
      options,
      id: create_fragment154.name
    });
  }
};
var MdSettingsInputComposite_default = MdSettingsInputComposite;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputHdmi.svelte
var file155 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputHdmi.svelte";
function create_default_slot155(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 7V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v3H5v6l3 6v3h8v-3l3-6V7h-1zM8 4h8v3h-2V5h-1v2h-2V5h-1v2H8V4z");
      add_location(path, file155, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot155.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment155(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot155] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment155.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance155($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsInputHdmi", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsInputHdmi = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance155, create_fragment155, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsInputHdmi",
      options,
      id: create_fragment155.name
    });
  }
};
var MdSettingsInputHdmi_default = MdSettingsInputHdmi;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputSvideo.svelte
var file156 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsInputSvideo.svelte";
function create_default_slot156(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 11.5c0-.83-.67-1.5-1.5-1.5S5 10.67 5 11.5 5.67 13 6.5 13 8 12.33 8 11.5zm7-5c0-.83-.67-1.5-1.5-1.5h-3C9.67 5 9 5.67 9 6.5S9.67 8 10.5 8h3c.83 0 1.5-.67 1.5-1.5zM8.5 15c-.83 0-1.5.67-1.5 1.5S7.67 18 8.5 18s1.5-.67 1.5-1.5S9.33 15 8.5 15zM12 1C5.93 1 1 5.93 1 12s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm0 20c-4.96 0-9-4.04-9-9s4.04-9 9-9 9 4.04 9 9-4.04 9-9 9zm5.5-11c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-2 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
      add_location(path, file156, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot156.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment156(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot156] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment156.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance156($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsInputSvideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsInputSvideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance156, create_fragment156, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsInputSvideo",
      options,
      id: create_fragment156.name
    });
  }
};
var MdSettingsInputSvideo_default = MdSettingsInputSvideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsOverscan.svelte
var file157 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsOverscan.svelte";
function create_default_slot157(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.01 5.5L10 8h4l-1.99-2.5zM18 10v4l2.5-1.99L18 10zM6 10l-2.5 2.01L6 14v-4zm8 6h-4l2.01 2.5L14 16zm7-13H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z");
      add_location(path, file157, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot157.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment157(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot157] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment157.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance157($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsOverscan", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsOverscan = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance157, create_fragment157, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsOverscan",
      options,
      id: create_fragment157.name
    });
  }
};
var MdSettingsOverscan_default = MdSettingsOverscan;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsPhone.svelte
var file158 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsPhone.svelte";
function create_default_slot158(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 9h-2v2h2V9zm4 0h-2v2h2V9zm3 6.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 9v2h2V9h-2z");
      add_location(path, file158, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot158.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment158(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot158] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment158.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance158($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsPhone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsPhone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance158, create_fragment158, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsPhone",
      options,
      id: create_fragment158.name
    });
  }
};
var MdSettingsPhone_default = MdSettingsPhone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsPower.svelte
var file159 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsPower.svelte";
function create_default_slot159(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm2-22h-2v10h2V2zm3.56 2.44l-1.45 1.45C16.84 6.94 18 8.83 18 11c0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.17 1.16-4.06 2.88-5.12L7.44 4.44C5.36 5.88 4 8.28 4 11c0 4.42 3.58 8 8 8s8-3.58 8-8c0-2.72-1.36-5.12-3.44-6.56zM15 24h2v-2h-2v2z");
      add_location(path, file159, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot159.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment159(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot159] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment159.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance159($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsPower", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsPower = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance159, create_fragment159, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsPower",
      options,
      id: create_fragment159.name
    });
  }
};
var MdSettingsPower_default = MdSettingsPower;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsRemote.svelte
var file160 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsRemote.svelte";
function create_default_slot160(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 9H9c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V10c0-.55-.45-1-1-1zm-3 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM7.05 6.05l1.41 1.41C9.37 6.56 10.62 6 12 6s2.63.56 3.54 1.46l1.41-1.41C15.68 4.78 13.93 4 12 4s-3.68.78-4.95 2.05zM12 0C8.96 0 6.21 1.23 4.22 3.22l1.41 1.41C7.26 3.01 9.51 2 12 2s4.74 1.01 6.36 2.64l1.41-1.41C17.79 1.23 15.04 0 12 0z");
      add_location(path, file160, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot160.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment160(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot160] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment160.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance160($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsRemote", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsRemote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance160, create_fragment160, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsRemote",
      options,
      id: create_fragment160.name
    });
  }
};
var MdSettingsRemote_default = MdSettingsRemote;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsVoice.svelte
var file161 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsVoice.svelte";
function create_default_slot161(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 24h2v-2H7v2zm5-11c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v6c0 1.66 1.34 3 3 3zm-1 11h2v-2h-2v2zm4 0h2v-2h-2v2zm4-14h-1.7c0 3-2.54 5.1-5.3 5.1S6.7 13 6.7 10H5c0 3.41 2.72 6.23 6 6.72V20h2v-3.28c3.28-.49 6-3.31 6-6.72z");
      add_location(path, file161, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot161.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment161(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot161] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment161.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance161($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsVoice", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsVoice = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance161, create_fragment161, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsVoice",
      options,
      id: create_fragment161.name
    });
  }
};
var MdSettingsVoice_default = MdSettingsVoice;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShop.svelte
var file162 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShop.svelte";
function create_default_slot162(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6h-6zm-6-2h4v2h-4V4zM9 18V9l7.5 4L9 18z");
      add_location(path, file162, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot162.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment162(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot162] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment162.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance162($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance162, create_fragment162, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShop",
      options,
      id: create_fragment162.name
    });
  }
};
var MdShop_default = MdShop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShopTwo.svelte
var file163 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShopTwo.svelte";
function create_default_slot163(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9H1v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2H3V9zm15-4V3c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H5v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2V5h-5zm-6-2h4v2h-4V3zm0 12V8l5.5 3-5.5 4z");
      add_location(path, file163, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot163.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment163(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot163] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment163.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance163($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShopTwo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShopTwo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance163, create_fragment163, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShopTwo",
      options,
      id: create_fragment163.name
    });
  }
};
var MdShopTwo_default = MdShopTwo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShoppingBasket.svelte
var file164 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShoppingBasket.svelte";
function create_default_slot164(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file164, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot164.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment164(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot164] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment164.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance164($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShoppingBasket", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShoppingBasket = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance164, create_fragment164, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShoppingBasket",
      options,
      id: create_fragment164.name
    });
  }
};
var MdShoppingBasket_default = MdShoppingBasket;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShoppingCart.svelte
var file165 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShoppingCart.svelte";
function create_default_slot165(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file165, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot165.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment165(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot165] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment165.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance165($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShoppingCart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShoppingCart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance165, create_fragment165, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShoppingCart",
      options,
      id: create_fragment165.name
    });
  }
};
var MdShoppingCart_default = MdShoppingCart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerNotes.svelte
var file166 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerNotes.svelte";
function create_default_slot166(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 14H6v-2h2v2zm0-3H6V9h2v2zm0-3H6V6h2v2zm7 6h-5v-2h5v2zm3-3h-8V9h8v2zm0-3h-8V6h8v2z");
      add_location(path, file166, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot166.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment166(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot166] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment166.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance166($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpeakerNotes", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpeakerNotes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance166, create_fragment166, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpeakerNotes",
      options,
      id: create_fragment166.name
    });
  }
};
var MdSpeakerNotes_default = MdSpeakerNotes;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerNotesOff.svelte
var file167 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerNotesOff.svelte";
function create_default_slot167(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.54 11l-.54-.54L7.54 8 6 6.46 2.38 2.84 1.27 1.73 0 3l2.01 2.01L2 22l4-4h9l5.73 5.73L22 22.46 17.54 18l-7-7zM8 14H6v-2h2v2zm-2-3V9l2 2H6zm14-9H4.08L10 7.92V6h8v2h-7.92l1 1H18v2h-4.92l6.99 6.99C21.14 17.95 22 17.08 22 16V4c0-1.1-.9-2-2-2z");
      add_location(path, file167, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot167.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment167(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot167] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment167.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance167($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpeakerNotesOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpeakerNotesOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance167, create_fragment167, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpeakerNotesOff",
      options,
      id: create_fragment167.name
    });
  }
};
var MdSpeakerNotesOff_default = MdSpeakerNotesOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpellcheck.svelte
var file168 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpellcheck.svelte";
function create_default_slot168(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59l-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z");
      add_location(path, file168, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot168.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment168(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot168] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment168.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance168($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpellcheck", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpellcheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance168, create_fragment168, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpellcheck",
      options,
      id: create_fragment168.name
    });
  }
};
var MdSpellcheck_default = MdSpellcheck;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStars.svelte
var file169 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStars.svelte";
function create_default_slot169(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm4.24 16L12 15.45 7.77 18l1.12-4.81-3.73-3.23 4.92-.42L12 5l1.92 4.53 4.92.42-3.73 3.23L16.23 18z");
      add_location(path, file169, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot169.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment169(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot169] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment169.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance169($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStars", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStars = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance169, create_fragment169, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStars",
      options,
      id: create_fragment169.name
    });
  }
};
var MdStars_default = MdStars;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStore.svelte
var file170 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStore.svelte";
function create_default_slot170(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z");
      add_location(path, file170, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot170.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment170(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot170] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment170.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance170($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance170, create_fragment170, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStore",
      options,
      id: create_fragment170.name
    });
  }
};
var MdStore_default = MdStore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubject.svelte
var file171 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubject.svelte";
function create_default_slot171(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z");
      add_location(path, file171, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot171.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment171(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot171] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment171.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance171($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSubject", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSubject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance171, create_fragment171, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSubject",
      options,
      id: create_fragment171.name
    });
  }
};
var MdSubject_default = MdSubject;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSupervisorAccount.svelte
var file172 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSupervisorAccount.svelte";
function create_default_slot172(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.5 12c1.38 0 2.49-1.12 2.49-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 2.99-1.34 2.99-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z");
      add_location(path, file172, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot172.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment172(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot172] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment172.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance172($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSupervisorAccount", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSupervisorAccount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance172, create_fragment172, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSupervisorAccount",
      options,
      id: create_fragment172.name
    });
  }
};
var MdSupervisorAccount_default = MdSupervisorAccount;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapHoriz.svelte
var file173 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapHoriz.svelte";
function create_default_slot173(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z");
      add_location(path, file173, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot173.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment173(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot173] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment173.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance173($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSwapHoriz", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSwapHoriz = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance173, create_fragment173, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSwapHoriz",
      options,
      id: create_fragment173.name
    });
  }
};
var MdSwapHoriz_default = MdSwapHoriz;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapVert.svelte
var file174 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapVert.svelte";
function create_default_slot174(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z");
      add_location(path, file174, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot174.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment174(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot174] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment174.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance174($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSwapVert", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSwapVert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance174, create_fragment174, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSwapVert",
      options,
      id: create_fragment174.name
    });
  }
};
var MdSwapVert_default = MdSwapVert;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapVerticalCircle.svelte
var file175 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapVerticalCircle.svelte";
function create_default_slot175(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.5 9L10 5.5 13.5 9H11v4H9V9H6.5zm11 6L14 18.5 10.5 15H13v-4h2v4h2.5z");
      add_location(path, file175, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot175.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment175(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot175] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment175.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance175($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSwapVerticalCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSwapVerticalCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance175, create_fragment175, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSwapVerticalCircle",
      options,
      id: create_fragment175.name
    });
  }
};
var MdSwapVerticalCircle_default = MdSwapVerticalCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSystemUpdateAlt.svelte
var file176 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSystemUpdateAlt.svelte";
function create_default_slot176(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 16.5l4-4h-3v-9h-2v9H8l4 4zm9-13h-6v1.99h6v14.03H3V5.49h6V3.5H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z");
      add_location(path, file176, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot176.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment176(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot176] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment176.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance176($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSystemUpdateAlt", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSystemUpdateAlt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance176, create_fragment176, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSystemUpdateAlt",
      options,
      id: create_fragment176.name
    });
  }
};
var MdSystemUpdateAlt_default = MdSystemUpdateAlt;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTab.svelte
var file177 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTab.svelte";
function create_default_slot177(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h10v4h8v10z");
      add_location(path, file177, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot177.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment177(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot177] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment177.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance177($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTab", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance177, create_fragment177, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTab",
      options,
      id: create_fragment177.name
    });
  }
};
var MdTab_default = MdTab;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTabUnselected.svelte
var file178 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTabUnselected.svelte";
function create_default_slot178(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 9h2V7H1v2zm0 4h2v-2H1v2zm0-8h2V3c-1.1 0-2 .9-2 2zm8 16h2v-2H9v2zm-8-4h2v-2H1v2zm2 4v-2H1c0 1.1.9 2 2 2zM21 3h-8v6h10V5c0-1.1-.9-2-2-2zm0 14h2v-2h-2v2zM9 5h2V3H9v2zM5 21h2v-2H5v2zM5 5h2V3H5v2zm16 16c1.1 0 2-.9 2-2h-2v2zm0-8h2v-2h-2v2zm-8 8h2v-2h-2v2zm4 0h2v-2h-2v2z");
      add_location(path, file178, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot178.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment178(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot178] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment178.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance178($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTabUnselected", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTabUnselected = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance178, create_fragment178, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTabUnselected",
      options,
      id: create_fragment178.name
    });
  }
};
var MdTabUnselected_default = MdTabUnselected;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTheaters.svelte
var file179 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTheaters.svelte";
function create_default_slot179(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z");
      add_location(path, file179, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot179.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment179(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot179] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment179.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance179($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTheaters", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTheaters = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance179, create_fragment179, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTheaters",
      options,
      id: create_fragment179.name
    });
  }
};
var MdTheaters_default = MdTheaters;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdThumbDown.svelte
var file180 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdThumbDown.svelte";
function create_default_slot180(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z");
      add_location(path, file180, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot180.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment180(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot180] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment180.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance180($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdThumbDown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdThumbDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance180, create_fragment180, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdThumbDown",
      options,
      id: create_fragment180.name
    });
  }
};
var MdThumbDown_default = MdThumbDown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdThumbUp.svelte
var file181 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdThumbUp.svelte";
function create_default_slot181(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z");
      add_location(path, file181, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot181.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment181(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot181] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment181.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance181($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdThumbUp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdThumbUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance181, create_fragment181, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdThumbUp",
      options,
      id: create_fragment181.name
    });
  }
};
var MdThumbUp_default = MdThumbUp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdThumbsUpDown.svelte
var file182 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdThumbsUpDown.svelte";
function create_default_slot182(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 6c0-.55-.45-1-1-1H5.82l.66-3.18.02-.23c0-.31-.13-.59-.33-.8L5.38 0 .44 4.94C.17 5.21 0 5.59 0 6v6.5c0 .83.67 1.5 1.5 1.5h6.75c.62 0 1.15-.38 1.38-.91l2.26-5.29c.07-.17.11-.36.11-.55V6zm10.5 4h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55V18c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5z");
      add_location(path, file182, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot182.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment182(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot182] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment182.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance182($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdThumbsUpDown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdThumbsUpDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance182, create_fragment182, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdThumbsUpDown",
      options,
      id: create_fragment182.name
    });
  }
};
var MdThumbsUpDown_default = MdThumbsUpDown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimeline.svelte
var file183 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimeline.svelte";
function create_default_slot183(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 8c0 1.1-.9 2-2 2-.18 0-.35-.02-.51-.07l-3.56 3.55c.05.16.07.34.07.52 0 1.1-.9 2-2 2s-2-.9-2-2c0-.18.02-.36.07-.52l-2.55-2.55c-.16.05-.34.07-.52.07s-.36-.02-.52-.07l-4.55 4.56c.05.16.07.33.07.51 0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2c.18 0 .35.02.51.07l4.56-4.55C8.02 9.36 8 9.18 8 9c0-1.1.9-2 2-2s2 .9 2 2c0 .18-.02.36-.07.52l2.55 2.55c.16-.05.34-.07.52-.07s.36.02.52.07l3.55-3.56C19.02 8.35 19 8.18 19 8c0-1.1.9-2 2-2s2 .9 2 2z");
      add_location(path, file183, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot183.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment183(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot183] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment183.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance183($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimeline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimeline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance183, create_fragment183, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimeline",
      options,
      id: create_fragment183.name
    });
  }
};
var MdTimeline_default = MdTimeline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToc.svelte
var file184 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToc.svelte";
function create_default_slot184(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z");
      add_location(path, file184, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot184.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment184(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot184] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment184.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance184($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdToc", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdToc = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance184, create_fragment184, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdToc",
      options,
      id: create_fragment184.name
    });
  }
};
var MdToc_default = MdToc;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToday.svelte
var file185 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToday.svelte";
function create_default_slot185(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z");
      add_location(path, file185, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot185.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment185(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot185] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment185.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance185($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdToday", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdToday = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance185, create_fragment185, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdToday",
      options,
      id: create_fragment185.name
    });
  }
};
var MdToday_default = MdToday;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToll.svelte
var file186 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToll.svelte";
function create_default_slot186(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zM3 12c0-2.61 1.67-4.83 4-5.65V4.26C3.55 5.15 1 8.27 1 12s2.55 6.85 6 7.74v-2.09c-2.33-.82-4-3.04-4-5.65z");
      add_location(path, file186, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot186.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment186(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot186] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment186.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance186($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdToll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdToll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance186, create_fragment186, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdToll",
      options,
      id: create_fragment186.name
    });
  }
};
var MdToll_default = MdToll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTouchApp.svelte
var file187 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTouchApp.svelte";
function create_default_slot187(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z");
      add_location(path, file187, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot187.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment187(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot187] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment187.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance187($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTouchApp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTouchApp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance187, create_fragment187, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTouchApp",
      options,
      id: create_fragment187.name
    });
  }
};
var MdTouchApp_default = MdTouchApp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrackChanges.svelte
var file188 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrackChanges.svelte";
function create_default_slot188(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.07 4.93l-1.41 1.41C19.1 7.79 20 9.79 20 12c0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02C8.16 6.57 6 9.03 6 12c0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41C15.55 9.9 16 10.9 16 12c0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V2h-1C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07z");
      add_location(path, file188, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot188.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment188(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot188] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment188.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance188($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTrackChanges", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTrackChanges = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance188, create_fragment188, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTrackChanges",
      options,
      id: create_fragment188.name
    });
  }
};
var MdTrackChanges_default = MdTrackChanges;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTranslate.svelte
var file189 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTranslate.svelte";
function create_default_slot189(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z");
      add_location(path, file189, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot189.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment189(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot189] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment189.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance189($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTranslate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTranslate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance189, create_fragment189, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTranslate",
      options,
      id: create_fragment189.name
    });
  }
};
var MdTranslate_default = MdTranslate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrendingDown.svelte
var file190 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrendingDown.svelte";
function create_default_slot190(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 18l2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z");
      add_location(path, file190, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot190.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment190(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot190] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment190.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance190($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTrendingDown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTrendingDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance190, create_fragment190, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTrendingDown",
      options,
      id: create_fragment190.name
    });
  }
};
var MdTrendingDown_default = MdTrendingDown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrendingFlat.svelte
var file191 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrendingFlat.svelte";
function create_default_slot191(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 12l-4-4v3H3v2h15v3z");
      add_location(path, file191, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot191.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment191(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot191] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment191.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance191($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTrendingFlat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTrendingFlat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance191, create_fragment191, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTrendingFlat",
      options,
      id: create_fragment191.name
    });
  }
};
var MdTrendingFlat_default = MdTrendingFlat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrendingUp.svelte
var file192 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrendingUp.svelte";
function create_default_slot192(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z");
      add_location(path, file192, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot192.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment192(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot192] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment192.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance192($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTrendingUp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTrendingUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance192, create_fragment192, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTrendingUp",
      options,
      id: create_fragment192.name
    });
  }
};
var MdTrendingUp_default = MdTrendingUp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTurnedIn.svelte
var file193 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTurnedIn.svelte";
function create_default_slot193(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z");
      add_location(path, file193, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot193.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment193(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot193] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment193.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance193($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTurnedIn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTurnedIn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance193, create_fragment193, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTurnedIn",
      options,
      id: create_fragment193.name
    });
  }
};
var MdTurnedIn_default = MdTurnedIn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTurnedInNot.svelte
var file194 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTurnedInNot.svelte";
function create_default_slot194(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z");
      add_location(path, file194, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot194.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment194(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot194] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment194.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance194($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTurnedInNot", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTurnedInNot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance194, create_fragment194, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTurnedInNot",
      options,
      id: create_fragment194.name
    });
  }
};
var MdTurnedInNot_default = MdTurnedInNot;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUpdate.svelte
var file195 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUpdate.svelte";
function create_default_slot195(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79 2.73 2.71 7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58 3.51-3.47 9.14-3.47 12.65 0L21 3v7.12zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8h1.5z");
      add_location(path, file195, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot195.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment195(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot195] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment195.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance195($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdUpdate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdUpdate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance195, create_fragment195, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdUpdate",
      options,
      id: create_fragment195.name
    });
  }
};
var MdUpdate_default = MdUpdate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerifiedUser.svelte
var file196 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerifiedUser.svelte";
function create_default_slot196(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z");
      add_location(path, file196, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot196.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment196(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot196] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment196.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance196($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVerifiedUser", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVerifiedUser = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance196, create_fragment196, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVerifiedUser",
      options,
      id: create_fragment196.name
    });
  }
};
var MdVerifiedUser_default = MdVerifiedUser;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewAgenda.svelte
var file197 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewAgenda.svelte";
function create_default_slot197(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 13H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm0-10H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z");
      add_location(path, file197, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot197.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment197(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot197] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment197.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance197($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewAgenda", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewAgenda = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance197, create_fragment197, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewAgenda",
      options,
      id: create_fragment197.name
    });
  }
};
var MdViewAgenda_default = MdViewAgenda;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewArray.svelte
var file198 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewArray.svelte";
function create_default_slot198(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 18h3V5H4v13zM18 5v13h3V5h-3zM8 18h9V5H8v13z");
      add_location(path, file198, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot198.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment198(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot198] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment198.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance198($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewArray", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewArray = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance198, create_fragment198, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewArray",
      options,
      id: create_fragment198.name
    });
  }
};
var MdViewArray_default = MdViewArray;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewCarousel.svelte
var file199 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewCarousel.svelte";
function create_default_slot199(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 19h10V4H7v15zm-5-2h4V6H2v11zM18 6v11h4V6h-4z");
      add_location(path, file199, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot199.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment199(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot199] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment199.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance199($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewCarousel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewCarousel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance199, create_fragment199, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewCarousel",
      options,
      id: create_fragment199.name
    });
  }
};
var MdViewCarousel_default = MdViewCarousel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewColumn.svelte
var file200 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewColumn.svelte";
function create_default_slot200(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 18h5V5h-5v13zm-6 0h5V5H4v13zM16 5v13h5V5h-5z");
      add_location(path, file200, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot200.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment200(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot200] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment200.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance200($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewColumn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewColumn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance200, create_fragment200, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewColumn",
      options,
      id: create_fragment200.name
    });
  }
};
var MdViewColumn_default = MdViewColumn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewDay.svelte
var file201 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewDay.svelte";
function create_default_slot201(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 21h19v-3H2v3zM20 8H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zM2 3v3h19V3H2z");
      add_location(path, file201, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot201.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment201(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot201] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment201.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance201($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewDay", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewDay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance201, create_fragment201, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewDay",
      options,
      id: create_fragment201.name
    });
  }
};
var MdViewDay_default = MdViewDay;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewHeadline.svelte
var file202 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewHeadline.svelte";
function create_default_slot202(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z");
      add_location(path, file202, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot202.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment202(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot202] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment202.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance202($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewHeadline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewHeadline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance202, create_fragment202, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewHeadline",
      options,
      id: create_fragment202.name
    });
  }
};
var MdViewHeadline_default = MdViewHeadline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewList.svelte
var file203 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewList.svelte";
function create_default_slot203(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z");
      add_location(path, file203, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot203.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment203(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot203] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment203.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance203($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewList", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance203, create_fragment203, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewList",
      options,
      id: create_fragment203.name
    });
  }
};
var MdViewList_default = MdViewList;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewModule.svelte
var file204 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewModule.svelte";
function create_default_slot204(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z");
      add_location(path, file204, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot204.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment204(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot204] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment204.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance204($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewModule", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewModule = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance204, create_fragment204, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewModule",
      options,
      id: create_fragment204.name
    });
  }
};
var MdViewModule_default = MdViewModule;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewQuilt.svelte
var file205 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewQuilt.svelte";
function create_default_slot205(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 18h5v-6h-5v6zm-6 0h5V5H4v13zm12 0h5v-6h-5v6zM10 5v6h11V5H10z");
      add_location(path, file205, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot205.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment205(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot205] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment205.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance205($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewQuilt", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewQuilt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance205, create_fragment205, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewQuilt",
      options,
      id: create_fragment205.name
    });
  }
};
var MdViewQuilt_default = MdViewQuilt;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewStream.svelte
var file206 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewStream.svelte";
function create_default_slot206(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 18h17v-6H4v6zM4 5v6h17V5H4z");
      add_location(path, file206, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot206.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment206(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot206] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment206.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance206($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewStream", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewStream = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance206, create_fragment206, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewStream",
      options,
      id: create_fragment206.name
    });
  }
};
var MdViewStream_default = MdViewStream;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewWeek.svelte
var file207 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewWeek.svelte";
function create_default_slot207(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z");
      add_location(path, file207, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot207.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment207(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot207] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment207.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance207($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewWeek", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewWeek = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance207, create_fragment207, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewWeek",
      options,
      id: create_fragment207.name
    });
  }
};
var MdViewWeek_default = MdViewWeek;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVisibility.svelte
var file208 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVisibility.svelte";
function create_default_slot208(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
      add_location(path, file208, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot208.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment208(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot208] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment208.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance208($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVisibility", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVisibility = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance208, create_fragment208, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVisibility",
      options,
      id: create_fragment208.name
    });
  }
};
var MdVisibility_default = MdVisibility;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVisibilityOff.svelte
var file209 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVisibilityOff.svelte";
function create_default_slot209(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z");
      add_location(path, file209, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot209.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment209(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot209] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment209.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance209($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVisibilityOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVisibilityOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance209, create_fragment209, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVisibilityOff",
      options,
      id: create_fragment209.name
    });
  }
};
var MdVisibilityOff_default = MdVisibilityOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWatchLater.svelte
var file210 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWatchLater.svelte";
function create_default_slot210(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm4.2 14.2L11 13V7h1.5v5.2l4.5 2.7-.8 1.3z");
      add_location(path, file210, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot210.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment210(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot210] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment210.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance210($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWatchLater", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWatchLater = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance210, create_fragment210, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWatchLater",
      options,
      id: create_fragment210.name
    });
  }
};
var MdWatchLater_default = MdWatchLater;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWork.svelte
var file211 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWork.svelte";
function create_default_slot211(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z");
      add_location(path, file211, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot211.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment211(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot211] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment211.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance211($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWork", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWork = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance211, create_fragment211, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWork",
      options,
      id: create_fragment211.name
    });
  }
};
var MdWork_default = MdWork;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdYoutubeSearchedFor.svelte
var file212 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdYoutubeSearchedFor.svelte";
function create_default_slot212(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.01 14h-.8l-.27-.27c.98-1.14 1.57-2.61 1.57-4.23 0-3.59-2.91-6.5-6.5-6.5s-6.5 3-6.5 6.5H2l3.84 4 4.16-4H6.51C6.51 7 8.53 5 11.01 5s4.5 2.01 4.5 4.5c0 2.48-2.02 4.5-4.5 4.5-.65 0-1.26-.14-1.82-.38L7.71 15.1c.97.57 2.09.9 3.3.9 1.61 0 3.08-.59 4.22-1.57l.27.27v.79l5.01 4.99L22 19l-4.99-5z");
      add_location(path, file212, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot212.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment212(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot212] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment212.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance212($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdYoutubeSearchedFor", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdYoutubeSearchedFor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance212, create_fragment212, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdYoutubeSearchedFor",
      options,
      id: create_fragment212.name
    });
  }
};
var MdYoutubeSearchedFor_default = MdYoutubeSearchedFor;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdZoomIn.svelte
var file213 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdZoomIn.svelte";
function create_default_slot213(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm2.5-4h-2v2H9v-2H7V9h2V7h1v2h2v1z");
      add_location(path, file213, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot213.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment213(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot213] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment213.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance213($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdZoomIn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdZoomIn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance213, create_fragment213, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdZoomIn",
      options,
      id: create_fragment213.name
    });
  }
};
var MdZoomIn_default = MdZoomIn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdZoomOut.svelte
var file214 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdZoomOut.svelte";
function create_default_slot214(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z");
      add_location(path, file214, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot214.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment214(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot214] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment214.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance214($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdZoomOut", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdZoomOut = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance214, create_fragment214, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdZoomOut",
      options,
      id: create_fragment214.name
    });
  }
};
var MdZoomOut_default = MdZoomOut;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddAlert.svelte
var file215 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddAlert.svelte";
function create_default_slot215(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.01 21.01c0 1.1.89 1.99 1.99 1.99s1.99-.89 1.99-1.99h-3.98zm8.87-4.19V11c0-3.25-2.25-5.97-5.29-6.69v-.72C13.59 2.71 12.88 2 12 2s-1.59.71-1.59 1.59v.72C7.37 5.03 5.12 7.75 5.12 11v5.82L3 18.94V20h18v-1.06l-2.12-2.12zM16 13.01h-3v3h-2v-3H8V11h3V8h2v3h3v2.01z");
      add_location(path, file215, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot215.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment215(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot215] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment215.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance215($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddAlert", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddAlert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance215, create_fragment215, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddAlert",
      options,
      id: create_fragment215.name
    });
  }
};
var MdAddAlert_default = MdAddAlert;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdError.svelte
var file216 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdError.svelte";
function create_default_slot216(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z");
      add_location(path, file216, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot216.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment216(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot216] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment216.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance216($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdError", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdError = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance216, create_fragment216, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdError",
      options,
      id: create_fragment216.name
    });
  }
};
var MdError_default = MdError;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdErrorOutline.svelte
var file217 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdErrorOutline.svelte";
function create_default_slot217(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z");
      add_location(path, file217, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot217.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment217(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot217] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment217.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance217($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdErrorOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdErrorOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance217, create_fragment217, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdErrorOutline",
      options,
      id: create_fragment217.name
    });
  }
};
var MdErrorOutline_default = MdErrorOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWarning.svelte
var file218 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWarning.svelte";
function create_default_slot218(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z");
      add_location(path, file218, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot218.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment218(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot218] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment218.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance218($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWarning", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWarning = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance218, create_fragment218, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWarning",
      options,
      id: create_fragment218.name
    });
  }
};
var MdWarning_default = MdWarning;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddToQueue.svelte
var file219 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddToQueue.svelte";
function create_default_slot219(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12zm-5-7v2h-3v3h-2v-3H8v-2h3V7h2v3h3z");
      add_location(path, file219, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot219.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment219(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot219] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment219.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance219($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddToQueue", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddToQueue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance219, create_fragment219, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddToQueue",
      options,
      id: create_fragment219.name
    });
  }
};
var MdAddToQueue_default = MdAddToQueue;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirplay.svelte
var file220 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirplay.svelte";
function create_default_slot220(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 22h12l-6-6zM21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4v-2H3V5h18v12h-4v2h4c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
      add_location(path, file220, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot220.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment220(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot220] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment220.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance220($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirplay", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirplay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance220, create_fragment220, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirplay",
      options,
      id: create_fragment220.name
    });
  }
};
var MdAirplay_default = MdAirplay;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlbum.svelte
var file221 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAlbum.svelte";
function create_default_slot221(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-5.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z");
      add_location(path, file221, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot221.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment221(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot221] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment221.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance221($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAlbum", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAlbum = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance221, create_fragment221, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAlbum",
      options,
      id: create_fragment221.name
    });
  }
};
var MdAlbum_default = MdAlbum;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArtTrack.svelte
var file222 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArtTrack.svelte";
function create_default_slot222(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 13h-8v-2h8v2zm0-6h-8v2h8V7zm-8 10h8v-2h-8v2zm-2-8v6c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V9c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2zm-1.5 6l-2.25-3-1.75 2.26-1.25-1.51L3.5 15h7z");
      add_location(path, file222, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot222.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment222(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot222] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment222.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance222($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArtTrack", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArtTrack = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance222, create_fragment222, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArtTrack",
      options,
      id: create_fragment222.name
    });
  }
};
var MdArtTrack_default = MdArtTrack;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAvTimer.svelte
var file223 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAvTimer.svelte";
function create_default_slot223(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 17c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1zm0-14v4h2V5.08c3.39.49 6 3.39 6 6.92 0 3.87-3.13 7-7 7s-7-3.13-7-7c0-1.68.59-3.22 1.58-4.42L12 13l1.41-1.41-6.8-6.8v.02C4.42 6.45 3 9.05 3 12c0 4.97 4.02 9 9 9 4.97 0 9-4.03 9-9s-4.03-9-9-9h-1zm7 9c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zM6 12c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1z");
      add_location(path, file223, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot223.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment223(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot223] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment223.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance223($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAvTimer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAvTimer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance223, create_fragment223, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAvTimer",
      options,
      id: create_fragment223.name
    });
  }
};
var MdAvTimer_default = MdAvTimer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrandingWatermark.svelte
var file224 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrandingWatermark.svelte";
function create_default_slot224(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16h-9v-6h9v6z");
      add_location(path, file224, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot224.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment224(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot224] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment224.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance224($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrandingWatermark", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrandingWatermark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance224, create_fragment224, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrandingWatermark",
      options,
      id: create_fragment224.name
    });
  }
};
var MdBrandingWatermark_default = MdBrandingWatermark;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallToAction.svelte
var file225 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallToAction.svelte";
function create_default_slot225(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3v-3h18v3z");
      add_location(path, file225, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot225.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment225(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot225] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment225.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance225($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallToAction", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallToAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance225, create_fragment225, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallToAction",
      options,
      id: create_fragment225.name
    });
  }
};
var MdCallToAction_default = MdCallToAction;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClosedCaption.svelte
var file226 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClosedCaption.svelte";
function create_default_slot226(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 7H9.5v-.5h-2v3h2V13H11v1c0 .55-.45 1-1 1H7c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1zm7 0h-1.5v-.5h-2v3h2V13H18v1c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1z");
      add_location(path, file226, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot226.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment226(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot226] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment226.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance226($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdClosedCaption", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdClosedCaption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance226, create_fragment226, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdClosedCaption",
      options,
      id: create_fragment226.name
    });
  }
};
var MdClosedCaption_default = MdClosedCaption;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEqualizer.svelte
var file227 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEqualizer.svelte";
function create_default_slot227(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z");
      add_location(path, file227, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot227.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment227(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot227] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment227.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance227($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEqualizer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEqualizer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance227, create_fragment227, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEqualizer",
      options,
      id: create_fragment227.name
    });
  }
};
var MdEqualizer_default = MdEqualizer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExplicit.svelte
var file228 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExplicit.svelte";
function create_default_slot228(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h4v2h-4v2h4v2H9V7h6v2z");
      add_location(path, file228, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot228.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment228(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot228] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment228.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance228($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExplicit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExplicit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance228, create_fragment228, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExplicit",
      options,
      id: create_fragment228.name
    });
  }
};
var MdExplicit_default = MdExplicit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFastForward.svelte
var file229 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFastForward.svelte";
function create_default_slot229(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z");
      add_location(path, file229, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot229.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment229(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot229] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment229.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance229($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFastForward", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFastForward = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance229, create_fragment229, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFastForward",
      options,
      id: create_fragment229.name
    });
  }
};
var MdFastForward_default = MdFastForward;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFastRewind.svelte
var file230 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFastRewind.svelte";
function create_default_slot230(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z");
      add_location(path, file230, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot230.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment230(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot230] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment230.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance230($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFastRewind", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFastRewind = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance230, create_fragment230, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFastRewind",
      options,
      id: create_fragment230.name
    });
  }
};
var MdFastRewind_default = MdFastRewind;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFeaturedPlayList.svelte
var file231 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFeaturedPlayList.svelte";
function create_default_slot231(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 8H3V9h9v2zm0-4H3V5h9v2z");
      add_location(path, file231, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot231.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment231(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot231] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment231.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance231($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFeaturedPlayList", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFeaturedPlayList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance231, create_fragment231, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFeaturedPlayList",
      options,
      id: create_fragment231.name
    });
  }
};
var MdFeaturedPlayList_default = MdFeaturedPlayList;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFeaturedVideo.svelte
var file232 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFeaturedVideo.svelte";
function create_default_slot232(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 9H3V5h9v7z");
      add_location(path, file232, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot232.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment232(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot232] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment232.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance232($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFeaturedVideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFeaturedVideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance232, create_fragment232, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFeaturedVideo",
      options,
      id: create_fragment232.name
    });
  }
};
var MdFeaturedVideo_default = MdFeaturedVideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberDvr.svelte
var file233 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberDvr.svelte";
function create_default_slot233(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.5 10.5h2v1h-2zm-13 0h2v3h-2zM21 3H3c-1.11 0-2 .89-2 2v14c0 1.1.89 2 2 2h18c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zM8 13.5c0 .85-.65 1.5-1.5 1.5H3V9h3.5c.85 0 1.5.65 1.5 1.5v3zm4.62 1.5h-1.5L9.37 9h1.5l1 3.43 1-3.43h1.5l-1.75 6zM21 11.5c0 .6-.4 1.15-.9 1.4L21 15h-1.5l-.85-2H17.5v2H16V9h3.5c.85 0 1.5.65 1.5 1.5v1z");
      add_location(path, file233, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot233.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment233(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot233] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment233.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance233($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFiberDvr", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFiberDvr = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance233, create_fragment233, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFiberDvr",
      options,
      id: create_fragment233.name
    });
  }
};
var MdFiberDvr_default = MdFiberDvr;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberManualRecord.svelte
var file234 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberManualRecord.svelte";
function create_default_slot234(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "undefined");
      add_location(path, file234, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot234.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment234(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot234] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment234.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance234($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFiberManualRecord", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFiberManualRecord = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance234, create_fragment234, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFiberManualRecord",
      options,
      id: create_fragment234.name
    });
  }
};
var MdFiberManualRecord_default = MdFiberManualRecord;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberNew.svelte
var file235 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberNew.svelte";
function create_default_slot235(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zM8.5 15H7.3l-2.55-3.5V15H3.5V9h1.25l2.5 3.5V9H8.5v6zm5-4.74H11v1.12h2.5v1.26H11v1.11h2.5V15h-4V9h4v1.26zm7 3.74c0 .55-.45 1-1 1h-4c-.55 0-1-.45-1-1V9h1.25v4.51h1.13V9.99h1.25v3.51h1.12V9h1.25v5z");
      add_location(path, file235, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot235.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment235(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot235] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment235.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance235($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFiberNew", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFiberNew = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance235, create_fragment235, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFiberNew",
      options,
      id: create_fragment235.name
    });
  }
};
var MdFiberNew_default = MdFiberNew;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberPin.svelte
var file236 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberPin.svelte";
function create_default_slot236(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5.5 10.5h2v1h-2zM20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zM9 11.5c0 .85-.65 1.5-1.5 1.5h-2v2H4V9h3.5c.85 0 1.5.65 1.5 1.5v1zm3.5 3.5H11V9h1.5v6zm7.5 0h-1.2l-2.55-3.5V15H15V9h1.25l2.5 3.5V9H20v6z");
      add_location(path, file236, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot236.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment236(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot236] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment236.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance236($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFiberPin", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFiberPin = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance236, create_fragment236, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFiberPin",
      options,
      id: create_fragment236.name
    });
  }
};
var MdFiberPin_default = MdFiberPin;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberSmartRecord.svelte
var file237 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFiberSmartRecord.svelte";
function create_default_slot237(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "undefined");
      add_location(path, file237, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot237.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment237(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot237] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment237.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance237($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFiberSmartRecord", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFiberSmartRecord = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance237, create_fragment237, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFiberSmartRecord",
      options,
      id: create_fragment237.name
    });
  }
};
var MdFiberSmartRecord_default = MdFiberSmartRecord;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward10.svelte
var file238 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward10.svelte";
function create_default_slot238(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 13c0 4.4 3.6 8 8 8s8-3.6 8-8h-2c0 3.3-2.7 6-6 6s-6-2.7-6-6 2.7-6 6-6v4l5-5-5-5v4c-4.4 0-8 3.6-8 8zm6.8 3H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1.3.2.5.3.2.3.3.6.1.5.1.8v.7zm-.8-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z");
      add_location(path, file238, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot238.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment238(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot238] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment238.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance238($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdForward10", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdForward10 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance238, create_fragment238, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdForward10",
      options,
      id: create_fragment238.name
    });
  }
};
var MdForward10_default = MdForward10;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward30.svelte
var file239 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward30.svelte";
function create_default_slot239(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.6 13.5h.4c.2 0 .4-.1.5-.2s.2-.2.2-.4v-.2s-.1-.1-.1-.2-.1-.1-.2-.1h-.5s-.1.1-.2.1-.1.1-.1.2v.2h-1c0-.2 0-.3.1-.5s.2-.3.3-.4.3-.2.4-.2.4-.1.5-.1c.2 0 .4 0 .6.1s.3.1.5.2.2.2.3.4.1.3.1.5v.3s-.1.2-.1.3-.1.2-.2.2-.2.1-.3.2c.2.1.4.2.5.4s.2.4.2.6c0 .2 0 .4-.1.5s-.2.3-.3.4-.3.2-.5.2-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.4-.1-.6h.8v.2s.1.1.1.2.1.1.2.1h.5s.1-.1.2-.1.1-.1.1-.2v-.5s-.1-.1-.1-.2-.1-.1-.2-.1h-.6v-.7zm5.7.7c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1.3.2.5.3.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5zM4 13c0 4.4 3.6 8 8 8s8-3.6 8-8h-2c0 3.3-2.7 6-6 6s-6-2.7-6-6 2.7-6 6-6v4l5-5-5-5v4c-4.4 0-8 3.6-8 8z");
      add_location(path, file239, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot239.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment239(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot239] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment239.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance239($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdForward30", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdForward30 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance239, create_fragment239, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdForward30",
      options,
      id: create_fragment239.name
    });
  }
};
var MdForward30_default = MdForward30;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward5.svelte
var file240 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward5.svelte";
function create_default_slot240(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 13c0 4.4 3.6 8 8 8s8-3.6 8-8h-2c0 3.3-2.7 6-6 6s-6-2.7-6-6 2.7-6 6-6v4l5-5-5-5v4c-4.4 0-8 3.6-8 8zm6.7.9l.2-2.2h2.4v.7h-1.7l-.1.9s.1 0 .1-.1.1 0 .1-.1.1 0 .2 0h.2c.2 0 .4 0 .5.1s.3.2.4.3.2.3.3.5.1.4.1.6c0 .2 0 .4-.1.5s-.1.3-.3.5-.3.2-.5.3-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.3-.1-.5h.8c0 .2.1.3.2.4s.2.1.4.1c.1 0 .2 0 .3-.1l.2-.2s.1-.2.1-.3v-.6l-.1-.2-.2-.2s-.2-.1-.3-.1h-.2s-.1 0-.2.1-.1 0-.1.1-.1.1-.1.1h-.6z");
      add_location(path, file240, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot240.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment240(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot240] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment240.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance240($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdForward5", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdForward5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance240, create_fragment240, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdForward5",
      options,
      id: create_fragment240.name
    });
  }
};
var MdForward5_default = MdForward5;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGames.svelte
var file241 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGames.svelte";
function create_default_slot241(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 7.5V2H9v5.5l3 3 3-3zM7.5 9H2v6h5.5l3-3-3-3zM9 16.5V22h6v-5.5l-3-3-3 3zM16.5 9l-3 3 3 3H22V9h-5.5z");
      add_location(path, file241, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot241.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment241(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot241] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment241.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance241($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGames", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGames = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance241, create_fragment241, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGames",
      options,
      id: create_fragment241.name
    });
  }
};
var MdGames_default = MdGames;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHd.svelte
var file242 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHd.svelte";
function create_default_slot242(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z");
      add_location(path, file242, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot242.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment242(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot242] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment242.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance242($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance242, create_fragment242, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHd",
      options,
      id: create_fragment242.name
    });
  }
};
var MdHd_default = MdHd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHearing.svelte
var file243 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHearing.svelte";
function create_default_slot243(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 20c-.29 0-.56-.06-.76-.15-.71-.37-1.21-.88-1.71-2.38-.51-1.56-1.47-2.29-2.39-3-.79-.61-1.61-1.24-2.32-2.53C9.29 10.98 9 9.93 9 9c0-2.8 2.2-5 5-5s5 2.2 5 5h2c0-3.93-3.07-7-7-7S7 5.07 7 9c0 1.26.38 2.65 1.07 3.9.91 1.65 1.98 2.48 2.85 3.15.81.62 1.39 1.07 1.71 2.05.6 1.82 1.37 2.84 2.73 3.55.51.23 1.07.35 1.64.35 2.21 0 4-1.79 4-4h-2c0 1.1-.9 2-2 2zM7.64 2.64L6.22 1.22C4.23 3.21 3 5.96 3 9s1.23 5.79 3.22 7.78l1.41-1.41C6.01 13.74 5 11.49 5 9s1.01-4.74 2.64-6.36zM11.5 9c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5-2.5 1.12-2.5 2.5z");
      add_location(path, file243, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot243.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment243(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot243] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment243.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance243($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHearing", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHearing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance243, create_fragment243, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHearing",
      options,
      id: create_fragment243.name
    });
  }
};
var MdHearing_default = MdHearing;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHighQuality.svelte
var file244 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHighQuality.svelte";
function create_default_slot244(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 11H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm7-1c0 .55-.45 1-1 1h-.75v1.5h-1.5V15H14c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v4zm-3.5-.5h2v-3h-2v3z");
      add_location(path, file244, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot244.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment244(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot244] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment244.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance244($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHighQuality", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHighQuality = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance244, create_fragment244, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHighQuality",
      options,
      id: create_fragment244.name
    });
  }
};
var MdHighQuality_default = MdHighQuality;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLibraryAdd.svelte
var file245 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLibraryAdd.svelte";
function create_default_slot245(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z");
      add_location(path, file245, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot245.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment245(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot245] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment245.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance245($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLibraryAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLibraryAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance245, create_fragment245, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLibraryAdd",
      options,
      id: create_fragment245.name
    });
  }
};
var MdLibraryAdd_default = MdLibraryAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLibraryBooks.svelte
var file246 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLibraryBooks.svelte";
function create_default_slot246(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z");
      add_location(path, file246, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot246.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment246(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot246] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment246.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance246($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLibraryBooks", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLibraryBooks = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance246, create_fragment246, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLibraryBooks",
      options,
      id: create_fragment246.name
    });
  }
};
var MdLibraryBooks_default = MdLibraryBooks;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLibraryMusic.svelte
var file247 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLibraryMusic.svelte";
function create_default_slot247(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 5h-3v5.5c0 1.38-1.12 2.5-2.5 2.5S10 13.88 10 12.5s1.12-2.5 2.5-2.5c.57 0 1.08.19 1.5.51V5h4v2zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6z");
      add_location(path, file247, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot247.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment247(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot247] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment247.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance247($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLibraryMusic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLibraryMusic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance247, create_fragment247, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLibraryMusic",
      options,
      id: create_fragment247.name
    });
  }
};
var MdLibraryMusic_default = MdLibraryMusic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLoop.svelte
var file248 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLoop.svelte";
function create_default_slot248(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z");
      add_location(path, file248, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot248.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment248(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot248] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment248.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance248($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLoop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLoop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance248, create_fragment248, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLoop",
      options,
      id: create_fragment248.name
    });
  }
};
var MdLoop_default = MdLoop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMic.svelte
var file249 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMic.svelte";
function create_default_slot249(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z");
      add_location(path, file249, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot249.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment249(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot249] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment249.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance249($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance249, create_fragment249, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMic",
      options,
      id: create_fragment249.name
    });
  }
};
var MdMic_default = MdMic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMicNone.svelte
var file250 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMicNone.svelte";
function create_default_slot250(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1.2-9.1c0-.66.54-1.2 1.2-1.2.66 0 1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2-.66 0-1.2-.54-1.2-1.2V4.9zm6.5 6.1c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z");
      add_location(path, file250, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot250.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment250(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot250] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment250.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance250($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMicNone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMicNone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance250, create_fragment250, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMicNone",
      options,
      id: create_fragment250.name
    });
  }
};
var MdMicNone_default = MdMicNone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMicOff.svelte
var file251 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMicOff.svelte";
function create_default_slot251(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z");
      add_location(path, file251, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot251.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment251(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot251] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment251.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance251($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMicOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMicOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance251, create_fragment251, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMicOff",
      options,
      id: create_fragment251.name
    });
  }
};
var MdMicOff_default = MdMicOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMovie.svelte
var file252 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMovie.svelte";
function create_default_slot252(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z");
      add_location(path, file252, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot252.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment252(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot252] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment252.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance252($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMovie", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMovie = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance252, create_fragment252, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMovie",
      options,
      id: create_fragment252.name
    });
  }
};
var MdMovie_default = MdMovie;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMusicVideo.svelte
var file253 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMusicVideo.svelte";
function create_default_slot253(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM8 15c0-1.66 1.34-3 3-3 .35 0 .69.07 1 .18V6h5v2h-3v7.03c-.02 1.64-1.35 2.97-3 2.97-1.66 0-3-1.34-3-3z");
      add_location(path, file253, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot253.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment253(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot253] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment253.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance253($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMusicVideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMusicVideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance253, create_fragment253, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMusicVideo",
      options,
      id: create_fragment253.name
    });
  }
};
var MdMusicVideo_default = MdMusicVideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNewReleases.svelte
var file254 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNewReleases.svelte";
function create_default_slot254(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 12l-2.44-2.78.34-3.68-3.61-.82-1.89-3.18L12 3 8.6 1.54 6.71 4.72l-3.61.81.34 3.68L1 12l2.44 2.78-.34 3.69 3.61.82 1.89 3.18L12 21l3.4 1.46 1.89-3.18 3.61-.82-.34-3.68L23 12zm-10 5h-2v-2h2v2zm0-4h-2V7h2v6z");
      add_location(path, file254, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot254.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment254(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot254] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment254.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance254($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNewReleases", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNewReleases = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance254, create_fragment254, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNewReleases",
      options,
      id: create_fragment254.name
    });
  }
};
var MdNewReleases_default = MdNewReleases;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotInterested.svelte
var file255 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotInterested.svelte";
function create_default_slot255(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z");
      add_location(path, file255, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot255.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment255(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot255] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment255.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance255($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNotInterested", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNotInterested = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance255, create_fragment255, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNotInterested",
      options,
      id: create_fragment255.name
    });
  }
};
var MdNotInterested_default = MdNotInterested;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNote.svelte
var file256 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNote.svelte";
function create_default_slot256(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 10l-6-6H4c-1.1 0-2 .9-2 2v12.01c0 1.1.9 1.99 2 1.99l16-.01c1.1 0 2-.89 2-1.99v-8zm-7-4.5l5.5 5.5H15V5.5z");
      add_location(path, file256, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot256.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment256(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot256] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment256.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance256($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNote", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance256, create_fragment256, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNote",
      options,
      id: create_fragment256.name
    });
  }
};
var MdNote_default = MdNote;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPause.svelte
var file257 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPause.svelte";
function create_default_slot257(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 19h4V5H6v14zm8-14v14h4V5h-4z");
      add_location(path, file257, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot257.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment257(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot257] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment257.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance257($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPause", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPause = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance257, create_fragment257, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPause",
      options,
      id: create_fragment257.name
    });
  }
};
var MdPause_default = MdPause;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPauseCircleFilled.svelte
var file258 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPauseCircleFilled.svelte";
function create_default_slot258(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z");
      add_location(path, file258, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot258.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment258(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot258] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment258.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance258($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPauseCircleFilled", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPauseCircleFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance258, create_fragment258, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPauseCircleFilled",
      options,
      id: create_fragment258.name
    });
  }
};
var MdPauseCircleFilled_default = MdPauseCircleFilled;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPauseCircleOutline.svelte
var file259 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPauseCircleOutline.svelte";
function create_default_slot259(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 16h2V8H9v8zm3-14C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm1-4h2V8h-2v8z");
      add_location(path, file259, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot259.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment259(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot259] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment259.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance259($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPauseCircleOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPauseCircleOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance259, create_fragment259, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPauseCircleOutline",
      options,
      id: create_fragment259.name
    });
  }
};
var MdPauseCircleOutline_default = MdPauseCircleOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayArrow.svelte
var file260 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayArrow.svelte";
function create_default_slot260(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 5v14l11-7z");
      add_location(path, file260, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot260.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment260(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot260] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment260.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance260($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlayArrow", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlayArrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance260, create_fragment260, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlayArrow",
      options,
      id: create_fragment260.name
    });
  }
};
var MdPlayArrow_default = MdPlayArrow;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayCircleFilled.svelte
var file261 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayCircleFilled.svelte";
function create_default_slot261(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z");
      add_location(path, file261, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot261.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment261(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot261] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment261.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance261($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlayCircleFilled", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlayCircleFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance261, create_fragment261, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlayCircleFilled",
      options,
      id: create_fragment261.name
    });
  }
};
var MdPlayCircleFilled_default = MdPlayCircleFilled;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayCircleOutline.svelte
var file262 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlayCircleOutline.svelte";
function create_default_slot262(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file262, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot262.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment262(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot262] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment262.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance262($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlayCircleOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlayCircleOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance262, create_fragment262, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlayCircleOutline",
      options,
      id: create_fragment262.name
    });
  }
};
var MdPlayCircleOutline_default = MdPlayCircleOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlaylistAdd.svelte
var file263 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlaylistAdd.svelte";
function create_default_slot263(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 10H2v2h12v-2zm0-4H2v2h12V6zm4 8v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM2 16h8v-2H2v2z");
      add_location(path, file263, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot263.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment263(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot263] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment263.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance263($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlaylistAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlaylistAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance263, create_fragment263, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlaylistAdd",
      options,
      id: create_fragment263.name
    });
  }
};
var MdPlaylistAdd_default = MdPlaylistAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlaylistAddCheck.svelte
var file264 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlaylistAddCheck.svelte";
function create_default_slot264(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 10H2v2h12v-2zm0-4H2v2h12V6zM2 16h8v-2H2v2zm19.5-4.5L23 13l-6.99 7-4.51-4.5L13 14l3.01 3 5.49-5.5z");
      add_location(path, file264, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot264.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment264(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot264] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment264.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance264($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlaylistAddCheck", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlaylistAddCheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance264, create_fragment264, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlaylistAddCheck",
      options,
      id: create_fragment264.name
    });
  }
};
var MdPlaylistAddCheck_default = MdPlaylistAddCheck;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlaylistPlay.svelte
var file265 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlaylistPlay.svelte";
function create_default_slot265(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 9H2v2h17V9zm0-4H2v2h17V5zM2 15h13v-2H2v2zm15-2v6l5-3-5-3z");
      add_location(path, file265, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot265.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment265(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot265] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment265.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance265($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlaylistPlay", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlaylistPlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance265, create_fragment265, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlaylistPlay",
      options,
      id: create_fragment265.name
    });
  }
};
var MdPlaylistPlay_default = MdPlaylistPlay;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueue.svelte
var file266 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueue.svelte";
function create_default_slot266(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z");
      add_location(path, file266, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot266.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment266(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot266] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment266.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance266($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdQueue", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdQueue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance266, create_fragment266, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdQueue",
      options,
      id: create_fragment266.name
    });
  }
};
var MdQueue_default = MdQueue;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueueMusic.svelte
var file267 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueueMusic.svelte";
function create_default_slot267(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 6H3v2h12V6zm0 4H3v2h12v-2zM3 16h8v-2H3v2zM17 6v8.18c-.31-.11-.65-.18-1-.18-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3V8h3V6h-5z");
      add_location(path, file267, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot267.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment267(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot267] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment267.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance267($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdQueueMusic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdQueueMusic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance267, create_fragment267, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdQueueMusic",
      options,
      id: create_fragment267.name
    });
  }
};
var MdQueueMusic_default = MdQueueMusic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueuePlayNext.svelte
var file268 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdQueuePlayNext.svelte";
function create_default_slot268(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h2v-2H3V5h18v8h2V5c0-1.11-.9-2-2-2zm-8 7V7h-2v3H8v2h3v3h2v-3h3v-2h-3zm11 8l-4.5 4.5L18 21l3-3-3-3 1.5-1.5L24 18z");
      add_location(path, file268, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot268.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment268(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot268] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment268.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance268($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdQueuePlayNext", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdQueuePlayNext = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance268, create_fragment268, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdQueuePlayNext",
      options,
      id: create_fragment268.name
    });
  }
};
var MdQueuePlayNext_default = MdQueuePlayNext;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRadio.svelte
var file269 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRadio.svelte";
function create_default_slot269(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.24 6.15C2.51 6.43 2 7.17 2 8v12c0 1.1.89 2 2 2h16c1.11 0 2-.9 2-2V8c0-1.11-.89-2-2-2H8.3l8.26-3.34L15.88 1 3.24 6.15zM7 20c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm13-8h-2v-2h-2v2H4V8h16v4z");
      add_location(path, file269, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot269.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment269(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot269] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment269.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance269($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRadio", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRadio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance269, create_fragment269, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRadio",
      options,
      id: create_fragment269.name
    });
  }
};
var MdRadio_default = MdRadio;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRecentActors.svelte
var file270 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRecentActors.svelte";
function create_default_slot270(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 5v14h2V5h-2zm-4 14h2V5h-2v14zM14 5H2c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM8 7.75c1.24 0 2.25 1.01 2.25 2.25S9.24 12.25 8 12.25 5.75 11.24 5.75 10 6.76 7.75 8 7.75zM12.5 17h-9v-.75c0-1.5 3-2.25 4.5-2.25s4.5.75 4.5 2.25V17z");
      add_location(path, file270, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot270.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment270(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot270] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment270.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance270($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRecentActors", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRecentActors = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance270, create_fragment270, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRecentActors",
      options,
      id: create_fragment270.name
    });
  }
};
var MdRecentActors_default = MdRecentActors;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveFromQueue.svelte
var file271 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveFromQueue.svelte";
function create_default_slot271(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12zm-5-7v2H8v-2h8z");
      add_location(path, file271, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot271.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment271(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot271] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment271.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance271($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRemoveFromQueue", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRemoveFromQueue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance271, create_fragment271, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRemoveFromQueue",
      options,
      id: create_fragment271.name
    });
  }
};
var MdRemoveFromQueue_default = MdRemoveFromQueue;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRepeat.svelte
var file272 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRepeat.svelte";
function create_default_slot272(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z");
      add_location(path, file272, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot272.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment272(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot272] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment272.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance272($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRepeat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRepeat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance272, create_fragment272, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRepeat",
      options,
      id: create_fragment272.name
    });
  }
};
var MdRepeat_default = MdRepeat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRepeatOne.svelte
var file273 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRepeatOne.svelte";
function create_default_slot273(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v4H13z");
      add_location(path, file273, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot273.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment273(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot273] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment273.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance273($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRepeatOne", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRepeatOne = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance273, create_fragment273, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRepeatOne",
      options,
      id: create_fragment273.name
    });
  }
};
var MdRepeatOne_default = MdRepeatOne;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay10.svelte
var file274 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay10.svelte";
function create_default_slot274(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.1 11H10v-3.3L9 13v-.7l1.8-.6h.1V16zm4.3-1.8c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1c.2.1.3.2.5.3s.2.3.3.6.1.5.1.8v.7zm-.9-.8v-.5s-.1-.2-.1-.3-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z");
      add_location(path, file274, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot274.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment274(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot274] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment274.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance274($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReplay10", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReplay10 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance274, create_fragment274, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReplay10",
      options,
      id: create_fragment274.name
    });
  }
};
var MdReplay10_default = MdReplay10;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay.svelte
var file275 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay.svelte";
function create_default_slot275(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z");
      add_location(path, file275, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot275.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment275(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot275] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment275.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance275($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReplay", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReplay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance275, create_fragment275, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReplay",
      options,
      id: create_fragment275.name
    });
  }
};
var MdReplay_default = MdReplay;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay30.svelte
var file276 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay30.svelte";
function create_default_slot276(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-2.4 8.5h.4c.2 0 .4-.1.5-.2s.2-.2.2-.4v-.2s-.1-.1-.1-.2-.1-.1-.2-.1h-.5s-.1.1-.2.1-.1.1-.1.2v.2h-1c0-.2 0-.3.1-.5s.2-.3.3-.4.3-.2.4-.2.4-.1.5-.1c.2 0 .4 0 .6.1s.3.1.5.2.2.2.3.4.1.3.1.5v.3s-.1.2-.1.3-.1.2-.2.2-.2.1-.3.2c.2.1.4.2.5.4s.2.4.2.6c0 .2 0 .4-.1.5s-.2.3-.3.4-.3.2-.5.2-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.4-.1-.6h.8v.2s.1.1.1.2.1.1.2.1h.5s.1-.1.2-.1.1-.1.1-.2v-.5s-.1-.1-.1-.2-.1-.1-.2-.1h-.6v-.7zm5.7.7c0 .3 0 .6-.1.8l-.3.6s-.3.3-.5.3-.4.1-.6.1-.4 0-.6-.1-.3-.2-.5-.3-.2-.3-.3-.6-.1-.5-.1-.8v-.7c0-.3 0-.6.1-.8l.3-.6s.3-.3.5-.3.4-.1.6-.1.4 0 .6.1.3.2.5.3.2.3.3.6.1.5.1.8v.7zm-.8-.8v-.5c0-.1-.1-.2-.1-.3s-.1-.1-.2-.2-.2-.1-.3-.1-.2 0-.3.1l-.2.2s-.1.2-.1.3v2s.1.2.1.3.1.1.2.2.2.1.3.1.2 0 .3-.1l.2-.2s.1-.2.1-.3v-1.5z");
      add_location(path, file276, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot276.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment276(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot276] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment276.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance276($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReplay30", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReplay30 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance276, create_fragment276, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReplay30",
      options,
      id: create_fragment276.name
    });
  }
};
var MdReplay30_default = MdReplay30;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay5.svelte
var file277 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplay5.svelte";
function create_default_slot277(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5V1L7 6l5 5V7c3.3 0 6 2.7 6 6s-2.7 6-6 6-6-2.7-6-6H4c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8zm-1.3 8.9l.2-2.2h2.4v.7h-1.7l-.1.9s.1 0 .1-.1.1 0 .1-.1.1 0 .2 0h.2c.2 0 .4 0 .5.1s.3.2.4.3.2.3.3.5.1.4.1.6c0 .2 0 .4-.1.5s-.1.3-.3.5-.3.2-.4.3-.4.1-.6.1c-.2 0-.4 0-.5-.1s-.3-.1-.5-.2-.2-.2-.3-.4-.1-.3-.1-.5h.8c0 .2.1.3.2.4s.2.1.4.1c.1 0 .2 0 .3-.1l.2-.2s.1-.2.1-.3v-.6l-.1-.2-.2-.2s-.2-.1-.3-.1h-.2s-.1 0-.2.1-.1 0-.1.1-.1.1-.1.1h-.7z");
      add_location(path, file277, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot277.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment277(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot277] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment277.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance277($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReplay5", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReplay5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance277, create_fragment277, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReplay5",
      options,
      id: create_fragment277.name
    });
  }
};
var MdReplay5_default = MdReplay5;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShuffle.svelte
var file278 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShuffle.svelte";
function create_default_slot278(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z");
      add_location(path, file278, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot278.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment278(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot278] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment278.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance278($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShuffle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShuffle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance278, create_fragment278, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShuffle",
      options,
      id: create_fragment278.name
    });
  }
};
var MdShuffle_default = MdShuffle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSkipNext.svelte
var file279 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSkipNext.svelte";
function create_default_slot279(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z");
      add_location(path, file279, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot279.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment279(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot279] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment279.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance279($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSkipNext", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSkipNext = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance279, create_fragment279, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSkipNext",
      options,
      id: create_fragment279.name
    });
  }
};
var MdSkipNext_default = MdSkipNext;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSkipPrevious.svelte
var file280 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSkipPrevious.svelte";
function create_default_slot280(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 6h2v12H6zm3.5 6l8.5 6V6z");
      add_location(path, file280, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot280.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment280(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot280] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment280.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance280($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSkipPrevious", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSkipPrevious = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance280, create_fragment280, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSkipPrevious",
      options,
      id: create_fragment280.name
    });
  }
};
var MdSkipPrevious_default = MdSkipPrevious;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSlowMotionVideo.svelte
var file281 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSlowMotionVideo.svelte";
function create_default_slot281(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13.05 9.79L10 7.5v9l3.05-2.29L16 12zm0 0L10 7.5v9l3.05-2.29L16 12zm0 0L10 7.5v9l3.05-2.29L16 12zM11 4.07V2.05c-2.01.2-3.84 1-5.32 2.21L7.1 5.69c1.11-.86 2.44-1.44 3.9-1.62zM5.69 7.1L4.26 5.68C3.05 7.16 2.25 8.99 2.05 11h2.02c.18-1.46.76-2.79 1.62-3.9zM4.07 13H2.05c.2 2.01 1 3.84 2.21 5.32l1.43-1.43c-.86-1.1-1.44-2.43-1.62-3.89zm1.61 6.74C7.16 20.95 9 21.75 11 21.95v-2.02c-1.46-.18-2.79-.76-3.9-1.62l-1.42 1.43zM22 12c0 5.16-3.92 9.42-8.95 9.95v-2.02C16.97 19.41 20 16.05 20 12s-3.03-7.41-6.95-7.93V2.05C18.08 2.58 22 6.84 22 12z");
      add_location(path, file281, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot281.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment281(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot281] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment281.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance281($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSlowMotionVideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSlowMotionVideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance281, create_fragment281, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSlowMotionVideo",
      options,
      id: create_fragment281.name
    });
  }
};
var MdSlowMotionVideo_default = MdSlowMotionVideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSnooze.svelte
var file282 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSnooze.svelte";
function create_default_slot282(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-3-9h3.63L9 15.2V17h6v-2h-3.63L15 10.8V9H9v2z");
      add_location(path, file282, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot282.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment282(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot282] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment282.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance282($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSnooze", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSnooze = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance282, create_fragment282, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSnooze",
      options,
      id: create_fragment282.name
    });
  }
};
var MdSnooze_default = MdSnooze;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSortByAlpha.svelte
var file283 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSortByAlpha.svelte";
function create_default_slot283(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.94 4.66h-4.72l2.36-2.36zm-4.69 14.71h4.66l-2.33 2.33zM6.1 6.27L1.6 17.73h1.84l.92-2.45h5.11l.92 2.45h1.84L7.74 6.27H6.1zm-1.13 7.37l1.94-5.18 1.94 5.18H4.97zm10.76 2.5h6.12v1.59h-8.53v-1.29l5.92-8.56h-5.88v-1.6h8.3v1.26l-5.93 8.6z");
      add_location(path, file283, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot283.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment283(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot283] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment283.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance283($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSortByAlpha", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSortByAlpha = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance283, create_fragment283, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSortByAlpha",
      options,
      id: create_fragment283.name
    });
  }
};
var MdSortByAlpha_default = MdSortByAlpha;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStop.svelte
var file284 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStop.svelte";
function create_default_slot284(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 6h12v12H6z");
      add_location(path, file284, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot284.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment284(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot284] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment284.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance284($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance284, create_fragment284, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStop",
      options,
      id: create_fragment284.name
    });
  }
};
var MdStop_default = MdStop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubscriptions.svelte
var file285 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubscriptions.svelte";
function create_default_slot285(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 8H4V6h16v2zm-2-6H6v2h12V2zm4 10v8c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2v-8c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2zm-6 4l-6-3.27v6.53L16 16z");
      add_location(path, file285, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot285.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment285(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot285] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment285.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance285($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSubscriptions", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSubscriptions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance285, create_fragment285, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSubscriptions",
      options,
      id: create_fragment285.name
    });
  }
};
var MdSubscriptions_default = MdSubscriptions;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubtitles.svelte
var file286 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubtitles.svelte";
function create_default_slot286(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM4 12h4v2H4v-2zm10 6H4v-2h10v2zm6 0h-4v-2h4v2zm0-4H10v-2h10v2z");
      add_location(path, file286, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot286.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment286(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot286] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment286.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance286($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSubtitles", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSubtitles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance286, create_fragment286, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSubtitles",
      options,
      id: create_fragment286.name
    });
  }
};
var MdSubtitles_default = MdSubtitles;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSurroundSound.svelte
var file287 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSurroundSound.svelte";
function create_default_slot287(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7.76 16.24l-1.41 1.41C4.78 16.1 4 14.05 4 12c0-2.05.78-4.1 2.34-5.66l1.41 1.41C6.59 8.93 6 10.46 6 12s.59 3.07 1.76 4.24zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm5.66 1.66l-1.41-1.41C17.41 15.07 18 13.54 18 12s-.59-3.07-1.76-4.24l1.41-1.41C19.22 7.9 20 9.95 20 12c0 2.05-.78 4.1-2.34 5.66zM12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file287, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot287.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment287(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot287] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment287.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance287($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSurroundSound", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSurroundSound = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance287, create_fragment287, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSurroundSound",
      options,
      id: create_fragment287.name
    });
  }
};
var MdSurroundSound_default = MdSurroundSound;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideoCall.svelte
var file288 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideoCall.svelte";
function create_default_slot288(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4zM14 13h-3v3H9v-3H6v-2h3V8h2v3h3v2z");
      add_location(path, file288, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot288.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment288(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot288] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment288.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance288($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVideoCall", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVideoCall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance288, create_fragment288, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVideoCall",
      options,
      id: create_fragment288.name
    });
  }
};
var MdVideoCall_default = MdVideoCall;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideoLabel.svelte
var file289 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideoLabel.svelte";
function create_default_slot289(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 13H3V5h18v11z");
      add_location(path, file289, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot289.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment289(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot289] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment289.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance289($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVideoLabel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVideoLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance289, create_fragment289, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVideoLabel",
      options,
      id: create_fragment289.name
    });
  }
};
var MdVideoLabel_default = MdVideoLabel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideoLibrary.svelte
var file290 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideoLibrary.svelte";
function create_default_slot290(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z");
      add_location(path, file290, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot290.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment290(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot290] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment290.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance290($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVideoLibrary", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVideoLibrary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance290, create_fragment290, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVideoLibrary",
      options,
      id: create_fragment290.name
    });
  }
};
var MdVideoLibrary_default = MdVideoLibrary;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideocam.svelte
var file291 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideocam.svelte";
function create_default_slot291(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z");
      add_location(path, file291, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot291.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment291(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot291] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment291.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance291($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVideocam", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVideocam = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance291, create_fragment291, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVideocam",
      options,
      id: create_fragment291.name
    });
  }
};
var MdVideocam_default = MdVideocam;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideocamOff.svelte
var file292 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideocamOff.svelte";
function create_default_slot292(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z");
      add_location(path, file292, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot292.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment292(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot292] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment292.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance292($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVideocamOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVideocamOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance292, create_fragment292, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVideocamOff",
      options,
      id: create_fragment292.name
    });
  }
};
var MdVideocamOff_default = MdVideocamOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeDown.svelte
var file293 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeDown.svelte";
function create_default_slot293(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z");
      add_location(path, file293, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot293.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment293(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot293] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment293.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance293($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVolumeDown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVolumeDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance293, create_fragment293, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVolumeDown",
      options,
      id: create_fragment293.name
    });
  }
};
var MdVolumeDown_default = MdVolumeDown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeMute.svelte
var file294 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeMute.svelte";
function create_default_slot294(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 9v6h4l5 5V4l-5 5H7z");
      add_location(path, file294, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot294.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment294(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot294] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment294.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance294($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVolumeMute", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVolumeMute = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance294, create_fragment294, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVolumeMute",
      options,
      id: create_fragment294.name
    });
  }
};
var MdVolumeMute_default = MdVolumeMute;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeOff.svelte
var file295 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeOff.svelte";
function create_default_slot295(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z");
      add_location(path, file295, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot295.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment295(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot295] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment295.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance295($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVolumeOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVolumeOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance295, create_fragment295, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVolumeOff",
      options,
      id: create_fragment295.name
    });
  }
};
var MdVolumeOff_default = MdVolumeOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeUp.svelte
var file296 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVolumeUp.svelte";
function create_default_slot296(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z");
      add_location(path, file296, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot296.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment296(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot296] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment296.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance296($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVolumeUp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVolumeUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance296, create_fragment296, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVolumeUp",
      options,
      id: create_fragment296.name
    });
  }
};
var MdVolumeUp_default = MdVolumeUp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWeb.svelte
var file297 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWeb.svelte";
function create_default_slot297(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z");
      add_location(path, file297, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot297.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment297(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot297] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment297.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance297($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWeb", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWeb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance297, create_fragment297, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWeb",
      options,
      id: create_fragment297.name
    });
  }
};
var MdWeb_default = MdWeb;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWebAsset.svelte
var file298 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWebAsset.svelte";
function create_default_slot298(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm0 14H5V8h14v10z");
      add_location(path, file298, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot298.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment298(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot298] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment298.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance298($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWebAsset", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWebAsset = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance298, create_fragment298, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWebAsset",
      options,
      id: create_fragment298.name
    });
  }
};
var MdWebAsset_default = MdWebAsset;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBusiness.svelte
var file299 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBusiness.svelte";
function create_default_slot299(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z");
      add_location(path, file299, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot299.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment299(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot299] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment299.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance299($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBusiness", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBusiness = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance299, create_fragment299, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBusiness",
      options,
      id: create_fragment299.name
    });
  }
};
var MdBusiness_default = MdBusiness;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCall.svelte
var file300 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCall.svelte";
function create_default_slot300(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z");
      add_location(path, file300, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot300.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment300(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot300] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment300.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance300($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCall", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance300, create_fragment300, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCall",
      options,
      id: create_fragment300.name
    });
  }
};
var MdCall_default = MdCall;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallEnd.svelte
var file301 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallEnd.svelte";
function create_default_slot301(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.11-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z");
      add_location(path, file301, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot301.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment301(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot301] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment301.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance301($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallEnd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallEnd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance301, create_fragment301, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallEnd",
      options,
      id: create_fragment301.name
    });
  }
};
var MdCallEnd_default = MdCallEnd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMade.svelte
var file302 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMade.svelte";
function create_default_slot302(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5z");
      add_location(path, file302, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot302.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment302(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot302] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment302.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance302($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallMade", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallMade = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance302, create_fragment302, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallMade",
      options,
      id: create_fragment302.name
    });
  }
};
var MdCallMade_default = MdCallMade;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMerge.svelte
var file303 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMerge.svelte";
function create_default_slot303(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z");
      add_location(path, file303, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot303.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment303(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot303] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment303.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance303($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallMerge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallMerge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance303, create_fragment303, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallMerge",
      options,
      id: create_fragment303.name
    });
  }
};
var MdCallMerge_default = MdCallMerge;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMissed.svelte
var file304 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMissed.svelte";
function create_default_slot304(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.59 7L12 14.59 6.41 9H11V7H3v8h2v-4.59l7 7 9-9z");
      add_location(path, file304, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot304.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment304(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot304] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment304.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance304($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallMissed", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallMissed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance304, create_fragment304, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallMissed",
      options,
      id: create_fragment304.name
    });
  }
};
var MdCallMissed_default = MdCallMissed;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMissedOutgoing.svelte
var file305 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallMissedOutgoing.svelte";
function create_default_slot305(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 8.41l9 9 7-7V15h2V7h-8v2h4.59L12 14.59 4.41 7 3 8.41z");
      add_location(path, file305, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot305.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment305(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot305] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment305.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance305($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallMissedOutgoing", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallMissedOutgoing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance305, create_fragment305, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallMissedOutgoing",
      options,
      id: create_fragment305.name
    });
  }
};
var MdCallMissedOutgoing_default = MdCallMissedOutgoing;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallReceived.svelte
var file306 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallReceived.svelte";
function create_default_slot306(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 5.41L18.59 4 7 15.59V9H5v10h10v-2H8.41z");
      add_location(path, file306, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot306.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment306(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot306] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment306.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance306($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallReceived", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallReceived = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance306, create_fragment306, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallReceived",
      options,
      id: create_fragment306.name
    });
  }
};
var MdCallReceived_default = MdCallReceived;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallSplit.svelte
var file307 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCallSplit.svelte";
function create_default_slot307(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 4l2.29 2.29-2.88 2.88 1.42 1.42 2.88-2.88L20 10V4zm-4 0H4v6l2.29-2.29 4.71 4.7V20h2v-8.41l-5.29-5.3z");
      add_location(path, file307, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot307.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment307(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot307] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment307.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance307($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCallSplit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCallSplit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance307, create_fragment307, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCallSplit",
      options,
      id: create_fragment307.name
    });
  }
};
var MdCallSplit_default = MdCallSplit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChat.svelte
var file308 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChat.svelte";
function create_default_slot308(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z");
      add_location(path, file308, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot308.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment308(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot308] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment308.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance308($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance308, create_fragment308, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChat",
      options,
      id: create_fragment308.name
    });
  }
};
var MdChat_default = MdChat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChatBubble.svelte
var file309 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChatBubble.svelte";
function create_default_slot309(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z");
      add_location(path, file309, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot309.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment309(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot309] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment309.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance309($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChatBubble", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChatBubble = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance309, create_fragment309, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChatBubble",
      options,
      id: create_fragment309.name
    });
  }
};
var MdChatBubble_default = MdChatBubble;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChatBubbleOutline.svelte
var file310 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChatBubbleOutline.svelte";
function create_default_slot310(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z");
      add_location(path, file310, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot310.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment310(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot310] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment310.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance310($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChatBubbleOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChatBubbleOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance310, create_fragment310, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChatBubbleOutline",
      options,
      id: create_fragment310.name
    });
  }
};
var MdChatBubbleOutline_default = MdChatBubbleOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClearAll.svelte
var file311 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClearAll.svelte";
function create_default_slot311(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 13h14v-2H5v2zm-2 4h14v-2H3v2zM7 7v2h14V7H7z");
      add_location(path, file311, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot311.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment311(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot311] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment311.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance311($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdClearAll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdClearAll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance311, create_fragment311, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdClearAll",
      options,
      id: create_fragment311.name
    });
  }
};
var MdClearAll_default = MdClearAll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdComment.svelte
var file312 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdComment.svelte";
function create_default_slot312(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z");
      add_location(path, file312, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot312.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment312(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot312] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment312.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance312($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdComment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdComment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance312, create_fragment312, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdComment",
      options,
      id: create_fragment312.name
    });
  }
};
var MdComment_default = MdComment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContactMail.svelte
var file313 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContactMail.svelte";
function create_default_slot313(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 8V7l-3 2-3-2v1l3 2 3-2zm1-5H2C.9 3 0 3.9 0 5v14c0 1.1.9 2 2 2h20c1.1 0 1.99-.9 1.99-2L24 5c0-1.1-.9-2-2-2zM8 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H2v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1zm8-6h-8V6h8v6z");
      add_location(path, file313, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot313.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment313(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot313] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment313.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance313($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdContactMail", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdContactMail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance313, create_fragment313, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdContactMail",
      options,
      id: create_fragment313.name
    });
  }
};
var MdContactMail_default = MdContactMail;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContactPhone.svelte
var file314 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContactPhone.svelte";
function create_default_slot314(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 3H2C.9 3 0 3.9 0 5v14c0 1.1.9 2 2 2h20c1.1 0 1.99-.9 1.99-2L24 5c0-1.1-.9-2-2-2zM8 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H2v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1zm3.85-4h1.64L21 16l-1.99 1.99c-1.31-.98-2.28-2.38-2.73-3.99-.18-.64-.28-1.31-.28-2s.1-1.36.28-2c.45-1.62 1.42-3.01 2.73-3.99L21 8l-1.51 2h-1.64c-.22.63-.35 1.3-.35 2s.13 1.37.35 2z");
      add_location(path, file314, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot314.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment314(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot314] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment314.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance314($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdContactPhone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdContactPhone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance314, create_fragment314, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdContactPhone",
      options,
      id: create_fragment314.name
    });
  }
};
var MdContactPhone_default = MdContactPhone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContacts.svelte
var file315 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContacts.svelte";
function create_default_slot315(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 0H4v2h16V0zM4 24h16v-2H4v2zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 2.75c1.24 0 2.25 1.01 2.25 2.25s-1.01 2.25-2.25 2.25S9.75 10.24 9.75 9 10.76 6.75 12 6.75zM17 17H7v-1.5c0-1.67 3.33-2.5 5-2.5s5 .83 5 2.5V17z");
      add_location(path, file315, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot315.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment315(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot315] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment315.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance315($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdContacts", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdContacts = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance315, create_fragment315, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdContacts",
      options,
      id: create_fragment315.name
    });
  }
};
var MdContacts_default = MdContacts;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDialerSip.svelte
var file316 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDialerSip.svelte";
function create_default_slot316(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3h-1v5h1V3zm-2 2h-2V4h2V3h-3v3h2v1h-2v1h3V5zm3-2v5h1V6h2V3h-3zm2 2h-1V4h1v1zm0 10.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.01.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.21c.27-.26.35-.65.24-1C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1z");
      add_location(path, file316, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot316.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment316(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot316] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment316.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance316($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDialerSip", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDialerSip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance316, create_fragment316, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDialerSip",
      options,
      id: create_fragment316.name
    });
  }
};
var MdDialerSip_default = MdDialerSip;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDialpad.svelte
var file317 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDialpad.svelte";
function create_default_slot317(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 19c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM6 1c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file317, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot317.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment317(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot317] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment317.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance317($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDialpad", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDialpad = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance317, create_fragment317, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDialpad",
      options,
      id: create_fragment317.name
    });
  }
};
var MdDialpad_default = MdDialpad;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEmail.svelte
var file318 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEmail.svelte";
function create_default_slot318(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z");
      add_location(path, file318, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot318.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment318(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot318] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment318.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance318($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEmail", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEmail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance318, create_fragment318, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEmail",
      options,
      id: create_fragment318.name
    });
  }
};
var MdEmail_default = MdEmail;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForum.svelte
var file319 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForum.svelte";
function create_default_slot319(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z");
      add_location(path, file319, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot319.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment319(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot319] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment319.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance319($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdForum", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdForum = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance319, create_fragment319, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdForum",
      options,
      id: create_fragment319.name
    });
  }
};
var MdForum_default = MdForum;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImportContacts.svelte
var file320 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImportContacts.svelte";
function create_default_slot320(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 5c-1.11-.35-2.33-.5-3.5-.5-1.95 0-4.05.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5S2.45 4.9 1 6v14.65c0 .25.25.5.5.5.1 0 .15-.05.25-.05C3.1 20.45 5.05 20 6.5 20c1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.3 4.75 1.05.1.05.15.05.25.05.25 0 .5-.25.5-.5V6c-.6-.45-1.25-.75-2-1zm0 13.5c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V8c1.35-.85 3.8-1.5 5.5-1.5 1.2 0 2.4.15 3.5.5v11.5z");
      add_location(path, file320, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot320.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment320(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot320] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment320.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance320($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdImportContacts", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdImportContacts = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance320, create_fragment320, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdImportContacts",
      options,
      id: create_fragment320.name
    });
  }
};
var MdImportContacts_default = MdImportContacts;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImportExport.svelte
var file321 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImportExport.svelte";
function create_default_slot321(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z");
      add_location(path, file321, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot321.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment321(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot321] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment321.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance321($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdImportExport", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdImportExport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance321, create_fragment321, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdImportExport",
      options,
      id: create_fragment321.name
    });
  }
};
var MdImportExport_default = MdImportExport;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInvertColorsOff.svelte
var file322 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInvertColorsOff.svelte";
function create_default_slot322(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.65 20.87l-2.35-2.35-6.3-6.29-3.56-3.57-1.42-1.41L4.27 4.5 3 5.77l2.78 2.78c-2.55 3.14-2.36 7.76.56 10.69C7.9 20.8 9.95 21.58 12 21.58c1.79 0 3.57-.59 5.03-1.78l2.7 2.7L21 21.23l-.35-.36zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59c0-1.32.43-2.57 1.21-3.6L12 14.77v4.82zM12 5.1v4.58l7.25 7.26c1.37-2.96.84-6.57-1.6-9.01L12 2.27l-3.7 3.7 1.41 1.41L12 5.1z");
      add_location(path, file322, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot322.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment322(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot322] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment322.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance322($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInvertColorsOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInvertColorsOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance322, create_fragment322, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInvertColorsOff",
      options,
      id: create_fragment322.name
    });
  }
};
var MdInvertColorsOff_default = MdInvertColorsOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLiveHelp.svelte
var file323 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLiveHelp.svelte";
function create_default_slot323(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h4l3 3 3-3h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-6 16h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 11.9 13 12.5 13 14h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z");
      add_location(path, file323, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot323.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment323(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot323] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment323.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance323($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLiveHelp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLiveHelp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance323, create_fragment323, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLiveHelp",
      options,
      id: create_fragment323.name
    });
  }
};
var MdLiveHelp_default = MdLiveHelp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationOff.svelte
var file324 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationOff.svelte";
function create_default_slot324(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 6.5c1.38 0 2.5 1.12 2.5 2.5 0 .74-.33 1.39-.83 1.85l3.63 3.63c.98-1.86 1.7-3.8 1.7-5.48 0-3.87-3.13-7-7-7-1.98 0-3.76.83-5.04 2.15l3.19 3.19c.46-.52 1.11-.84 1.85-.84zm4.37 9.6l-4.63-4.63-.11-.11L3.27 3 2 4.27l3.18 3.18C5.07 7.95 5 8.47 5 9c0 5.25 7 13 7 13s1.67-1.85 3.38-4.35L18.73 21 20 19.73l-3.63-3.63z");
      add_location(path, file324, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot324.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment324(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot324] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment324.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance324($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocationOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocationOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance324, create_fragment324, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocationOff",
      options,
      id: create_fragment324.name
    });
  }
};
var MdLocationOff_default = MdLocationOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationOn.svelte
var file325 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationOn.svelte";
function create_default_slot325(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z");
      add_location(path, file325, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot325.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment325(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot325] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment325.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance325($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocationOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocationOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance325, create_fragment325, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocationOn",
      options,
      id: create_fragment325.name
    });
  }
};
var MdLocationOn_default = MdLocationOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMailOutline.svelte
var file326 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMailOutline.svelte";
function create_default_slot326(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V8l8 5 8-5v10zm-8-7L4 6h16l-8 5z");
      add_location(path, file326, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot326.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment326(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot326] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment326.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance326($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMailOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMailOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance326, create_fragment326, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMailOutline",
      options,
      id: create_fragment326.name
    });
  }
};
var MdMailOutline_default = MdMailOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMessage.svelte
var file327 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMessage.svelte";
function create_default_slot327(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z");
      add_location(path, file327, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot327.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment327(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot327] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment327.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance327($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMessage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMessage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance327, create_fragment327, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMessage",
      options,
      id: create_fragment327.name
    });
  }
};
var MdMessage_default = MdMessage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNoSim.svelte
var file328 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNoSim.svelte";
function create_default_slot328(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.99 5c0-1.1-.89-2-1.99-2h-7L7.66 5.34 19 16.68 18.99 5zM3.65 3.88L2.38 5.15 5 7.77V19c0 1.1.9 2 2 2h10.01c.35 0 .67-.1.96-.26l1.88 1.88 1.27-1.27L3.65 3.88z");
      add_location(path, file328, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot328.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment328(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot328] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment328.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance328($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNoSim", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNoSim = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance328, create_fragment328, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNoSim",
      options,
      id: create_fragment328.name
    });
  }
};
var MdNoSim_default = MdNoSim;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhone.svelte
var file329 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhone.svelte";
function create_default_slot329(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z");
      add_location(path, file329, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot329.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment329(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot329] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment329.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance329($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance329, create_fragment329, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhone",
      options,
      id: create_fragment329.name
    });
  }
};
var MdPhone_default = MdPhone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkErase.svelte
var file330 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkErase.svelte";
function create_default_slot330(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 8.2l-1-1-4 4-4-4-1 1 4 4-4 4 1 1 4-4 4 4 1-1-4-4 4-4zM19 1H9c-1.1 0-2 .9-2 2v3h2V4h10v16H9v-2H7v3c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2z");
      add_location(path, file330, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot330.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment330(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot330] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment330.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance330($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonelinkErase", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonelinkErase = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance330, create_fragment330, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonelinkErase",
      options,
      id: create_fragment330.name
    });
  }
};
var MdPhonelinkErase_default = MdPhonelinkErase;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkLock.svelte
var file331 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkLock.svelte";
function create_default_slot331(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 1H9c-1.1 0-2 .9-2 2v3h2V4h10v16H9v-2H7v3c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm-8.2 10V9.5C10.8 8.1 9.4 7 8 7S5.2 8.1 5.2 9.5V11c-.6 0-1.2.6-1.2 1.2v3.5c0 .7.6 1.3 1.2 1.3h5.5c.7 0 1.3-.6 1.3-1.2v-3.5c0-.7-.6-1.3-1.2-1.3zm-1.3 0h-3V9.5c0-.8.7-1.3 1.5-1.3s1.5.5 1.5 1.3V11z");
      add_location(path, file331, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot331.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment331(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot331] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment331.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance331($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonelinkLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonelinkLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance331, create_fragment331, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonelinkLock",
      options,
      id: create_fragment331.name
    });
  }
};
var MdPhonelinkLock_default = MdPhonelinkLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkRing.svelte
var file332 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkRing.svelte";
function create_default_slot332(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.1 7.7l-1 1c1.8 1.8 1.8 4.6 0 6.5l1 1c2.5-2.3 2.5-6.1 0-8.5zM18 9.8l-1 1c.5.7.5 1.6 0 2.3l1 1c1.2-1.2 1.2-3 0-4.3zM14 1H4c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 19H4V4h10v16z");
      add_location(path, file332, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot332.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment332(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot332] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment332.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance332($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonelinkRing", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonelinkRing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance332, create_fragment332, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonelinkRing",
      options,
      id: create_fragment332.name
    });
  }
};
var MdPhonelinkRing_default = MdPhonelinkRing;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkSetup.svelte
var file333 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkSetup.svelte";
function create_default_slot333(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.8 12.5v-1l1.1-.8c.1-.1.1-.2.1-.3l-1-1.7c-.1-.1-.2-.2-.3-.1l-1.3.4c-.3-.2-.6-.4-.9-.5l-.2-1.3c0-.1-.1-.2-.3-.2H7c-.1 0-.2.1-.3.2l-.2 1.3c-.3.1-.6.3-.9.5l-1.3-.5c-.1 0-.2 0-.3.1l-1 1.7c-.1.1 0 .2.1.3l1.1.8v1l-1.1.8c-.1.2-.1.3-.1.4l1 1.7c.1.1.2.2.3.1l1.4-.4c.3.2.6.4.9.5l.2 1.3c-.1.1.1.2.2.2h2c.1 0 .2-.1.3-.2l.2-1.3c.3-.1.6-.3.9-.5l1.3.5c.1 0 .2 0 .3-.1l1-1.7c.1-.1 0-.2-.1-.3l-1.1-.9zM8 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM19 1H9c-1.1 0-2 .9-2 2v3h2V4h10v16H9v-2H7v3c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2z");
      add_location(path, file333, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot333.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment333(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot333] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment333.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance333($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonelinkSetup", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonelinkSetup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance333, create_fragment333, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonelinkSetup",
      options,
      id: create_fragment333.name
    });
  }
};
var MdPhonelinkSetup_default = MdPhonelinkSetup;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPortableWifiOff.svelte
var file334 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPortableWifiOff.svelte";
function create_default_slot334(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.56 14.24c.28-.69.44-1.45.44-2.24 0-3.31-2.69-6-6-6-.79 0-1.55.16-2.24.44l1.62 1.62c.2-.03.41-.06.62-.06 2.21 0 4 1.79 4 4 0 .21-.02.42-.05.63l1.61 1.61zM12 4c4.42 0 8 3.58 8 8 0 1.35-.35 2.62-.95 3.74l1.47 1.47C21.46 15.69 22 13.91 22 12c0-5.52-4.48-10-10-10-1.91 0-3.69.55-5.21 1.47l1.46 1.46C9.37 4.34 10.65 4 12 4zM3.27 2.5L2 3.77l2.1 2.1C2.79 7.57 2 9.69 2 12c0 3.7 2.01 6.92 4.99 8.65l1-1.73C5.61 17.53 4 14.96 4 12c0-1.76.57-3.38 1.53-4.69l1.43 1.44C6.36 9.68 6 10.8 6 12c0 2.22 1.21 4.15 3 5.19l1-1.74c-1.19-.7-2-1.97-2-3.45 0-.65.17-1.25.44-1.79l1.58 1.58L10 12c0 1.1.9 2 2 2l.21-.02.01.01 7.51 7.51L21 20.23 4.27 3.5l-1-1z");
      add_location(path, file334, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot334.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment334(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot334] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment334.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance334($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPortableWifiOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPortableWifiOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance334, create_fragment334, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPortableWifiOff",
      options,
      id: create_fragment334.name
    });
  }
};
var MdPortableWifiOff_default = MdPortableWifiOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPresentToAll.svelte
var file335 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPresentToAll.svelte";
function create_default_slot335(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.11 0-2 .89-2 2v14c0 1.11.89 2 2 2h18c1.11 0 2-.89 2-2V5c0-1.11-.89-2-2-2zm0 16.02H3V4.98h18v14.04zM10 12H8l4-4 4 4h-2v4h-4v-4z");
      add_location(path, file335, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot335.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment335(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot335] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment335.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance335($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPresentToAll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPresentToAll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance335, create_fragment335, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPresentToAll",
      options,
      id: create_fragment335.name
    });
  }
};
var MdPresentToAll_default = MdPresentToAll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRingVolume.svelte
var file336 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRingVolume.svelte";
function create_default_slot336(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23.71 16.67C20.66 13.78 16.54 12 12 12 7.46 12 3.34 13.78.29 16.67c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l2.48 2.48c.18.18.43.29.71.29.27 0 .52-.11.7-.28.79-.74 1.69-1.36 2.66-1.85.33-.16.56-.5.56-.9v-3.1c1.45-.48 3-.73 4.6-.73s3.15.25 4.6.72v3.1c0 .39.23.74.56.9.98.49 1.87 1.12 2.66 1.85.18.18.43.28.7.28.28 0 .53-.11.71-.29l2.48-2.48c.18-.18.29-.43.29-.71 0-.27-.11-.52-.29-.7zM21.16 6.26l-1.41-1.41-3.56 3.55 1.41 1.41s3.45-3.52 3.56-3.55zM13 2h-2v5h2V2zM6.4 9.81L7.81 8.4 4.26 4.84 2.84 6.26c.11.03 3.56 3.55 3.56 3.55z");
      add_location(path, file336, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot336.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment336(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot336] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment336.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance336($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRingVolume", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRingVolume = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance336, create_fragment336, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRingVolume",
      options,
      id: create_fragment336.name
    });
  }
};
var MdRingVolume_default = MdRingVolume;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRssFeed.svelte
var file337 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRssFeed.svelte";
function create_default_slot337(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file337, 4, 10, 151);
      attr_dev(path1, "d", "M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z");
      add_location(path1, file337, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot337.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment337(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot337] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment337.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance337($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRssFeed", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRssFeed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance337, create_fragment337, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRssFeed",
      options,
      id: create_fragment337.name
    });
  }
};
var MdRssFeed_default = MdRssFeed;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenShare.svelte
var file338 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenShare.svelte";
function create_default_slot338(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18c1.1 0 1.99-.9 1.99-2L22 6c0-1.11-.9-2-2-2H4c-1.11 0-2 .89-2 2v10c0 1.1.89 2 2 2H0v2h24v-2h-4zm-7-3.53v-2.19c-2.78 0-4.61.85-6 2.72.56-2.67 2.11-5.33 6-5.87V7l4 3.73-4 3.74z");
      add_location(path, file338, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot338.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment338(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot338] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment338.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance338($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdScreenShare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdScreenShare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance338, create_fragment338, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdScreenShare",
      options,
      id: create_fragment338.name
    });
  }
};
var MdScreenShare_default = MdScreenShare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerPhone.svelte
var file339 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerPhone.svelte";
function create_default_slot339(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 7.07L8.43 8.5c.91-.91 2.18-1.48 3.57-1.48s2.66.57 3.57 1.48L17 7.07C15.72 5.79 13.95 5 12 5s-3.72.79-5 2.07zM12 1C8.98 1 6.24 2.23 4.25 4.21l1.41 1.41C7.28 4 9.53 3 12 3s4.72 1 6.34 2.62l1.41-1.41C17.76 2.23 15.02 1 12 1zm2.86 9.01L9.14 10C8.51 10 8 10.51 8 11.14v9.71c0 .63.51 1.14 1.14 1.14h5.71c.63 0 1.14-.51 1.14-1.14v-9.71c.01-.63-.5-1.13-1.13-1.13zM15 20H9v-8h6v8z");
      add_location(path, file339, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot339.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment339(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot339] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment339.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance339($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpeakerPhone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpeakerPhone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance339, create_fragment339, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpeakerPhone",
      options,
      id: create_fragment339.name
    });
  }
};
var MdSpeakerPhone_default = MdSpeakerPhone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayCurrentLandscape.svelte
var file340 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayCurrentLandscape.svelte";
function create_default_slot340(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1.01 7L1 17c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2H3c-1.1 0-1.99.9-1.99 2zM19 7v10H5V7h14z");
      add_location(path, file340, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot340.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment340(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot340] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment340.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance340($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStayCurrentLandscape", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStayCurrentLandscape = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance340, create_fragment340, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStayCurrentLandscape",
      options,
      id: create_fragment340.name
    });
  }
};
var MdStayCurrentLandscape_default = MdStayCurrentLandscape;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayCurrentPortrait.svelte
var file341 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayCurrentPortrait.svelte";
function create_default_slot341(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 1.01L7 1c-1.1 0-1.99.9-1.99 2v18c0 1.1.89 2 1.99 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z");
      add_location(path, file341, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot341.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment341(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot341] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment341.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance341($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStayCurrentPortrait", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStayCurrentPortrait = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance341, create_fragment341, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStayCurrentPortrait",
      options,
      id: create_fragment341.name
    });
  }
};
var MdStayCurrentPortrait_default = MdStayCurrentPortrait;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayPrimaryLandscape.svelte
var file342 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayPrimaryLandscape.svelte";
function create_default_slot342(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1.01 7L1 17c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2H3c-1.1 0-1.99.9-1.99 2zM19 7v10H5V7h14z");
      add_location(path, file342, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot342.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment342(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot342] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment342.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance342($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStayPrimaryLandscape", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStayPrimaryLandscape = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance342, create_fragment342, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStayPrimaryLandscape",
      options,
      id: create_fragment342.name
    });
  }
};
var MdStayPrimaryLandscape_default = MdStayPrimaryLandscape;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayPrimaryPortrait.svelte
var file343 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStayPrimaryPortrait.svelte";
function create_default_slot343(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 1.01L7 1c-1.1 0-1.99.9-1.99 2v18c0 1.1.89 2 1.99 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z");
      add_location(path, file343, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot343.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment343(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot343] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment343.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance343($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStayPrimaryPortrait", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStayPrimaryPortrait = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance343, create_fragment343, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStayPrimaryPortrait",
      options,
      id: create_fragment343.name
    });
  }
};
var MdStayPrimaryPortrait_default = MdStayPrimaryPortrait;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStopScreenShare.svelte
var file344 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStopScreenShare.svelte";
function create_default_slot344(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.22 18.02l2 2H24v-2h-2.78zm.77-2l.01-10c0-1.11-.9-2-2-2H7.22l5.23 5.23c.18-.04.36-.07.55-.1V7.02l4 3.73-1.58 1.47 5.54 5.54c.61-.33 1.03-.99 1.03-1.74zM2.39 1.73L1.11 3l1.54 1.54c-.4.36-.65.89-.65 1.48v10c0 1.1.89 2 2 2H0v2h18.13l2.71 2.71 1.27-1.27L2.39 1.73zM7 15.02c.31-1.48.92-2.95 2.07-4.06l1.59 1.59c-1.54.38-2.7 1.18-3.66 2.47z");
      add_location(path, file344, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot344.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment344(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot344] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment344.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance344($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStopScreenShare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStopScreenShare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance344, create_fragment344, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStopScreenShare",
      options,
      id: create_fragment344.name
    });
  }
};
var MdStopScreenShare_default = MdStopScreenShare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapCalls.svelte
var file345 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwapCalls.svelte";
function create_default_slot345(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4l-4 4h3v7c0 1.1-.9 2-2 2s-2-.9-2-2V8c0-2.21-1.79-4-4-4S5 5.79 5 8v7H2l4 4 4-4H7V8c0-1.1.9-2 2-2s2 .9 2 2v7c0 2.21 1.79 4 4 4s4-1.79 4-4V8h3l-4-4z");
      add_location(path, file345, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot345.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment345(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot345] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment345.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance345($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSwapCalls", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSwapCalls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance345, create_fragment345, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSwapCalls",
      options,
      id: create_fragment345.name
    });
  }
};
var MdSwapCalls_default = MdSwapCalls;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTextsms.svelte
var file346 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTextsms.svelte";
function create_default_slot346(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM9 11H7V9h2v2zm4 0h-2V9h2v2zm4 0h-2V9h2v2z");
      add_location(path, file346, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot346.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment346(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot346] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment346.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance346($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTextsms", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTextsms = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance346, create_fragment346, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTextsms",
      options,
      id: create_fragment346.name
    });
  }
};
var MdTextsms_default = MdTextsms;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVoicemail.svelte
var file347 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVoicemail.svelte";
function create_default_slot347(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.5 6C15.46 6 13 8.46 13 11.5c0 1.33.47 2.55 1.26 3.5H9.74c.79-.95 1.26-2.17 1.26-3.5C11 8.46 8.54 6 5.5 6S0 8.46 0 11.5 2.46 17 5.5 17h13c3.04 0 5.5-2.46 5.5-5.5S21.54 6 18.5 6zm-13 9C3.57 15 2 13.43 2 11.5S3.57 8 5.5 8 9 9.57 9 11.5 7.43 15 5.5 15zm13 0c-1.93 0-3.5-1.57-3.5-3.5S16.57 8 18.5 8 22 9.57 22 11.5 20.43 15 18.5 15z");
      add_location(path, file347, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot347.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment347(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot347] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment347.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance347($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVoicemail", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVoicemail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance347, create_fragment347, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVoicemail",
      options,
      id: create_fragment347.name
    });
  }
};
var MdVoicemail_default = MdVoicemail;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVpnKey.svelte
var file348 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVpnKey.svelte";
function create_default_slot348(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.65 10C11.83 7.67 9.61 6 7 6c-3.31 0-6 2.69-6 6s2.69 6 6 6c2.61 0 4.83-1.67 5.65-4H17v4h4v-4h2v-4H12.65zM7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file348, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot348.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment348(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot348] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment348.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance348($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVpnKey", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVpnKey = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance348, create_fragment348, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVpnKey",
      options,
      id: create_fragment348.name
    });
  }
};
var MdVpnKey_default = MdVpnKey;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAdd.svelte
var file349 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAdd.svelte";
function create_default_slot349(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z");
      add_location(path, file349, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot349.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment349(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot349] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment349.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance349($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance349, create_fragment349, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAdd",
      options,
      id: create_fragment349.name
    });
  }
};
var MdAdd_default = MdAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddBox.svelte
var file350 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddBox.svelte";
function create_default_slot350(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z");
      add_location(path, file350, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot350.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment350(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot350] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment350.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance350($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddBox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance350, create_fragment350, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddBox",
      options,
      id: create_fragment350.name
    });
  }
};
var MdAddBox_default = MdAddBox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddCircle.svelte
var file351 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddCircle.svelte";
function create_default_slot351(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z");
      add_location(path, file351, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot351.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment351(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot351] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment351.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance351($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance351, create_fragment351, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddCircle",
      options,
      id: create_fragment351.name
    });
  }
};
var MdAddCircle_default = MdAddCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddCircleOutline.svelte
var file352 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddCircleOutline.svelte";
function create_default_slot352(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file352, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot352.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment352(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot352] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment352.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance352($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddCircleOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddCircleOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance352, create_fragment352, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddCircleOutline",
      options,
      id: create_fragment352.name
    });
  }
};
var MdAddCircleOutline_default = MdAddCircleOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArchive.svelte
var file353 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArchive.svelte";
function create_default_slot353(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z");
      add_location(path, file353, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot353.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment353(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot353] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment353.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance353($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArchive", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArchive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance353, create_fragment353, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArchive",
      options,
      id: create_fragment353.name
    });
  }
};
var MdArchive_default = MdArchive;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBackspace.svelte
var file354 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBackspace.svelte";
function create_default_slot354(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-3 12.59L17.59 17 14 13.41 10.41 17 9 15.59 12.59 12 9 8.41 10.41 7 14 10.59 17.59 7 19 8.41 15.41 12 19 15.59z");
      add_location(path, file354, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot354.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment354(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot354] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment354.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance354($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBackspace", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBackspace = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance354, create_fragment354, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBackspace",
      options,
      id: create_fragment354.name
    });
  }
};
var MdBackspace_default = MdBackspace;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlock.svelte
var file355 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlock.svelte";
function create_default_slot355(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z");
      add_location(path, file355, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot355.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment355(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot355] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment355.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance355($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBlock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance355, create_fragment355, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBlock",
      options,
      id: create_fragment355.name
    });
  }
};
var MdBlock_default = MdBlock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClear.svelte
var file356 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClear.svelte";
function create_default_slot356(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
      add_location(path, file356, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot356.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment356(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot356] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment356.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance356($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdClear", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdClear = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance356, create_fragment356, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdClear",
      options,
      id: create_fragment356.name
    });
  }
};
var MdClear_default = MdClear;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContentCopy.svelte
var file357 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContentCopy.svelte";
function create_default_slot357(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z");
      add_location(path, file357, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot357.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment357(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot357] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment357.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance357($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdContentCopy", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdContentCopy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance357, create_fragment357, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdContentCopy",
      options,
      id: create_fragment357.name
    });
  }
};
var MdContentCopy_default = MdContentCopy;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContentCut.svelte
var file358 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContentCut.svelte";
function create_default_slot358(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z");
      add_location(path, file358, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot358.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment358(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot358] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment358.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance358($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdContentCut", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdContentCut = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance358, create_fragment358, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdContentCut",
      options,
      id: create_fragment358.name
    });
  }
};
var MdContentCut_default = MdContentCut;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContentPaste.svelte
var file359 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdContentPaste.svelte";
function create_default_slot359(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z");
      add_location(path, file359, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot359.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment359(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot359] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment359.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance359($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdContentPaste", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdContentPaste = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance359, create_fragment359, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdContentPaste",
      options,
      id: create_fragment359.name
    });
  }
};
var MdContentPaste_default = MdContentPaste;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCreate.svelte
var file360 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCreate.svelte";
function create_default_slot360(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z");
      add_location(path, file360, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot360.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment360(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot360] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment360.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance360($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCreate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCreate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance360, create_fragment360, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCreate",
      options,
      id: create_fragment360.name
    });
  }
};
var MdCreate_default = MdCreate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeleteSweep.svelte
var file361 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeleteSweep.svelte";
function create_default_slot361(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 16h4v2h-4zm0-8h7v2h-7zm0 4h6v2h-6zM3 18c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V8H3v10zM14 5h-3l-1-1H6L5 5H2v2h12z");
      add_location(path, file361, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot361.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment361(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot361] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment361.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance361($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDeleteSweep", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDeleteSweep = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance361, create_fragment361, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDeleteSweep",
      options,
      id: create_fragment361.name
    });
  }
};
var MdDeleteSweep_default = MdDeleteSweep;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDrafts.svelte
var file362 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDrafts.svelte";
function create_default_slot362(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z");
      add_location(path, file362, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot362.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment362(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot362] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment362.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance362($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDrafts", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDrafts = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance362, create_fragment362, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDrafts",
      options,
      id: create_fragment362.name
    });
  }
};
var MdDrafts_default = MdDrafts;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterList.svelte
var file363 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterList.svelte";
function create_default_slot363(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z");
      add_location(path, file363, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot363.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment363(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot363] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment363.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance363($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterList", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance363, create_fragment363, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterList",
      options,
      id: create_fragment363.name
    });
  }
};
var MdFilterList_default = MdFilterList;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlag.svelte
var file364 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlag.svelte";
function create_default_slot364(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z");
      add_location(path, file364, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot364.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment364(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot364] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment364.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance364($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlag", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance364, create_fragment364, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlag",
      options,
      id: create_fragment364.name
    });
  }
};
var MdFlag_default = MdFlag;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFontDownload.svelte
var file365 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFontDownload.svelte";
function create_default_slot365(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z");
      add_location(path, file365, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot365.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment365(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot365] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment365.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance365($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFontDownload", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFontDownload = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance365, create_fragment365, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFontDownload",
      options,
      id: create_fragment365.name
    });
  }
};
var MdFontDownload_default = MdFontDownload;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward.svelte
var file366 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdForward.svelte";
function create_default_slot366(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8V4l8 8-8 8v-4H4V8z");
      add_location(path, file366, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot366.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment366(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot366] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment366.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance366($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdForward", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdForward = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance366, create_fragment366, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdForward",
      options,
      id: create_fragment366.name
    });
  }
};
var MdForward_default = MdForward;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGesture.svelte
var file367 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGesture.svelte";
function create_default_slot367(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z");
      add_location(path, file367, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot367.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment367(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot367] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment367.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance367($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGesture", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance367, create_fragment367, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGesture",
      options,
      id: create_fragment367.name
    });
  }
};
var MdGesture_default = MdGesture;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInbox.svelte
var file368 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInbox.svelte";
function create_default_slot368(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H4.99c-1.11 0-1.98.89-1.98 2L3 19c0 1.1.88 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.11-.9-2-2-2zm0 12h-4c0 1.66-1.35 3-3 3s-3-1.34-3-3H4.99V5H19v10z");
      add_location(path, file368, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot368.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment368(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot368] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment368.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance368($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInbox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance368, create_fragment368, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInbox",
      options,
      id: create_fragment368.name
    });
  }
};
var MdInbox_default = MdInbox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLink.svelte
var file369 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLink.svelte";
function create_default_slot369(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z");
      add_location(path, file369, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot369.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment369(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot369] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment369.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance369($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLink", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance369, create_fragment369, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLink",
      options,
      id: create_fragment369.name
    });
  }
};
var MdLink_default = MdLink;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLowPriority.svelte
var file370 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLowPriority.svelte";
function create_default_slot370(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5z");
      add_location(path, file370, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot370.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment370(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot370] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment370.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance370($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLowPriority", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLowPriority = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance370, create_fragment370, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLowPriority",
      options,
      id: create_fragment370.name
    });
  }
};
var MdLowPriority_default = MdLowPriority;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMail.svelte
var file371 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMail.svelte";
function create_default_slot371(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z");
      add_location(path, file371, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot371.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment371(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot371] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment371.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance371($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMail", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance371, create_fragment371, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMail",
      options,
      id: create_fragment371.name
    });
  }
};
var MdMail_default = MdMail;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMarkunread.svelte
var file372 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMarkunread.svelte";
function create_default_slot372(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z");
      add_location(path, file372, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot372.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment372(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot372] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment372.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance372($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMarkunread", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMarkunread = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance372, create_fragment372, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMarkunread",
      options,
      id: create_fragment372.name
    });
  }
};
var MdMarkunread_default = MdMarkunread;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoveToInbox.svelte
var file373 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoveToInbox.svelte";
function create_default_slot373(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H4.99c-1.11 0-1.98.9-1.98 2L3 19c0 1.1.88 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12h-4c0 1.66-1.35 3-3 3s-3-1.34-3-3H4.99V5H19v10zm-3-5h-2V7h-4v3H8l4 4 4-4z");
      add_location(path, file373, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot373.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment373(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot373] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment373.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance373($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMoveToInbox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMoveToInbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance373, create_fragment373, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMoveToInbox",
      options,
      id: create_fragment373.name
    });
  }
};
var MdMoveToInbox_default = MdMoveToInbox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNextWeek.svelte
var file374 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNextWeek.svelte";
function create_default_slot374(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 7h-4V5c0-.55-.22-1.05-.59-1.41C15.05 3.22 14.55 3 14 3h-4c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zM10 5h4v2h-4V5zm1 13.5l-1-1 3-3-3-3 1-1 4 4-4 4z");
      add_location(path, file374, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot374.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment374(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot374] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment374.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance374($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNextWeek", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNextWeek = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance374, create_fragment374, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNextWeek",
      options,
      id: create_fragment374.name
    });
  }
};
var MdNextWeek_default = MdNextWeek;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRedo.svelte
var file375 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRedo.svelte";
function create_default_slot375(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z");
      add_location(path, file375, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot375.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment375(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot375] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment375.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance375($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRedo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRedo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance375, create_fragment375, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRedo",
      options,
      id: create_fragment375.name
    });
  }
};
var MdRedo_default = MdRedo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemove.svelte
var file376 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemove.svelte";
function create_default_slot376(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 13H5v-2h14v2z");
      add_location(path, file376, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot376.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment376(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot376] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment376.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance376($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRemove", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRemove = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance376, create_fragment376, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRemove",
      options,
      id: create_fragment376.name
    });
  }
};
var MdRemove_default = MdRemove;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveCircle.svelte
var file377 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveCircle.svelte";
function create_default_slot377(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z");
      add_location(path, file377, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot377.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment377(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot377] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment377.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance377($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRemoveCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRemoveCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance377, create_fragment377, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRemoveCircle",
      options,
      id: create_fragment377.name
    });
  }
};
var MdRemoveCircle_default = MdRemoveCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveCircleOutline.svelte
var file378 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveCircleOutline.svelte";
function create_default_slot378(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file378, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot378.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment378(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot378] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment378.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance378($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRemoveCircleOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRemoveCircleOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance378, create_fragment378, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRemoveCircleOutline",
      options,
      id: create_fragment378.name
    });
  }
};
var MdRemoveCircleOutline_default = MdRemoveCircleOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReply.svelte
var file379 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReply.svelte";
function create_default_slot379(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z");
      add_location(path, file379, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot379.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment379(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot379] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment379.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance379($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReply", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReply = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance379, create_fragment379, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReply",
      options,
      id: create_fragment379.name
    });
  }
};
var MdReply_default = MdReply;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplyAll.svelte
var file380 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReplyAll.svelte";
function create_default_slot380(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 8V5l-7 7 7 7v-3l-4-4 4-4zm6 1V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z");
      add_location(path, file380, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot380.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment380(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot380] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment380.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance380($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReplyAll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReplyAll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance380, create_fragment380, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReplyAll",
      options,
      id: create_fragment380.name
    });
  }
};
var MdReplyAll_default = MdReplyAll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReport.svelte
var file381 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdReport.svelte";
function create_default_slot381(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z");
      add_location(path, file381, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot381.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment381(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot381] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment381.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance381($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdReport", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdReport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance381, create_fragment381, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdReport",
      options,
      id: create_fragment381.name
    });
  }
};
var MdReport_default = MdReport;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSave.svelte
var file382 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSave.svelte";
function create_default_slot382(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z");
      add_location(path, file382, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot382.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment382(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot382] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment382.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance382($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSave", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSave = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance382, create_fragment382, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSave",
      options,
      id: create_fragment382.name
    });
  }
};
var MdSave_default = MdSave;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSelectAll.svelte
var file383 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSelectAll.svelte";
function create_default_slot383(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z");
      add_location(path, file383, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot383.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment383(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot383] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment383.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance383($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSelectAll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSelectAll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance383, create_fragment383, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSelectAll",
      options,
      id: create_fragment383.name
    });
  }
};
var MdSelectAll_default = MdSelectAll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSend.svelte
var file384 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSend.svelte";
function create_default_slot384(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z");
      add_location(path, file384, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot384.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment384(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot384] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment384.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance384($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSend", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSend = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance384, create_fragment384, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSend",
      options,
      id: create_fragment384.name
    });
  }
};
var MdSend_default = MdSend;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSort.svelte
var file385 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSort.svelte";
function create_default_slot385(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z");
      add_location(path, file385, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot385.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment385(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot385] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment385.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance385($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSort", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSort = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance385, create_fragment385, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSort",
      options,
      id: create_fragment385.name
    });
  }
};
var MdSort_default = MdSort;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTextFormat.svelte
var file386 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTextFormat.svelte";
function create_default_slot386(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 17v2h14v-2H5zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1l.9-2.2zM12 5.98L13.87 11h-3.74L12 5.98z");
      add_location(path, file386, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot386.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment386(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot386] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment386.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance386($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTextFormat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTextFormat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance386, create_fragment386, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTextFormat",
      options,
      id: create_fragment386.name
    });
  }
};
var MdTextFormat_default = MdTextFormat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUnarchive.svelte
var file387 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUnarchive.svelte";
function create_default_slot387(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.55 5.22l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.15.55L3.46 5.22C3.17 5.57 3 6.01 3 6.5V19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.49-.17-.93-.45-1.28zM12 9.5l5.5 5.5H14v2h-4v-2H6.5L12 9.5zM5.12 5l.82-1h12l.93 1H5.12z");
      add_location(path, file387, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot387.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment387(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot387] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment387.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance387($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdUnarchive", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdUnarchive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance387, create_fragment387, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdUnarchive",
      options,
      id: create_fragment387.name
    });
  }
};
var MdUnarchive_default = MdUnarchive;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUndo.svelte
var file388 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUndo.svelte";
function create_default_slot388(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z");
      add_location(path, file388, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot388.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment388(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot388] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment388.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance388($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdUndo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdUndo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance388, create_fragment388, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdUndo",
      options,
      id: create_fragment388.name
    });
  }
};
var MdUndo_default = MdUndo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWeekend.svelte
var file389 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWeekend.svelte";
function create_default_slot389(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 10c-1.1 0-2 .9-2 2v3H5v-3c0-1.1-.9-2-2-2s-2 .9-2 2v5c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-5c0-1.1-.9-2-2-2zm-3-5H6c-1.1 0-2 .9-2 2v2.15c1.16.41 2 1.51 2 2.82V14h12v-2.03c0-1.3.84-2.4 2-2.82V7c0-1.1-.9-2-2-2z");
      add_location(path, file389, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot389.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment389(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot389] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment389.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance389($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWeekend", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWeekend = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance389, create_fragment389, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWeekend",
      options,
      id: create_fragment389.name
    });
  }
};
var MdWeekend_default = MdWeekend;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessAlarm.svelte
var file390 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessAlarm.svelte";
function create_default_slot390(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file390, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot390.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment390(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot390] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment390.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance390($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccessAlarm", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccessAlarm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance390, create_fragment390, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccessAlarm",
      options,
      id: create_fragment390.name
    });
  }
};
var MdAccessAlarm_default = MdAccessAlarm;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessAlarms.svelte
var file391 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessAlarms.svelte";
function create_default_slot391(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 5.7l-4.6-3.9-1.3 1.5 4.6 3.9L22 5.7zM7.9 3.4L6.6 1.9 2 5.7l1.3 1.5 4.6-3.8zM12.5 8H11v6l4.7 2.9.8-1.2-4-2.4V8zM12 4c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9zm0 16c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7z");
      add_location(path, file391, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot391.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment391(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot391] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment391.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance391($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccessAlarms", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccessAlarms = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance391, create_fragment391, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccessAlarms",
      options,
      id: create_fragment391.name
    });
  }
};
var MdAccessAlarms_default = MdAccessAlarms;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessTime.svelte
var file392 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAccessTime.svelte";
function create_default_slot392(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z");
      add_location(path, file392, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot392.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment392(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot392] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment392.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance392($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAccessTime", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAccessTime = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance392, create_fragment392, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAccessTime",
      options,
      id: create_fragment392.name
    });
  }
};
var MdAccessTime_default = MdAccessTime;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddAlarm.svelte
var file393 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddAlarm.svelte";
function create_default_slot393(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3H8v2h3v3h2v-3h3v-2h-3V9z");
      add_location(path, file393, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot393.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment393(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot393] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment393.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance393($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddAlarm", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddAlarm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance393, create_fragment393, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddAlarm",
      options,
      id: create_fragment393.name
    });
  }
};
var MdAddAlarm_default = MdAddAlarm;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirplanemodeActive.svelte
var file394 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirplanemodeActive.svelte";
function create_default_slot394(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M10.18 9");
      add_location(path0, file394, 4, 10, 151);
      attr_dev(path1, "d", "M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z");
      add_location(path1, file394, 5, 0, 173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot394.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment394(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot394] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment394.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance394($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirplanemodeActive", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirplanemodeActive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance394, create_fragment394, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirplanemodeActive",
      options,
      id: create_fragment394.name
    });
  }
};
var MdAirplanemodeActive_default = MdAirplanemodeActive;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirplanemodeInactive.svelte
var file395 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirplanemodeInactive.svelte";
function create_default_slot395(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 9V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5v3.68l7.83 7.83L21 16v-2l-8-5zM3 5.27l4.99 4.99L2 14v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-3.73L18.73 21 20 19.73 4.27 4 3 5.27z");
      add_location(path, file395, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot395.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment395(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot395] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment395.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance395($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirplanemodeInactive", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirplanemodeInactive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance395, create_fragment395, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirplanemodeInactive",
      options,
      id: create_fragment395.name
    });
  }
};
var MdAirplanemodeInactive_default = MdAirplanemodeInactive;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery20.svelte
var file396 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery20.svelte";
function create_default_slot396(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M7 17v3.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V17H7z");
      add_location(path0, file396, 4, 10, 151);
      attr_dev(path1, "d", "M17 5.33C17 4.6 16.4 4 15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V17h10V5.33z");
      add_location(path1, file396, 5, 0, 232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot396.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment396(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot396] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment396.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance396($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBattery20", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBattery20 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance396, create_fragment396, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBattery20",
      options,
      id: create_fragment396.name
    });
  }
};
var MdBattery20_default = MdBattery20;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery30.svelte
var file397 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery30.svelte";
function create_default_slot397(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 5.33C17 4.6 16.4 4 15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V15h10V5.33z");
      add_location(path0, file397, 4, 10, 151);
      attr_dev(path1, "d", "M7 15v5.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V15H7z");
      add_location(path1, file397, 5, 0, 241);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot397.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment397(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot397] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment397.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance397($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBattery30", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBattery30 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance397, create_fragment397, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBattery30",
      options,
      id: create_fragment397.name
    });
  }
};
var MdBattery30_default = MdBattery30;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery50.svelte
var file398 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery50.svelte";
function create_default_slot398(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 5.33C17 4.6 16.4 4 15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V13h10V5.33z");
      add_location(path0, file398, 4, 10, 151);
      attr_dev(path1, "d", "M7 13v7.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V13H7z");
      add_location(path1, file398, 5, 0, 241);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot398.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment398(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot398] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment398.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance398($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBattery50", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBattery50 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance398, create_fragment398, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBattery50",
      options,
      id: create_fragment398.name
    });
  }
};
var MdBattery50_default = MdBattery50;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery60.svelte
var file399 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery60.svelte";
function create_default_slot399(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 5.33C17 4.6 16.4 4 15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V11h10V5.33z");
      add_location(path0, file399, 4, 10, 151);
      attr_dev(path1, "d", "M7 11v9.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V11H7z");
      add_location(path1, file399, 5, 0, 241);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot399.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment399(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot399] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment399.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance399($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBattery60", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBattery60 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance399, create_fragment399, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBattery60",
      options,
      id: create_fragment399.name
    });
  }
};
var MdBattery60_default = MdBattery60;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery80.svelte
var file400 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery80.svelte";
function create_default_slot400(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 5.33C17 4.6 16.4 4 15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V9h10V5.33z");
      add_location(path0, file400, 4, 10, 151);
      attr_dev(path1, "d", "M7 9v11.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V9H7z");
      add_location(path1, file400, 5, 0, 240);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot400.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment400(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot400] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment400.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance400($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBattery80", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBattery80 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance400, create_fragment400, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBattery80",
      options,
      id: create_fragment400.name
    });
  }
};
var MdBattery80_default = MdBattery80;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery90.svelte
var file401 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBattery90.svelte";
function create_default_slot401(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 5.33C17 4.6 16.4 4 15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V8h10V5.33z");
      add_location(path0, file401, 4, 10, 151);
      attr_dev(path1, "d", "M7 8v12.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V8H7z");
      add_location(path1, file401, 5, 0, 240);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot401.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment401(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot401] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment401.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance401($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBattery90", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBattery90 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance401, create_fragment401, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBattery90",
      options,
      id: create_fragment401.name
    });
  }
};
var MdBattery90_default = MdBattery90;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryAlert.svelte
var file402 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryAlert.svelte";
function create_default_slot402(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4zM13 18h-2v-2h2v2zm0-4h-2V9h2v5z");
      add_location(path, file402, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot402.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment402(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot402] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment402.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance402($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryAlert", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryAlert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance402, create_fragment402, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryAlert",
      options,
      id: create_fragment402.name
    });
  }
};
var MdBatteryAlert_default = MdBatteryAlert;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging20.svelte
var file403 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging20.svelte";
function create_default_slot403(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M11 20v-3H7v3.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V17h-4.4L11 20z");
      add_location(path0, file403, 4, 10, 151);
      attr_dev(path1, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V17h4v-2.5H9L13 7v5.5h2L12.6 17H17V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path1, file403, 5, 0, 247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot403.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment403(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot403] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment403.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance403($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryCharging20", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryCharging20 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance403, create_fragment403, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryCharging20",
      options,
      id: create_fragment403.name
    });
  }
};
var MdBatteryCharging20_default = MdBatteryCharging20;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging30.svelte
var file404 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging30.svelte";
function create_default_slot404(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v9.17h2L13 7v5.5h2l-1.07 2H17V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path0, file404, 4, 10, 151);
      attr_dev(path1, "d", "M11 20v-5.5H7v6.17C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V14.5h-3.07L11 20z");
      add_location(path1, file404, 5, 0, 264);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot404.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment404(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot404] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment404.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance404($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryCharging30", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryCharging30 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance404, create_fragment404, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryCharging30",
      options,
      id: create_fragment404.name
    });
  }
};
var MdBatteryCharging30_default = MdBatteryCharging30;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging50.svelte
var file405 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging50.svelte";
function create_default_slot405(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M14.47 13.5L11 20v-5.5H9l.53-1H7v7.17C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V13.5h-2.53z");
      add_location(path0, file405, 4, 10, 151);
      attr_dev(path1, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v8.17h2.53L13 7v5.5h2l-.53 1H17V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path1, file405, 5, 0, 265);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot405.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment405(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot405] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment405.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance405($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryCharging50", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryCharging50 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance405, create_fragment405, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryCharging50",
      options,
      id: create_fragment405.name
    });
  }
};
var MdBatteryCharging50_default = MdBatteryCharging50;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging60.svelte
var file406 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging60.svelte";
function create_default_slot406(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V11h3.87L13 7v4h4V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path0, file406, 4, 10, 151);
      attr_dev(path1, "d", "M13 12.5h2L11 20v-5.5H9l1.87-3.5H7v9.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V11h-4v1.5z");
      add_location(path1, file406, 5, 0, 252);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot406.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment406(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot406] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment406.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance406($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryCharging60", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryCharging60 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance406, create_fragment406, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryCharging60",
      options,
      id: create_fragment406.name
    });
  }
};
var MdBatteryCharging60_default = MdBatteryCharging60;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging80.svelte
var file407 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging80.svelte";
function create_default_slot407(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V9h4.93L13 7v2h4V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path0, file407, 4, 10, 151);
      attr_dev(path1, "d", "M13 12.5h2L11 20v-5.5H9L11.93 9H7v11.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V9h-4v3.5z");
      add_location(path1, file407, 5, 0, 251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot407.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment407(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot407] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment407.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance407($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryCharging80", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryCharging80 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance407, create_fragment407, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryCharging80",
      options,
      id: create_fragment407.name
    });
  }
};
var MdBatteryCharging80_default = MdBatteryCharging80;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging90.svelte
var file408 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryCharging90.svelte";
function create_default_slot408(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V8h5.47L13 7v1h4V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path0, file408, 4, 10, 151);
      attr_dev(path1, "d", "M13 12.5h2L11 20v-5.5H9L12.47 8H7v12.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V8h-4v4.5z");
      add_location(path1, file408, 5, 0, 251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot408.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment408(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot408] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment408.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance408($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryCharging90", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryCharging90 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance408, create_fragment408, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryCharging90",
      options,
      id: create_fragment408.name
    });
  }
};
var MdBatteryCharging90_default = MdBatteryCharging90;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryChargingFull.svelte
var file409 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryChargingFull.svelte";
function create_default_slot409(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4zM11 20v-5.5H9L13 7v5.5h2L11 20z");
      add_location(path, file409, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot409.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment409(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot409] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment409.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance409($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryChargingFull", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryChargingFull = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance409, create_fragment409, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryChargingFull",
      options,
      id: create_fragment409.name
    });
  }
};
var MdBatteryChargingFull_default = MdBatteryChargingFull;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryFull.svelte
var file410 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryFull.svelte";
function create_default_slot410(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path, file410, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot410.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment410(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot410] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment410.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance410($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryFull", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryFull = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance410, create_fragment410, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryFull",
      options,
      id: create_fragment410.name
    });
  }
};
var MdBatteryFull_default = MdBatteryFull;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryStd.svelte
var file411 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryStd.svelte";
function create_default_slot411(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4z");
      add_location(path, file411, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot411.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment411(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot411] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment411.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance411($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryStd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryStd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance411, create_fragment411, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryStd",
      options,
      id: create_fragment411.name
    });
  }
};
var MdBatteryStd_default = MdBatteryStd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryUnknown.svelte
var file412 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBatteryUnknown.svelte";
function create_default_slot412(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33v15.33C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V5.33C17 4.6 16.4 4 15.67 4zm-2.72 13.95h-1.9v-1.9h1.9v1.9zm1.35-5.26s-.38.42-.67.71c-.48.48-.83 1.15-.83 1.6h-1.6c0-.83.46-1.52.93-2l.93-.94c.27-.27.44-.65.44-1.06 0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5H9c0-1.66 1.34-3 3-3s3 1.34 3 3c0 .66-.27 1.26-.7 1.69z");
      add_location(path, file412, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot412.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment412(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot412] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment412.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance412($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBatteryUnknown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBatteryUnknown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance412, create_fragment412, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBatteryUnknown",
      options,
      id: create_fragment412.name
    });
  }
};
var MdBatteryUnknown_default = MdBatteryUnknown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetooth.svelte
var file413 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetooth.svelte";
function create_default_slot413(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z");
      add_location(path, file413, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot413.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment413(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot413] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment413.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance413($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBluetooth", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBluetooth = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance413, create_fragment413, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBluetooth",
      options,
      id: create_fragment413.name
    });
  }
};
var MdBluetooth_default = MdBluetooth;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothConnected.svelte
var file414 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothConnected.svelte";
function create_default_slot414(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 12l-2-2-2 2 2 2 2-2zm10.71-4.29L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88zM19 10l-2 2 2 2 2-2-2-2z");
      add_location(path, file414, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot414.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment414(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot414] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment414.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance414($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBluetoothConnected", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBluetoothConnected = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance414, create_fragment414, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBluetoothConnected",
      options,
      id: create_fragment414.name
    });
  }
};
var MdBluetoothConnected_default = MdBluetoothConnected;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothDisabled.svelte
var file415 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothDisabled.svelte";
function create_default_slot415(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 5.83l1.88 1.88-1.6 1.6 1.41 1.41 3.02-3.02L12 2h-1v5.03l2 2v-3.2zM5.41 4L4 5.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l4.29-4.29 2.3 2.29L20 18.59 5.41 4zM13 18.17v-3.76l1.88 1.88L13 18.17z");
      add_location(path, file415, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot415.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment415(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot415] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment415.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance415($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBluetoothDisabled", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBluetoothDisabled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance415, create_fragment415, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBluetoothDisabled",
      options,
      id: create_fragment415.name
    });
  }
};
var MdBluetoothDisabled_default = MdBluetoothDisabled;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothSearching.svelte
var file416 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothSearching.svelte";
function create_default_slot416(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z");
      add_location(path, file416, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot416.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment416(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot416] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment416.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance416($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBluetoothSearching", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBluetoothSearching = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance416, create_fragment416, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBluetoothSearching",
      options,
      id: create_fragment416.name
    });
  }
};
var MdBluetoothSearching_default = MdBluetoothSearching;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessAuto.svelte
var file417 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessAuto.svelte";
function create_default_slot417(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.85 12.65h2.3L12 9l-1.15 3.65zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM14.3 16l-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9h-1.9z");
      add_location(path, file417, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot417.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment417(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot417] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment417.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance417($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightnessAuto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightnessAuto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance417, create_fragment417, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightnessAuto",
      options,
      id: create_fragment417.name
    });
  }
};
var MdBrightnessAuto_default = MdBrightnessAuto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessHigh.svelte
var file418 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessHigh.svelte";
function create_default_slot418(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z");
      add_location(path, file418, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot418.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment418(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot418] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment418.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance418($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightnessHigh", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightnessHigh = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance418, create_fragment418, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightnessHigh",
      options,
      id: create_fragment418.name
    });
  }
};
var MdBrightnessHigh_default = MdBrightnessHigh;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessLow.svelte
var file419 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessLow.svelte";
function create_default_slot419(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.31L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z");
      add_location(path, file419, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot419.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment419(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot419] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment419.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance419($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightnessLow", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightnessLow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance419, create_fragment419, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightnessLow",
      options,
      id: create_fragment419.name
    });
  }
};
var MdBrightnessLow_default = MdBrightnessLow;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessMedium.svelte
var file420 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightnessMedium.svelte";
function create_default_slot420(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.31L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18V6c3.31 0 6 2.69 6 6s-2.69 6-6 6z");
      add_location(path, file420, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot420.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment420(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot420] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment420.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance420($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightnessMedium", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightnessMedium = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance420, create_fragment420, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightnessMedium",
      options,
      id: create_fragment420.name
    });
  }
};
var MdBrightnessMedium_default = MdBrightnessMedium;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDataUsage.svelte
var file421 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDataUsage.svelte";
function create_default_slot421(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 2.05v3.03c3.39.49 6 3.39 6 6.92 0 .9-.18 1.75-.48 2.54l2.6 1.53c.56-1.24.88-2.62.88-4.07 0-5.18-3.95-9.45-9-9.95zM12 19c-3.87 0-7-3.13-7-7 0-3.53 2.61-6.43 6-6.92V2.05c-5.06.5-9 4.76-9 9.95 0 5.52 4.47 10 9.99 10 3.31 0 6.24-1.61 8.06-4.09l-2.6-1.53C16.17 17.98 14.21 19 12 19z");
      add_location(path, file421, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot421.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment421(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot421] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment421.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance421($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDataUsage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDataUsage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance421, create_fragment421, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDataUsage",
      options,
      id: create_fragment421.name
    });
  }
};
var MdDataUsage_default = MdDataUsage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeveloperMode.svelte
var file422 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeveloperMode.svelte";
function create_default_slot422(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 5h10v2h2V3c0-1.1-.9-1.99-2-1.99L7 1c-1.1 0-2 .9-2 2v4h2V5zm8.41 11.59L20 12l-4.59-4.59L14 8.83 17.17 12 14 15.17l1.41 1.42zM10 15.17L6.83 12 10 8.83 8.59 7.41 4 12l4.59 4.59L10 15.17zM17 19H7v-2H5v4c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2v-4h-2v2z");
      add_location(path, file422, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot422.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment422(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot422] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment422.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance422($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDeveloperMode", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDeveloperMode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance422, create_fragment422, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDeveloperMode",
      options,
      id: create_fragment422.name
    });
  }
};
var MdDeveloperMode_default = MdDeveloperMode;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDevices.svelte
var file423 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDevices.svelte";
function create_default_slot423(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6h18V4H4c-1.1 0-2 .9-2 2v11H0v3h14v-3H4V6zm19 2h-6c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-1 9h-4v-7h4v7z");
      add_location(path, file423, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot423.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment423(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot423] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment423.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance423($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDevices", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDevices = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance423, create_fragment423, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDevices",
      options,
      id: create_fragment423.name
    });
  }
};
var MdDevices_default = MdDevices;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDvr.svelte
var file424 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDvr.svelte";
function create_default_slot424(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.1-.9-2-2-2zm0 14H3V5h18v12zm-2-9H8v2h11V8zm0 4H8v2h11v-2zM7 8H5v2h2V8zm0 4H5v2h2v-2z");
      add_location(path, file424, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot424.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment424(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot424] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment424.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance424($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDvr", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDvr = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance424, create_fragment424, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDvr",
      options,
      id: create_fragment424.name
    });
  }
};
var MdDvr_default = MdDvr;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGpsFixed.svelte
var file425 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGpsFixed.svelte";
function create_default_slot425(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file425, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot425.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment425(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot425] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment425.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance425($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGpsFixed", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGpsFixed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance425, create_fragment425, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGpsFixed",
      options,
      id: create_fragment425.name
    });
  }
};
var MdGpsFixed_default = MdGpsFixed;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGpsNotFixed.svelte
var file426 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGpsNotFixed.svelte";
function create_default_slot426(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file426, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot426.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment426(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot426] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment426.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance426($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGpsNotFixed", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGpsNotFixed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance426, create_fragment426, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGpsNotFixed",
      options,
      id: create_fragment426.name
    });
  }
};
var MdGpsNotFixed_default = MdGpsNotFixed;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGpsOff.svelte
var file427 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGpsOff.svelte";
function create_default_slot427(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06c-1.13.12-2.19.46-3.16.97l1.5 1.5C10.16 5.19 11.06 5 12 5c3.87 0 7 3.13 7 7 0 .94-.19 1.84-.52 2.65l1.5 1.5c.5-.96.84-2.02.97-3.15H23v-2h-2.06zM3 4.27l2.04 2.04C3.97 7.62 3.25 9.23 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c1.77-.2 3.38-.91 4.69-1.98L19.73 21 21 19.73 4.27 3 3 4.27zm13.27 13.27C15.09 18.45 13.61 19 12 19c-3.87 0-7-3.13-7-7 0-1.61.55-3.09 1.46-4.27l9.81 9.81z");
      add_location(path, file427, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot427.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment427(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot427] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment427.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance427($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGpsOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGpsOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance427, create_fragment427, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGpsOff",
      options,
      id: create_fragment427.name
    });
  }
};
var MdGpsOff_default = MdGpsOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGraphicEq.svelte
var file428 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGraphicEq.svelte";
function create_default_slot428(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 18h2V6H7v12zm4 4h2V2h-2v20zm-8-8h2v-4H3v4zm12 4h2V6h-2v12zm4-8v4h2v-4h-2z");
      add_location(path, file428, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot428.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment428(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot428] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment428.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance428($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGraphicEq", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGraphicEq = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance428, create_fragment428, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGraphicEq",
      options,
      id: create_fragment428.name
    });
  }
};
var MdGraphicEq_default = MdGraphicEq;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationDisabled.svelte
var file429 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationDisabled.svelte";
function create_default_slot429(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06c-1.13.12-2.19.46-3.16.97l1.5 1.5C10.16 5.19 11.06 5 12 5c3.87 0 7 3.13 7 7 0 .94-.19 1.84-.52 2.65l1.5 1.5c.5-.96.84-2.02.97-3.15H23v-2h-2.06zM3 4.27l2.04 2.04C3.97 7.62 3.25 9.23 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c1.77-.2 3.38-.91 4.69-1.98L19.73 21 21 19.73 4.27 3 3 4.27zm13.27 13.27C15.09 18.45 13.61 19 12 19c-3.87 0-7-3.13-7-7 0-1.61.55-3.09 1.46-4.27l9.81 9.81z");
      add_location(path, file429, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot429.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment429(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot429] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment429.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance429($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocationDisabled", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocationDisabled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance429, create_fragment429, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocationDisabled",
      options,
      id: create_fragment429.name
    });
  }
};
var MdLocationDisabled_default = MdLocationDisabled;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationSearching.svelte
var file430 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationSearching.svelte";
function create_default_slot430(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file430, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot430.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment430(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot430] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment430.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance430($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocationSearching", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocationSearching = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance430, create_fragment430, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocationSearching",
      options,
      id: create_fragment430.name
    });
  }
};
var MdLocationSearching_default = MdLocationSearching;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkCell.svelte
var file431 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkCell.svelte";
function create_default_slot431(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M2 22h20V2z");
      add_location(path0, file431, 4, 10, 151);
      attr_dev(path1, "d", "M17 7L2 22h15z");
      add_location(path1, file431, 5, 0, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot431.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment431(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot431] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment431.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance431($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNetworkCell", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNetworkCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance431, create_fragment431, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNetworkCell",
      options,
      id: create_fragment431.name
    });
  }
};
var MdNetworkCell_default = MdNetworkCell;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkWifi.svelte
var file432 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkWifi.svelte";
function create_default_slot432(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01z");
      add_location(path0, file432, 4, 10, 151);
      attr_dev(path1, "d", "M3.53 10.95l8.46 10.54.01.01.01-.01 8.46-10.54C20.04 10.62 16.81 8 12 8c-4.81 0-8.04 2.62-8.47 2.95z");
      add_location(path1, file432, 5, 0, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot432.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment432(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot432] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment432.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance432($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNetworkWifi", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNetworkWifi = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance432, create_fragment432, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNetworkWifi",
      options,
      id: create_fragment432.name
    });
  }
};
var MdNetworkWifi_default = MdNetworkWifi;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNfc.svelte
var file433 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNfc.svelte";
function create_default_slot433(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H4V4h16v16zM18 6h-5c-1.1 0-2 .9-2 2v2.28c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V8h3v8H8V8h2V6H6v12h12V6z");
      add_location(path, file433, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot433.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment433(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot433] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment433.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance433($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNfc", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNfc = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance433, create_fragment433, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNfc",
      options,
      id: create_fragment433.name
    });
  }
};
var MdNfc_default = MdNfc;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenLockLandscape.svelte
var file434 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenLockLandscape.svelte";
function create_default_slot434(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 5H3c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-2 12H5V7h14v10zm-9-1h4c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1v-1c0-1.11-.9-2-2-2-1.11 0-2 .9-2 2v1c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1zm.8-6c0-.66.54-1.2 1.2-1.2.66 0 1.2.54 1.2 1.2v1h-2.4v-1z");
      add_location(path, file434, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot434.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment434(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot434] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment434.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance434($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdScreenLockLandscape", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdScreenLockLandscape = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance434, create_fragment434, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdScreenLockLandscape",
      options,
      id: create_fragment434.name
    });
  }
};
var MdScreenLockLandscape_default = MdScreenLockLandscape;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenLockPortrait.svelte
var file435 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenLockPortrait.svelte";
function create_default_slot435(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 16h4c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1v-1c0-1.11-.9-2-2-2-1.11 0-2 .9-2 2v1c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1zm.8-6c0-.66.54-1.2 1.2-1.2.66 0 1.2.54 1.2 1.2v1h-2.4v-1zM17 1H7c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 18H7V5h10v14z");
      add_location(path, file435, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot435.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment435(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot435] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment435.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance435($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdScreenLockPortrait", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdScreenLockPortrait = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance435, create_fragment435, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdScreenLockPortrait",
      options,
      id: create_fragment435.name
    });
  }
};
var MdScreenLockPortrait_default = MdScreenLockPortrait;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenLockRotation.svelte
var file436 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenLockRotation.svelte";
function create_default_slot436(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23.25 12.77l-2.57-2.57-1.41 1.41 2.22 2.22-5.66 5.66L4.51 8.17l5.66-5.66 2.1 2.1 1.41-1.41L11.23.75c-.59-.59-1.54-.59-2.12 0L2.75 7.11c-.59.59-.59 1.54 0 2.12l12.02 12.02c.59.59 1.54.59 2.12 0l6.36-6.36c.59-.59.59-1.54 0-2.12zM8.47 20.48C5.2 18.94 2.86 15.76 2.5 12H1c.51 6.16 5.66 11 11.95 11l.66-.03-3.81-3.82-1.33 1.33zM16 9h5c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1v-.5C21 1.12 19.88 0 18.5 0S16 1.12 16 2.5V3c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1zm.8-6.5c0-.94.76-1.7 1.7-1.7s1.7.76 1.7 1.7V3h-3.4v-.5z");
      add_location(path, file436, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot436.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment436(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot436] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment436.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance436($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdScreenLockRotation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdScreenLockRotation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance436, create_fragment436, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdScreenLockRotation",
      options,
      id: create_fragment436.name
    });
  }
};
var MdScreenLockRotation_default = MdScreenLockRotation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenRotation.svelte
var file437 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScreenRotation.svelte";
function create_default_slot437(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h1.5C23.44 4.84 18.29 0 12 0l-.66.03 3.81 3.81 1.33-1.32zm-6.25-.77c-.59-.59-1.54-.59-2.12 0L1.75 8.11c-.59.59-.59 1.54 0 2.12l12.02 12.02c.59.59 1.54.59 2.12 0l6.36-6.36c.59-.59.59-1.54 0-2.12L10.23 1.75zm4.6 19.44L2.81 9.17l6.36-6.36 12.02 12.02-6.36 6.36zm-7.31.29C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32z");
      add_location(path, file437, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot437.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment437(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot437] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment437.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance437($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdScreenRotation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdScreenRotation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance437, create_fragment437, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdScreenRotation",
      options,
      id: create_fragment437.name
    });
  }
};
var MdScreenRotation_default = MdScreenRotation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSdStorage.svelte
var file438 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSdStorage.svelte";
function create_default_slot438(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2h-8L4.02 8 4 20c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-6 6h-2V4h2v4zm3 0h-2V4h2v4zm3 0h-2V4h2v4z");
      add_location(path, file438, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot438.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment438(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot438] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment438.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance438($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSdStorage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSdStorage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance438, create_fragment438, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSdStorage",
      options,
      id: create_fragment438.name
    });
  }
};
var MdSdStorage_default = MdSdStorage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsSystemDaydream.svelte
var file439 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSettingsSystemDaydream.svelte";
function create_default_slot439(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 16h6.5c1.38 0 2.5-1.12 2.5-2.5S16.88 11 15.5 11h-.05c-.24-1.69-1.69-3-3.45-3-1.4 0-2.6.83-3.16 2.02h-.16C7.17 10.18 6 11.45 6 13c0 1.66 1.34 3 3 3zM21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z");
      add_location(path, file439, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot439.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment439(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot439] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment439.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance439($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSettingsSystemDaydream", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSettingsSystemDaydream = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance439, create_fragment439, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSettingsSystemDaydream",
      options,
      id: create_fragment439.name
    });
  }
};
var MdSettingsSystemDaydream_default = MdSettingsSystemDaydream;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular0Bar.svelte
var file440 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular0Bar.svelte";
function create_default_slot440(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 22h20V2z");
      add_location(path, file440, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot440.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment440(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot440] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment440.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance440($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellular0Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellular0Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance440, create_fragment440, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellular0Bar",
      options,
      id: create_fragment440.name
    });
  }
};
var MdSignalCellular0Bar_default = MdSignalCellular0Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular1Bar.svelte
var file441 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular1Bar.svelte";
function create_default_slot441(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M2 22h20V2z");
      add_location(path0, file441, 4, 10, 151);
      attr_dev(path1, "d", "M12 12L2 22h10z");
      add_location(path1, file441, 5, 0, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot441.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment441(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot441] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment441.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance441($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellular1Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellular1Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance441, create_fragment441, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellular1Bar",
      options,
      id: create_fragment441.name
    });
  }
};
var MdSignalCellular1Bar_default = MdSignalCellular1Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular2Bar.svelte
var file442 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular2Bar.svelte";
function create_default_slot442(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M2 22h20V2z");
      add_location(path0, file442, 4, 10, 151);
      attr_dev(path1, "d", "M14 10L2 22h12z");
      add_location(path1, file442, 5, 0, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot442.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment442(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot442] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment442.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance442($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellular2Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellular2Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance442, create_fragment442, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellular2Bar",
      options,
      id: create_fragment442.name
    });
  }
};
var MdSignalCellular2Bar_default = MdSignalCellular2Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular3Bar.svelte
var file443 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular3Bar.svelte";
function create_default_slot443(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M2 22h20V2z");
      add_location(path0, file443, 4, 10, 151);
      attr_dev(path1, "d", "M17 7L2 22h15z");
      add_location(path1, file443, 5, 0, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot443.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment443(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot443] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment443.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance443($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellular3Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellular3Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance443, create_fragment443, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellular3Bar",
      options,
      id: create_fragment443.name
    });
  }
};
var MdSignalCellular3Bar_default = MdSignalCellular3Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular4Bar.svelte
var file444 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellular4Bar.svelte";
function create_default_slot444(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 22h20V2z");
      add_location(path, file444, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot444.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment444(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot444] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment444.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance444($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellular4Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellular4Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance444, create_fragment444, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellular4Bar",
      options,
      id: create_fragment444.name
    });
  }
};
var MdSignalCellular4Bar_default = MdSignalCellular4Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet0Bar.svelte
var file445 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet0Bar.svelte";
function create_default_slot445(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M22 8V2L2 22h16V8z");
      add_location(path0, file445, 4, 10, 151);
      attr_dev(path1, "d", "M20 22h2v-2h-2v2zm0-12v8h2v-8h-2z");
      add_location(path1, file445, 5, 0, 183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot445.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment445(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot445] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment445.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance445($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularConnectedNoInternet0Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularConnectedNoInternet0Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance445, create_fragment445, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularConnectedNoInternet0Bar",
      options,
      id: create_fragment445.name
    });
  }
};
var MdSignalCellularConnectedNoInternet0Bar_default = MdSignalCellularConnectedNoInternet0Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet1Bar.svelte
var file446 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet1Bar.svelte";
function create_default_slot446(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M22 8V2L2 22h16V8z");
      add_location(path0, file446, 4, 10, 151);
      attr_dev(path1, "d", "M20 10v8h2v-8h-2zm-8 12V12L2 22h10zm8 0h2v-2h-2v2z");
      add_location(path1, file446, 5, 0, 183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot446.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment446(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot446] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment446.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance446($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularConnectedNoInternet1Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularConnectedNoInternet1Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance446, create_fragment446, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularConnectedNoInternet1Bar",
      options,
      id: create_fragment446.name
    });
  }
};
var MdSignalCellularConnectedNoInternet1Bar_default = MdSignalCellularConnectedNoInternet1Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet2Bar.svelte
var file447 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet2Bar.svelte";
function create_default_slot447(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M22 8V2L2 22h16V8z");
      add_location(path0, file447, 4, 10, 151);
      attr_dev(path1, "d", "M14 22V10L2 22h12zm6-12v8h2v-8h-2zm0 12h2v-2h-2v2z");
      add_location(path1, file447, 5, 0, 183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot447.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment447(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot447] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment447.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance447($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularConnectedNoInternet2Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularConnectedNoInternet2Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance447, create_fragment447, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularConnectedNoInternet2Bar",
      options,
      id: create_fragment447.name
    });
  }
};
var MdSignalCellularConnectedNoInternet2Bar_default = MdSignalCellularConnectedNoInternet2Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet3Bar.svelte
var file448 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet3Bar.svelte";
function create_default_slot448(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M22 8V2L2 22h16V8z");
      add_location(path0, file448, 4, 10, 151);
      attr_dev(path1, "d", "M17 22V7L2 22h15zm3-12v8h2v-8h-2zm0 12h2v-2h-2v2z");
      add_location(path1, file448, 5, 0, 183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot448.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment448(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot448] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment448.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance448($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularConnectedNoInternet3Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularConnectedNoInternet3Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance448, create_fragment448, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularConnectedNoInternet3Bar",
      options,
      id: create_fragment448.name
    });
  }
};
var MdSignalCellularConnectedNoInternet3Bar_default = MdSignalCellularConnectedNoInternet3Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet4Bar.svelte
var file449 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularConnectedNoInternet4Bar.svelte";
function create_default_slot449(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18h2v-8h-2v8zm0 4h2v-2h-2v2zM2 22h16V8h4V2L2 22z");
      add_location(path, file449, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot449.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment449(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot449] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment449.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance449($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularConnectedNoInternet4Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularConnectedNoInternet4Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance449, create_fragment449, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularConnectedNoInternet4Bar",
      options,
      id: create_fragment449.name
    });
  }
};
var MdSignalCellularConnectedNoInternet4Bar_default = MdSignalCellularConnectedNoInternet4Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularNoSim.svelte
var file450 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularNoSim.svelte";
function create_default_slot450(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.99 5c0-1.1-.89-2-1.99-2h-7L7.66 5.34 19 16.68 18.99 5zM3.65 3.88L2.38 5.15 5 7.77V19c0 1.1.9 2 2 2h10.01c.35 0 .67-.1.96-.26l1.88 1.88 1.27-1.27L3.65 3.88z");
      add_location(path, file450, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot450.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment450(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot450] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment450.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance450($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularNoSim", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularNoSim = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance450, create_fragment450, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularNoSim",
      options,
      id: create_fragment450.name
    });
  }
};
var MdSignalCellularNoSim_default = MdSignalCellularNoSim;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularNull.svelte
var file451 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularNull.svelte";
function create_default_slot451(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6.83V20H6.83L20 6.83M22 2L2 22h20V2z");
      add_location(path, file451, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot451.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment451(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot451] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment451.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance451($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularNull", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularNull = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance451, create_fragment451, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularNull",
      options,
      id: create_fragment451.name
    });
  }
};
var MdSignalCellularNull_default = MdSignalCellularNull;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularOff.svelte
var file452 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalCellularOff.svelte";
function create_default_slot452(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 1l-8.59 8.59L21 18.18V1zM4.77 4.5L3.5 5.77l6.36 6.36L1 21h17.73l2 2L22 21.73 4.77 4.5z");
      add_location(path, file452, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot452.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment452(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot452] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment452.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance452($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalCellularOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalCellularOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance452, create_fragment452, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalCellularOff",
      options,
      id: create_fragment452.name
    });
  }
};
var MdSignalCellularOff_default = MdSignalCellularOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi0Bar.svelte
var file453 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi0Bar.svelte";
function create_default_slot453(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01z");
      add_location(path, file453, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot453.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment453(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot453] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment453.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance453($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi0Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi0Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance453, create_fragment453, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi0Bar",
      options,
      id: create_fragment453.name
    });
  }
};
var MdSignalWifi0Bar_default = MdSignalWifi0Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi1Bar.svelte
var file454 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi1Bar.svelte";
function create_default_slot454(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01z");
      add_location(path0, file454, 4, 10, 151);
      attr_dev(path1, "d", "M6.67 14.86L12 21.49v.01l.01-.01 5.33-6.63C17.06 14.65 15.03 13 12 13s-5.06 1.65-5.33 1.86z");
      add_location(path1, file454, 5, 0, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot454.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment454(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot454] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment454.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance454($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi1Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi1Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance454, create_fragment454, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi1Bar",
      options,
      id: create_fragment454.name
    });
  }
};
var MdSignalWifi1Bar_default = MdSignalWifi1Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi1BarLock.svelte
var file455 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi1BarLock.svelte";
function create_default_slot455(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M23 16v-1.5c0-1.4-1.1-2.5-2.5-2.5S18 13.1 18 14.5V16c-.5 0-1 .5-1 1v4c0 .5.5 1 1 1h5c.5 0 1-.5 1-1v-4c0-.5-.5-1-1-1zm-1 0h-3v-1.5c0-.8.7-1.5 1.5-1.5s1.5.7 1.5 1.5V16z");
      add_location(path0, file455, 4, 10, 151);
      attr_dev(path1, "d", "M15.5 14.5c0-2.8 2.2-5 5-5 .4 0 .7 0 1 .1L23.6 7c-.4-.3-4.9-4-11.6-4C5.3 3 .8 6.7.4 7L12 21.5l3.5-4.3v-2.7z");
      add_location(path1, file455, 5, 0, 331);
      attr_dev(path2, "d", "M6.7 14.9l5.3 6.6 3.5-4.3v-2.6c0-.2 0-.5.1-.7-.9-.5-2.2-.9-3.6-.9-3 0-5.1 1.7-5.3 1.9z");
      add_location(path2, file455, 6, 0, 452);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot455.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment455(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot455] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment455.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance455($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi1BarLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi1BarLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance455, create_fragment455, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi1BarLock",
      options,
      id: create_fragment455.name
    });
  }
};
var MdSignalWifi1BarLock_default = MdSignalWifi1BarLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi2Bar.svelte
var file456 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi2Bar.svelte";
function create_default_slot456(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01z");
      add_location(path0, file456, 4, 10, 151);
      attr_dev(path1, "d", "M4.79 12.52l7.2 8.98H12l.01-.01 7.2-8.98C18.85 12.24 16.1 10 12 10s-6.85 2.24-7.21 2.52z");
      add_location(path1, file456, 5, 0, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot456.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment456(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot456] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment456.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance456($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi2Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi2Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance456, create_fragment456, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi2Bar",
      options,
      id: create_fragment456.name
    });
  }
};
var MdSignalWifi2Bar_default = MdSignalWifi2Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi2BarLock.svelte
var file457 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi2BarLock.svelte";
function create_default_slot457(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M23 16v-1.5c0-1.4-1.1-2.5-2.5-2.5S18 13.1 18 14.5V16c-.5 0-1 .5-1 1v4c0 .5.5 1 1 1h5c.5 0 1-.5 1-1v-4c0-.5-.5-1-1-1zm-1 0h-3v-1.5c0-.8.7-1.5 1.5-1.5s1.5.7 1.5 1.5V16z");
      add_location(path0, file457, 4, 10, 151);
      attr_dev(path1, "d", "M15.5 14.5c0-2.8 2.2-5 5-5 .4 0 .7 0 1 .1L23.6 7c-.4-.3-4.9-4-11.6-4C5.3 3 .8 6.7.4 7L12 21.5l3.5-4.3v-2.7z");
      add_location(path1, file457, 5, 0, 331);
      attr_dev(path2, "d", "M4.8 12.5l7.2 9 3.5-4.4v-2.6c0-1.3.5-2.5 1.4-3.4C15.6 10.5 14 10 12 10c-4.1 0-6.8 2.2-7.2 2.5z");
      add_location(path2, file457, 6, 0, 452);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot457.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment457(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot457] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment457.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance457($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi2BarLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi2BarLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance457, create_fragment457, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi2BarLock",
      options,
      id: create_fragment457.name
    });
  }
};
var MdSignalWifi2BarLock_default = MdSignalWifi2BarLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi3Bar.svelte
var file458 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi3Bar.svelte";
function create_default_slot458(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01z");
      add_location(path0, file458, 4, 10, 151);
      attr_dev(path1, "d", "M3.53 10.95l8.46 10.54.01.01.01-.01 8.46-10.54C20.04 10.62 16.81 8 12 8c-4.81 0-8.04 2.62-8.47 2.95z");
      add_location(path1, file458, 5, 0, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot458.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment458(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot458] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment458.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance458($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi3Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi3Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance458, create_fragment458, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi3Bar",
      options,
      id: create_fragment458.name
    });
  }
};
var MdSignalWifi3Bar_default = MdSignalWifi3Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi3BarLock.svelte
var file459 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi3BarLock.svelte";
function create_default_slot459(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 3C5.3 3 .8 6.7.4 7l3.2 3.9L12 21.5l3.5-4.3v-2.6c0-2.2 1.4-4 3.3-4.7.3-.1.5-.2.8-.2.3-.1.6-.1.9-.1.4 0 .7 0 1 .1L23.6 7c-.4-.3-4.9-4-11.6-4z");
      add_location(path0, file459, 4, 10, 151);
      attr_dev(path1, "d", "M23 16v-1.5c0-1.4-1.1-2.5-2.5-2.5S18 13.1 18 14.5V16c-.5 0-1 .5-1 1v4c0 .5.5 1 1 1h5c.5 0 1-.5 1-1v-4c0-.5-.5-1-1-1zm-1 0h-3v-1.5c0-.8.7-1.5 1.5-1.5s1.5.7 1.5 1.5V16zm-10 5.5l3.5-4.3v-2.6c0-2.2 1.4-4 3.3-4.7C17.3 9 14.9 8 12 8c-4.8 0-8 2.6-8.5 2.9");
      add_location(path1, file459, 5, 0, 308);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot459.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment459(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot459] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment459.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance459($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi3BarLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi3BarLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance459, create_fragment459, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi3BarLock",
      options,
      id: create_fragment459.name
    });
  }
};
var MdSignalWifi3BarLock_default = MdSignalWifi3BarLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi4Bar.svelte
var file460 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi4Bar.svelte";
function create_default_slot460(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01z");
      add_location(path, file460, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot460.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment460(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot460] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment460.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance460($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi4Bar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi4Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance460, create_fragment460, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi4Bar",
      options,
      id: create_fragment460.name
    });
  }
};
var MdSignalWifi4Bar_default = MdSignalWifi4Bar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi4BarLock.svelte
var file461 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifi4BarLock.svelte";
function create_default_slot461(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 16v-1.5c0-1.4-1.1-2.5-2.5-2.5S18 13.1 18 14.5V16c-.5 0-1 .5-1 1v4c0 .5.5 1 1 1h5c.5 0 1-.5 1-1v-4c0-.5-.5-1-1-1zm-1 0h-3v-1.5c0-.8.7-1.5 1.5-1.5s1.5.7 1.5 1.5V16zm-6.5-1.5c0-2.8 2.2-5 5-5 .4 0 .7 0 1 .1L23.6 7c-.4-.3-4.9-4-11.6-4C5.3 3 .8 6.7.4 7L12 21.5l3.5-4.4v-2.6z");
      add_location(path, file461, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot461.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment461(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot461] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment461.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance461($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifi4BarLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifi4BarLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance461, create_fragment461, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifi4BarLock",
      options,
      id: create_fragment461.name
    });
  }
};
var MdSignalWifi4BarLock_default = MdSignalWifi4BarLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifiOff.svelte
var file462 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSignalWifiOff.svelte";
function create_default_slot462(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23.64 7c-.45-.34-4.93-4-11.64-4-1.5 0-2.89.19-4.15.48L18.18 13.8 23.64 7zm-6.6 8.22L3.27 1.44 2 2.72l2.05 2.06C1.91 5.76.59 6.82.36 7l11.63 14.49.01.01.01-.01 3.9-4.86 3.32 3.32 1.27-1.27-3.46-3.46z");
      add_location(path, file462, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot462.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment462(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot462] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment462.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance462($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSignalWifiOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSignalWifiOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance462, create_fragment462, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSignalWifiOff",
      options,
      id: create_fragment462.name
    });
  }
};
var MdSignalWifiOff_default = MdSignalWifiOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStorage.svelte
var file463 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStorage.svelte";
function create_default_slot463(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 20h20v-4H2v4zm2-3h2v2H4v-2zM2 4v4h20V4H2zm4 3H4V5h2v2zm-4 7h20v-4H2v4zm2-3h2v2H4v-2z");
      add_location(path, file463, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot463.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment463(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot463] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment463.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance463($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStorage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStorage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance463, create_fragment463, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStorage",
      options,
      id: create_fragment463.name
    });
  }
};
var MdStorage_default = MdStorage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUsb.svelte
var file464 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUsb.svelte";
function create_default_slot464(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 7v4h1v2h-3V5h2l-3-4-3 4h2v8H8v-2.07c.7-.37 1.2-1.08 1.2-1.93 0-1.21-.99-2.2-2.2-2.2-1.21 0-2.2.99-2.2 2.2 0 .85.5 1.56 1.2 1.93V13c0 1.11.89 2 2 2h3v3.05c-.71.37-1.2 1.1-1.2 1.95 0 1.22.99 2.2 2.2 2.2 1.21 0 2.2-.98 2.2-2.2 0-.85-.49-1.58-1.2-1.95V15h3c1.11 0 2-.89 2-2v-2h1V7h-4z");
      add_location(path, file464, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot464.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment464(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot464] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment464.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance464($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdUsb", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdUsb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance464, create_fragment464, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdUsb",
      options,
      id: create_fragment464.name
    });
  }
};
var MdUsb_default = MdUsb;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWallpaper.svelte
var file465 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWallpaper.svelte";
function create_default_slot465(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 4h7V2H4c-1.1 0-2 .9-2 2v7h2V4zm6 9l-4 5h12l-3-4-2.03 2.71L10 13zm7-4.5c0-.83-.67-1.5-1.5-1.5S14 7.67 14 8.5s.67 1.5 1.5 1.5S17 9.33 17 8.5zM20 2h-7v2h7v7h2V4c0-1.1-.9-2-2-2zm0 18h-7v2h7c1.1 0 2-.9 2-2v-7h-2v7zM4 13H2v7c0 1.1.9 2 2 2h7v-2H4v-7z");
      add_location(path, file465, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot465.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment465(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot465] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment465.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance465($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWallpaper", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWallpaper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance465, create_fragment465, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWallpaper",
      options,
      id: create_fragment465.name
    });
  }
};
var MdWallpaper_default = MdWallpaper;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWidgets.svelte
var file466 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWidgets.svelte";
function create_default_slot466(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 13v8h8v-8h-8zM3 21h8v-8H3v8zM3 3v8h8V3H3zm13.66-1.31L11 7.34 16.66 13l5.66-5.66-5.66-5.65z");
      add_location(path, file466, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot466.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment466(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot466] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment466.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance466($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWidgets", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWidgets = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance466, create_fragment466, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWidgets",
      options,
      id: create_fragment466.name
    });
  }
};
var MdWidgets_default = MdWidgets;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWifiLock.svelte
var file467 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWifiLock.svelte";
function create_default_slot467(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.5 9.5c.28 0 .55.04.81.08L24 6c-3.34-2.51-7.5-4-12-4S3.34 3.49 0 6l12 16 3.5-4.67V14.5c0-2.76 2.24-5 5-5zM23 16v-1.5c0-1.38-1.12-2.5-2.5-2.5S18 13.12 18 14.5V16c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1zm-1 0h-3v-1.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V16z");
      add_location(path, file467, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot467.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment467(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot467] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment467.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance467($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWifiLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWifiLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance467, create_fragment467, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWifiLock",
      options,
      id: create_fragment467.name
    });
  }
};
var MdWifiLock_default = MdWifiLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWifiTethering.svelte
var file468 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWifiTethering.svelte";
function create_default_slot468(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 2c0-3.31-2.69-6-6-6s-6 2.69-6 6c0 2.22 1.21 4.15 3 5.19l1-1.74c-1.19-.7-2-1.97-2-3.45 0-2.21 1.79-4 4-4s4 1.79 4 4c0 1.48-.81 2.75-2 3.45l1 1.74c1.79-1.04 3-2.97 3-5.19zM12 3C6.48 3 2 7.48 2 13c0 3.7 2.01 6.92 4.99 8.65l1-1.73C5.61 18.53 4 15.96 4 13c0-4.42 3.58-8 8-8s8 3.58 8 8c0 2.96-1.61 5.53-4 6.92l1 1.73c2.99-1.73 5-4.95 5-8.65 0-5.52-4.48-10-10-10z");
      add_location(path, file468, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot468.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment468(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot468] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment468.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance468($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWifiTethering", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWifiTethering = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance468, create_fragment468, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWifiTethering",
      options,
      id: create_fragment468.name
    });
  }
};
var MdWifiTethering_default = MdWifiTethering;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAttachFile.svelte
var file469 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAttachFile.svelte";
function create_default_slot469(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z");
      add_location(path, file469, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot469.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment469(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot469] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment469.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance469($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAttachFile", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAttachFile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance469, create_fragment469, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAttachFile",
      options,
      id: create_fragment469.name
    });
  }
};
var MdAttachFile_default = MdAttachFile;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAttachMoney.svelte
var file470 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAttachMoney.svelte";
function create_default_slot470(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z");
      add_location(path, file470, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot470.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment470(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot470] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment470.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance470($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAttachMoney", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAttachMoney = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance470, create_fragment470, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAttachMoney",
      options,
      id: create_fragment470.name
    });
  }
};
var MdAttachMoney_default = MdAttachMoney;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderAll.svelte
var file471 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderAll.svelte";
function create_default_slot471(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z");
      add_location(path, file471, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot471.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment471(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot471] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment471.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance471($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderAll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderAll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance471, create_fragment471, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderAll",
      options,
      id: create_fragment471.name
    });
  }
};
var MdBorderAll_default = MdBorderAll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderBottom.svelte
var file472 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderBottom.svelte";
function create_default_slot472(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 11H7v2h2v-2zm4 4h-2v2h2v-2zM9 3H7v2h2V3zm4 8h-2v2h2v-2zM5 3H3v2h2V3zm8 4h-2v2h2V7zm4 4h-2v2h2v-2zm-4-8h-2v2h2V3zm4 0h-2v2h2V3zm2 10h2v-2h-2v2zm0 4h2v-2h-2v2zM5 7H3v2h2V7zm14-4v2h2V3h-2zm0 6h2V7h-2v2zM5 11H3v2h2v-2zM3 21h18v-2H3v2zm2-6H3v2h2v-2z");
      add_location(path, file472, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot472.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment472(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot472] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment472.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance472($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderBottom", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderBottom = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance472, create_fragment472, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderBottom",
      options,
      id: create_fragment472.name
    });
  }
};
var MdBorderBottom_default = MdBorderBottom;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderClear.svelte
var file473 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderClear.svelte";
function create_default_slot473(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 5h2V3H7v2zm0 8h2v-2H7v2zm0 8h2v-2H7v2zm4-4h2v-2h-2v2zm0 4h2v-2h-2v2zm-8 0h2v-2H3v2zm0-4h2v-2H3v2zm0-4h2v-2H3v2zm0-4h2V7H3v2zm0-4h2V3H3v2zm8 8h2v-2h-2v2zm8 4h2v-2h-2v2zm0-4h2v-2h-2v2zm0 8h2v-2h-2v2zm0-12h2V7h-2v2zm-8 0h2V7h-2v2zm8-6v2h2V3h-2zm-8 2h2V3h-2v2zm4 16h2v-2h-2v2zm0-8h2v-2h-2v2zm0-8h2V3h-2v2z");
      add_location(path, file473, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot473.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment473(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot473] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment473.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance473($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderClear", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderClear = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance473, create_fragment473, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderClear",
      options,
      id: create_fragment473.name
    });
  }
};
var MdBorderClear_default = MdBorderClear;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderColor.svelte
var file474 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderColor.svelte";
function create_default_slot474(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17.75 7L14 3.25l-10 10V17h3.75l10-10zm2.96-2.96c.39-.39.39-1.02 0-1.41L18.37.29c-.39-.39-1.02-.39-1.41 0L15 2.25 18.75 6l1.96-1.96z");
      add_location(path0, file474, 4, 10, 151);
      attr_dev(path1, "d", "M0 20h24v4H0z");
      add_location(path1, file474, 5, 0, 297);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot474.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment474(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot474] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment474.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance474($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderColor", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderColor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance474, create_fragment474, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderColor",
      options,
      id: create_fragment474.name
    });
  }
};
var MdBorderColor_default = MdBorderColor;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderHorizontal.svelte
var file475 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderHorizontal.svelte";
function create_default_slot475(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 21h2v-2H3v2zM5 7H3v2h2V7zM3 17h2v-2H3v2zm4 4h2v-2H7v2zM5 3H3v2h2V3zm4 0H7v2h2V3zm8 0h-2v2h2V3zm-4 4h-2v2h2V7zm0-4h-2v2h2V3zm6 14h2v-2h-2v2zm-8 4h2v-2h-2v2zm-8-8h18v-2H3v2zM19 3v2h2V3h-2zm0 6h2V7h-2v2zm-8 8h2v-2h-2v2zm4 4h2v-2h-2v2zm4 0h2v-2h-2v2z");
      add_location(path, file475, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot475.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment475(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot475] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment475.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance475($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderHorizontal", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderHorizontal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance475, create_fragment475, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderHorizontal",
      options,
      id: create_fragment475.name
    });
  }
};
var MdBorderHorizontal_default = MdBorderHorizontal;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderInner.svelte
var file476 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderInner.svelte";
function create_default_slot476(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 21h2v-2H3v2zm4 0h2v-2H7v2zM5 7H3v2h2V7zM3 17h2v-2H3v2zM9 3H7v2h2V3zM5 3H3v2h2V3zm12 0h-2v2h2V3zm2 6h2V7h-2v2zm0-6v2h2V3h-2zm-4 18h2v-2h-2v2zM13 3h-2v8H3v2h8v8h2v-8h8v-2h-8V3zm6 18h2v-2h-2v2zm0-4h2v-2h-2v2z");
      add_location(path, file476, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot476.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment476(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot476] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment476.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance476($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderInner", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderInner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance476, create_fragment476, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderInner",
      options,
      id: create_fragment476.name
    });
  }
};
var MdBorderInner_default = MdBorderInner;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderLeft.svelte
var file477 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderLeft.svelte";
function create_default_slot477(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 21h2v-2h-2v2zm0-4h2v-2h-2v2zm0-12h2V3h-2v2zm0 4h2V7h-2v2zm0 4h2v-2h-2v2zm-4 8h2v-2H7v2zM7 5h2V3H7v2zm0 8h2v-2H7v2zm-4 8h2V3H3v18zM19 9h2V7h-2v2zm-4 12h2v-2h-2v2zm4-4h2v-2h-2v2zm0-14v2h2V3h-2zm0 10h2v-2h-2v2zm0 8h2v-2h-2v2zm-4-8h2v-2h-2v2zm0-8h2V3h-2v2z");
      add_location(path, file477, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot477.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment477(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot477] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment477.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance477($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderLeft", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance477, create_fragment477, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderLeft",
      options,
      id: create_fragment477.name
    });
  }
};
var MdBorderLeft_default = MdBorderLeft;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderOuter.svelte
var file478 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderOuter.svelte";
function create_default_slot478(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 7h-2v2h2V7zm0 4h-2v2h2v-2zm4 0h-2v2h2v-2zM3 3v18h18V3H3zm16 16H5V5h14v14zm-6-4h-2v2h2v-2zm-4-4H7v2h2v-2z");
      add_location(path, file478, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot478.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment478(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot478] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment478.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance478($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderOuter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderOuter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance478, create_fragment478, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderOuter",
      options,
      id: create_fragment478.name
    });
  }
};
var MdBorderOuter_default = MdBorderOuter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderRight.svelte
var file479 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderRight.svelte";
function create_default_slot479(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 21h2v-2H7v2zM3 5h2V3H3v2zm4 0h2V3H7v2zm0 8h2v-2H7v2zm-4 8h2v-2H3v2zm8 0h2v-2h-2v2zm-8-8h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm8 8h2v-2h-2v2zm4-4h2v-2h-2v2zm4-10v18h2V3h-2zm-4 18h2v-2h-2v2zm0-16h2V3h-2v2zm-4 8h2v-2h-2v2zm0-8h2V3h-2v2zm0 4h2V7h-2v2z");
      add_location(path, file479, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot479.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment479(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot479] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment479.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance479($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderRight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance479, create_fragment479, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderRight",
      options,
      id: create_fragment479.name
    });
  }
};
var MdBorderRight_default = MdBorderRight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderStyle.svelte
var file480 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderStyle.svelte";
function create_default_slot480(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 21h2v-2h-2v2zm4 0h2v-2h-2v2zM7 21h2v-2H7v2zm4 0h2v-2h-2v2zm8-4h2v-2h-2v2zm0-4h2v-2h-2v2zM3 3v18h2V5h16V3H3zm16 6h2V7h-2v2z");
      add_location(path, file480, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot480.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment480(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot480] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment480.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance480($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderStyle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderStyle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance480, create_fragment480, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderStyle",
      options,
      id: create_fragment480.name
    });
  }
};
var MdBorderStyle_default = MdBorderStyle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderTop.svelte
var file481 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderTop.svelte";
function create_default_slot481(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 21h2v-2H7v2zm0-8h2v-2H7v2zm4 0h2v-2h-2v2zm0 8h2v-2h-2v2zm-8-4h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2v-2H3v2zm0-4h2V7H3v2zm8 8h2v-2h-2v2zm8-8h2V7h-2v2zm0 4h2v-2h-2v2zM3 3v2h18V3H3zm16 14h2v-2h-2v2zm-4 4h2v-2h-2v2zM11 9h2V7h-2v2zm8 12h2v-2h-2v2zm-4-8h2v-2h-2v2z");
      add_location(path, file481, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot481.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment481(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot481] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment481.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance481($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderTop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderTop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance481, create_fragment481, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderTop",
      options,
      id: create_fragment481.name
    });
  }
};
var MdBorderTop_default = MdBorderTop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderVertical.svelte
var file482 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBorderVertical.svelte";
function create_default_slot482(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9h2V7H3v2zm0-4h2V3H3v2zm4 16h2v-2H7v2zm0-8h2v-2H7v2zm-4 0h2v-2H3v2zm0 8h2v-2H3v2zm0-4h2v-2H3v2zM7 5h2V3H7v2zm12 12h2v-2h-2v2zm-8 4h2V3h-2v18zm8 0h2v-2h-2v2zm0-8h2v-2h-2v2zm0-10v2h2V3h-2zm0 6h2V7h-2v2zm-4-4h2V3h-2v2zm0 16h2v-2h-2v2zm0-8h2v-2h-2v2z");
      add_location(path, file482, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot482.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment482(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot482] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment482.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance482($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBorderVertical", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBorderVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance482, create_fragment482, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBorderVertical",
      options,
      id: create_fragment482.name
    });
  }
};
var MdBorderVertical_default = MdBorderVertical;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBubbleChart.svelte
var file483 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBubbleChart.svelte";
function create_default_slot483(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file483, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file483, 5, 0, 174);
      attr_dev(path2, "d", "undefined");
      add_location(path2, file483, 6, 0, 197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot483.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment483(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot483] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment483.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance483($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBubbleChart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBubbleChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance483, create_fragment483, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBubbleChart",
      options,
      id: create_fragment483.name
    });
  }
};
var MdBubbleChart_default = MdBubbleChart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDragHandle.svelte
var file484 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDragHandle.svelte";
function create_default_slot484(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 9H4v2h16V9zM4 15h16v-2H4v2z");
      add_location(path, file484, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot484.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment484(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot484] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment484.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance484($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDragHandle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDragHandle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance484, create_fragment484, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDragHandle",
      options,
      id: create_fragment484.name
    });
  }
};
var MdDragHandle_default = MdDragHandle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignCenter.svelte
var file485 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignCenter.svelte";
function create_default_slot485(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z");
      add_location(path, file485, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot485.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment485(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot485] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment485.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance485($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatAlignCenter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatAlignCenter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance485, create_fragment485, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatAlignCenter",
      options,
      id: create_fragment485.name
    });
  }
};
var MdFormatAlignCenter_default = MdFormatAlignCenter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignJustify.svelte
var file486 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignJustify.svelte";
function create_default_slot486(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z");
      add_location(path, file486, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot486.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment486(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot486] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment486.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance486($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatAlignJustify", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatAlignJustify = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance486, create_fragment486, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatAlignJustify",
      options,
      id: create_fragment486.name
    });
  }
};
var MdFormatAlignJustify_default = MdFormatAlignJustify;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignLeft.svelte
var file487 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignLeft.svelte";
function create_default_slot487(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z");
      add_location(path, file487, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot487.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment487(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot487] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment487.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance487($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatAlignLeft", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatAlignLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance487, create_fragment487, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatAlignLeft",
      options,
      id: create_fragment487.name
    });
  }
};
var MdFormatAlignLeft_default = MdFormatAlignLeft;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignRight.svelte
var file488 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatAlignRight.svelte";
function create_default_slot488(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z");
      add_location(path, file488, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot488.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment488(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot488] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment488.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance488($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatAlignRight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatAlignRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance488, create_fragment488, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatAlignRight",
      options,
      id: create_fragment488.name
    });
  }
};
var MdFormatAlignRight_default = MdFormatAlignRight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatBold.svelte
var file489 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatBold.svelte";
function create_default_slot489(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z");
      add_location(path, file489, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot489.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment489(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot489] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment489.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance489($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatBold", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatBold = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance489, create_fragment489, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatBold",
      options,
      id: create_fragment489.name
    });
  }
};
var MdFormatBold_default = MdFormatBold;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatClear.svelte
var file490 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatClear.svelte";
function create_default_slot490(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.27 5L2 6.27l6.97 6.97L6.5 19h3l1.57-3.66L16.73 21 18 19.73 3.55 5.27 3.27 5zM6 5v.18L8.82 8h2.4l-.72 1.68 2.1 2.1L14.21 8H20V5H6z");
      add_location(path, file490, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot490.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment490(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot490] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment490.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance490($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatClear", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatClear = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance490, create_fragment490, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatClear",
      options,
      id: create_fragment490.name
    });
  }
};
var MdFormatClear_default = MdFormatClear;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatColorFill.svelte
var file491 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatColorFill.svelte";
function create_default_slot491(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M16.56 8.94L7.62 0 6.21 1.41l2.38 2.38-5.15 5.15c-.59.59-.59 1.54 0 2.12l5.5 5.5c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12zM5.21 10L10 5.21 14.79 10H5.21zM19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5z");
      add_location(path0, file491, 4, 10, 151);
      attr_dev(path1, "d", "M0 20h24v4H0z");
      add_location(path1, file491, 5, 0, 411);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot491.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment491(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot491] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment491.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance491($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatColorFill", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatColorFill = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance491, create_fragment491, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatColorFill",
      options,
      id: create_fragment491.name
    });
  }
};
var MdFormatColorFill_default = MdFormatColorFill;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatColorReset.svelte
var file492 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatColorReset.svelte";
function create_default_slot492(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 14c0-4-6-10.8-6-10.8s-1.33 1.51-2.73 3.52l8.59 8.59c.09-.42.14-.86.14-1.31zm-.88 3.12L12.5 12.5 5.27 5.27 4 6.55l3.32 3.32C6.55 11.32 6 12.79 6 14c0 3.31 2.69 6 6 6 1.52 0 2.9-.57 3.96-1.5l2.63 2.63 1.27-1.27-2.74-2.74z");
      add_location(path, file492, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot492.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment492(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot492] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment492.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance492($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatColorReset", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatColorReset = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance492, create_fragment492, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatColorReset",
      options,
      id: create_fragment492.name
    });
  }
};
var MdFormatColorReset_default = MdFormatColorReset;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatColorText.svelte
var file493 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatColorText.svelte";
function create_default_slot493(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M0 20h24v4H0z");
      add_location(path0, file493, 4, 10, 151);
      attr_dev(path1, "d", "M11 3L5.5 17h2.25l1.12-3h6.25l1.12 3h2.25L13 3h-2zm-1.38 9L12 5.67 14.38 12H9.62z");
      add_location(path1, file493, 5, 0, 178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot493.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment493(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot493] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment493.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance493($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatColorText", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatColorText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance493, create_fragment493, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatColorText",
      options,
      id: create_fragment493.name
    });
  }
};
var MdFormatColorText_default = MdFormatColorText;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatIndentDecrease.svelte
var file494 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatIndentDecrease.svelte";
function create_default_slot494(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 17h10v-2H11v2zm-8-5l4 4V8l-4 4zm0 9h18v-2H3v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z");
      add_location(path, file494, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot494.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment494(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot494] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment494.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance494($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatIndentDecrease", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatIndentDecrease = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance494, create_fragment494, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatIndentDecrease",
      options,
      id: create_fragment494.name
    });
  }
};
var MdFormatIndentDecrease_default = MdFormatIndentDecrease;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatIndentIncrease.svelte
var file495 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatIndentIncrease.svelte";
function create_default_slot495(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 21h18v-2H3v2zM3 8v8l4-4-4-4zm8 9h10v-2H11v2zM3 3v2h18V3H3zm8 6h10V7H11v2zm0 4h10v-2H11v2z");
      add_location(path, file495, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot495.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment495(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot495] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment495.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance495($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatIndentIncrease", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatIndentIncrease = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance495, create_fragment495, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatIndentIncrease",
      options,
      id: create_fragment495.name
    });
  }
};
var MdFormatIndentIncrease_default = MdFormatIndentIncrease;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatItalic.svelte
var file496 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatItalic.svelte";
function create_default_slot496(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z");
      add_location(path, file496, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot496.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment496(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot496] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment496.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance496($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatItalic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatItalic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance496, create_fragment496, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatItalic",
      options,
      id: create_fragment496.name
    });
  }
};
var MdFormatItalic_default = MdFormatItalic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatLineSpacing.svelte
var file497 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatLineSpacing.svelte";
function create_default_slot497(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 7h2.5L5 3.5 1.5 7H4v10H1.5L5 20.5 8.5 17H6V7zm4-2v2h12V5H10zm0 14h12v-2H10v2zm0-6h12v-2H10v2z");
      add_location(path, file497, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot497.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment497(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot497] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment497.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance497($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatLineSpacing", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatLineSpacing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance497, create_fragment497, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatLineSpacing",
      options,
      id: create_fragment497.name
    });
  }
};
var MdFormatLineSpacing_default = MdFormatLineSpacing;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatListBulleted.svelte
var file498 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatListBulleted.svelte";
function create_default_slot498(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z");
      add_location(path, file498, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot498.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment498(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot498] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment498.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance498($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatListBulleted", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatListBulleted = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance498, create_fragment498, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatListBulleted",
      options,
      id: create_fragment498.name
    });
  }
};
var MdFormatListBulleted_default = MdFormatListBulleted;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatListNumbered.svelte
var file499 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatListNumbered.svelte";
function create_default_slot499(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z");
      add_location(path, file499, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot499.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment499(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot499] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment499.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance499($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatListNumbered", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatListNumbered = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance499, create_fragment499, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatListNumbered",
      options,
      id: create_fragment499.name
    });
  }
};
var MdFormatListNumbered_default = MdFormatListNumbered;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatPaint.svelte
var file500 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatPaint.svelte";
function create_default_slot500(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4V3c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6h1v4H9v11c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-9h8V4h-3z");
      add_location(path, file500, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot500.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment500(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot500] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment500.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance500($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatPaint", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatPaint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance500, create_fragment500, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatPaint",
      options,
      id: create_fragment500.name
    });
  }
};
var MdFormatPaint_default = MdFormatPaint;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatQuote.svelte
var file501 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatQuote.svelte";
function create_default_slot501(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z");
      add_location(path, file501, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot501.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment501(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot501] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment501.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance501($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatQuote", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatQuote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance501, create_fragment501, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatQuote",
      options,
      id: create_fragment501.name
    });
  }
};
var MdFormatQuote_default = MdFormatQuote;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatShapes.svelte
var file502 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatShapes.svelte";
function create_default_slot502(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 7V1h-6v2H7V1H1v6h2v10H1v6h6v-2h10v2h6v-6h-2V7h2zM3 3h2v2H3V3zm2 18H3v-2h2v2zm12-2H7v-2H5V7h2V5h10v2h2v10h-2v2zm4 2h-2v-2h2v2zM19 5V3h2v2h-2zm-5.27 9h-3.49l-.73 2H7.89l3.4-9h1.4l3.41 9h-1.63l-.74-2zm-3.04-1.26h2.61L12 8.91l-1.31 3.83z");
      add_location(path, file502, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot502.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment502(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot502] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment502.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance502($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatShapes", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatShapes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance502, create_fragment502, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatShapes",
      options,
      id: create_fragment502.name
    });
  }
};
var MdFormatShapes_default = MdFormatShapes;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatSize.svelte
var file503 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatSize.svelte";
function create_default_slot503(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z");
      add_location(path, file503, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot503.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment503(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot503] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment503.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance503($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatSize", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatSize = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance503, create_fragment503, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatSize",
      options,
      id: create_fragment503.name
    });
  }
};
var MdFormatSize_default = MdFormatSize;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatStrikethrough.svelte
var file504 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatStrikethrough.svelte";
function create_default_slot504(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 19h4v-3h-4v3zM5 4v3h5v3h4V7h5V4H5zM3 14h18v-2H3v2z");
      add_location(path, file504, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot504.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment504(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot504] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment504.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance504($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatStrikethrough", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatStrikethrough = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance504, create_fragment504, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatStrikethrough",
      options,
      id: create_fragment504.name
    });
  }
};
var MdFormatStrikethrough_default = MdFormatStrikethrough;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatTextdirectionLToR.svelte
var file505 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatTextdirectionLToR.svelte";
function create_default_slot505(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 10v5h2V4h2v11h2V4h2V2H9C6.79 2 5 3.79 5 6s1.79 4 4 4zm12 8l-4-4v3H5v2h12v3l4-4z");
      add_location(path, file505, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot505.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment505(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot505] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment505.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance505($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatTextdirectionLToR", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatTextdirectionLToR = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance505, create_fragment505, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatTextdirectionLToR",
      options,
      id: create_fragment505.name
    });
  }
};
var MdFormatTextdirectionLToR_default = MdFormatTextdirectionLToR;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatTextdirectionRToL.svelte
var file506 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatTextdirectionRToL.svelte";
function create_default_slot506(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 10v5h2V4h2v11h2V4h2V2h-8C7.79 2 6 3.79 6 6s1.79 4 4 4zm-2 7v-3l-4 4 4 4v-3h12v-2H8z");
      add_location(path, file506, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot506.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment506(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot506] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment506.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance506($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatTextdirectionRToL", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatTextdirectionRToL = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance506, create_fragment506, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatTextdirectionRToL",
      options,
      id: create_fragment506.name
    });
  }
};
var MdFormatTextdirectionRToL_default = MdFormatTextdirectionRToL;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatUnderlined.svelte
var file507 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFormatUnderlined.svelte";
function create_default_slot507(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z");
      add_location(path, file507, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot507.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment507(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot507] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment507.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance507($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFormatUnderlined", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFormatUnderlined = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance507, create_fragment507, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFormatUnderlined",
      options,
      id: create_fragment507.name
    });
  }
};
var MdFormatUnderlined_default = MdFormatUnderlined;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFunctions.svelte
var file508 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFunctions.svelte";
function create_default_slot508(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4H6v2l6.5 6L6 18v2h12v-3h-7l5-5-5-5h7z");
      add_location(path, file508, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot508.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment508(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot508] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment508.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance508($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFunctions", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFunctions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance508, create_fragment508, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFunctions",
      options,
      id: create_fragment508.name
    });
  }
};
var MdFunctions_default = MdFunctions;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHighlight.svelte
var file509 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHighlight.svelte";
function create_default_slot509(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 14l3 3v5h6v-5l3-3V9H6zm5-12h2v3h-2zM3.5 5.875L4.914 4.46l2.12 2.122L5.62 7.997zm13.46.71l2.123-2.12 1.414 1.414L18.375 8z");
      add_location(path, file509, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot509.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment509(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot509] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment509.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance509($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHighlight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHighlight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance509, create_fragment509, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHighlight",
      options,
      id: create_fragment509.name
    });
  }
};
var MdHighlight_default = MdHighlight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertChart.svelte
var file510 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertChart.svelte";
function create_default_slot510(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z");
      add_location(path, file510, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot510.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment510(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot510] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment510.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance510($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertChart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance510, create_fragment510, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertChart",
      options,
      id: create_fragment510.name
    });
  }
};
var MdInsertChart_default = MdInsertChart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertComment.svelte
var file511 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertComment.svelte";
function create_default_slot511(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z");
      add_location(path, file511, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot511.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment511(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot511] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment511.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance511($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertComment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertComment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance511, create_fragment511, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertComment",
      options,
      id: create_fragment511.name
    });
  }
};
var MdInsertComment_default = MdInsertComment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertDriveFile.svelte
var file512 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertDriveFile.svelte";
function create_default_slot512(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z");
      add_location(path, file512, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot512.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment512(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot512] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment512.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance512($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertDriveFile", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertDriveFile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance512, create_fragment512, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertDriveFile",
      options,
      id: create_fragment512.name
    });
  }
};
var MdInsertDriveFile_default = MdInsertDriveFile;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertEmoticon.svelte
var file513 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertEmoticon.svelte";
function create_default_slot513(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z");
      add_location(path, file513, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot513.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment513(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot513] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment513.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance513($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertEmoticon", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertEmoticon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance513, create_fragment513, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertEmoticon",
      options,
      id: create_fragment513.name
    });
  }
};
var MdInsertEmoticon_default = MdInsertEmoticon;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertInvitation.svelte
var file514 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertInvitation.svelte";
function create_default_slot514(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z");
      add_location(path, file514, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot514.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment514(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot514] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment514.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance514($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertInvitation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertInvitation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance514, create_fragment514, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertInvitation",
      options,
      id: create_fragment514.name
    });
  }
};
var MdInsertInvitation_default = MdInsertInvitation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertLink.svelte
var file515 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertLink.svelte";
function create_default_slot515(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z");
      add_location(path, file515, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot515.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment515(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot515] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment515.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance515($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertLink", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance515, create_fragment515, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertLink",
      options,
      id: create_fragment515.name
    });
  }
};
var MdInsertLink_default = MdInsertLink;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertPhoto.svelte
var file516 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdInsertPhoto.svelte";
function create_default_slot516(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z");
      add_location(path, file516, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot516.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment516(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot516] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment516.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance516($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdInsertPhoto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdInsertPhoto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance516, create_fragment516, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdInsertPhoto",
      options,
      id: create_fragment516.name
    });
  }
};
var MdInsertPhoto_default = MdInsertPhoto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLinearScale.svelte
var file517 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLinearScale.svelte";
function create_default_slot517(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.5 9.5c-1.03 0-1.9.62-2.29 1.5h-2.92c-.39-.88-1.26-1.5-2.29-1.5s-1.9.62-2.29 1.5H6.79c-.39-.88-1.26-1.5-2.29-1.5C3.12 9.5 2 10.62 2 12s1.12 2.5 2.5 2.5c1.03 0 1.9-.62 2.29-1.5h2.92c.39.88 1.26 1.5 2.29 1.5s1.9-.62 2.29-1.5h2.92c.39.88 1.26 1.5 2.29 1.5 1.38 0 2.5-1.12 2.5-2.5s-1.12-2.5-2.5-2.5z");
      add_location(path, file517, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot517.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment517(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot517] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment517.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance517($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLinearScale", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLinearScale = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance517, create_fragment517, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLinearScale",
      options,
      id: create_fragment517.name
    });
  }
};
var MdLinearScale_default = MdLinearScale;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMergeType.svelte
var file518 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMergeType.svelte";
function create_default_slot518(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 20.41L18.41 19 15 15.59 13.59 17 17 20.41zM7.5 8H11v5.59L5.59 19 7 20.41l6-6V8h3.5L12 3.5 7.5 8z");
      add_location(path, file518, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot518.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment518(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot518] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment518.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance518($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMergeType", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMergeType = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance518, create_fragment518, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMergeType",
      options,
      id: create_fragment518.name
    });
  }
};
var MdMergeType_default = MdMergeType;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdModeComment.svelte
var file519 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdModeComment.svelte";
function create_default_slot519(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z");
      add_location(path, file519, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot519.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment519(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot519] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment519.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance519($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdModeComment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdModeComment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance519, create_fragment519, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdModeComment",
      options,
      id: create_fragment519.name
    });
  }
};
var MdModeComment_default = MdModeComment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdModeEdit.svelte
var file520 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdModeEdit.svelte";
function create_default_slot520(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z");
      add_location(path, file520, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot520.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment520(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot520] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment520.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance520($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdModeEdit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdModeEdit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance520, create_fragment520, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdModeEdit",
      options,
      id: create_fragment520.name
    });
  }
};
var MdModeEdit_default = MdModeEdit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMonetizationOn.svelte
var file521 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMonetizationOn.svelte";
function create_default_slot521(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16z");
      add_location(path, file521, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot521.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment521(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot521] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment521.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance521($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMonetizationOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMonetizationOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance521, create_fragment521, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMonetizationOn",
      options,
      id: create_fragment521.name
    });
  }
};
var MdMonetizationOn_default = MdMonetizationOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoneyOff.svelte
var file522 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoneyOff.svelte";
function create_default_slot522(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12.5 6.9c1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-.53.12-1.03.3-1.48.54l1.47 1.47c.41-.17.91-.27 1.51-.27zM5.33 4.06L4.06 5.33 7.5 8.77c0 2.08 1.56 3.21 3.91 3.91l3.51 3.51c-.34.48-1.05.91-2.42.91-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c.96-.18 1.82-.55 2.45-1.12l2.22 2.22 1.27-1.27L5.33 4.06z");
      add_location(path, file522, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot522.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment522(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot522] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment522.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance522($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMoneyOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMoneyOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance522, create_fragment522, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMoneyOff",
      options,
      id: create_fragment522.name
    });
  }
};
var MdMoneyOff_default = MdMoneyOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMultilineChart.svelte
var file523 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMultilineChart.svelte";
function create_default_slot523(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 6.92l-1.41-1.41-2.85 3.21C15.68 6.4 12.83 5 9.61 5 6.72 5 4.07 6.16 2 8l1.42 1.42C5.12 7.93 7.27 7 9.61 7c2.74 0 5.09 1.26 6.77 3.24l-2.88 3.24-4-4L2 16.99l1.5 1.5 6-6.01 4 4 4.05-4.55c.75 1.35 1.25 2.9 1.44 4.55H21c-.22-2.3-.95-4.39-2.04-6.14L22 6.92z");
      add_location(path, file523, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot523.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment523(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot523] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment523.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance523($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMultilineChart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMultilineChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance523, create_fragment523, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMultilineChart",
      options,
      id: create_fragment523.name
    });
  }
};
var MdMultilineChart_default = MdMultilineChart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPieChart.svelte
var file524 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPieChart.svelte";
function create_default_slot524(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 2v20c-5.07-.5-9-4.79-9-10s3.93-9.5 9-10zm2.03 0v8.99H22c-.47-4.74-4.24-8.52-8.97-8.99zm0 11.01V22c4.74-.47 8.5-4.25 8.97-8.99h-8.97z");
      add_location(path, file524, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot524.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment524(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot524] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment524.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance524($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPieChart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPieChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance524, create_fragment524, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPieChart",
      options,
      id: create_fragment524.name
    });
  }
};
var MdPieChart_default = MdPieChart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPieChartOutlined.svelte
var file525 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPieChartOutlined.svelte";
function create_default_slot525(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm1 2.07c3.61.45 6.48 3.33 6.93 6.93H13V4.07zM4 12c0-4.06 3.07-7.44 7-7.93v15.87c-3.93-.5-7-3.88-7-7.94zm9 7.93V13h6.93c-.45 3.61-3.32 6.48-6.93 6.93z");
      add_location(path, file525, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot525.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment525(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot525] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment525.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance525($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPieChartOutlined", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPieChartOutlined = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance525, create_fragment525, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPieChartOutlined",
      options,
      id: create_fragment525.name
    });
  }
};
var MdPieChartOutlined_default = MdPieChartOutlined;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPublish.svelte
var file526 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPublish.svelte";
function create_default_slot526(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 4v2h14V4H5zm0 10h4v6h6v-6h4l-7-7-7 7z");
      add_location(path, file526, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot526.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment526(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot526] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment526.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance526($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPublish", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPublish = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance526, create_fragment526, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPublish",
      options,
      id: create_fragment526.name
    });
  }
};
var MdPublish_default = MdPublish;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShortText.svelte
var file527 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShortText.svelte";
function create_default_slot527(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 9h16v2H4zm0 4h10v2H4z");
      add_location(path, file527, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot527.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment527(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot527] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment527.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance527($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShortText", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShortText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance527, create_fragment527, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShortText",
      options,
      id: create_fragment527.name
    });
  }
};
var MdShortText_default = MdShortText;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShowChart.svelte
var file528 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShowChart.svelte";
function create_default_slot528(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z");
      add_location(path, file528, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot528.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment528(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot528] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment528.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance528($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShowChart", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShowChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance528, create_fragment528, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShowChart",
      options,
      id: create_fragment528.name
    });
  }
};
var MdShowChart_default = MdShowChart;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpaceBar.svelte
var file529 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpaceBar.svelte";
function create_default_slot529(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 9v4H6V9H4v6h16V9z");
      add_location(path, file529, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot529.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment529(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot529] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment529.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance529($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpaceBar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpaceBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance529, create_fragment529, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpaceBar",
      options,
      id: create_fragment529.name
    });
  }
};
var MdSpaceBar_default = MdSpaceBar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStrikethroughS.svelte
var file530 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStrikethroughS.svelte";
function create_default_slot530(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.24 8.75c-.26-.48-.39-1.03-.39-1.67 0-.61.13-1.16.4-1.67.26-.5.63-.93 1.11-1.29.48-.35 1.05-.63 1.7-.83.66-.19 1.39-.29 2.18-.29.81 0 1.54.11 2.21.34.66.22 1.23.54 1.69.94.47.4.83.88 1.08 1.43.25.55.38 1.15.38 1.81h-3.01c0-.31-.05-.59-.15-.85-.09-.27-.24-.49-.44-.68-.2-.19-.45-.33-.75-.44-.3-.1-.66-.16-1.06-.16-.39 0-.74.04-1.03.13-.29.09-.53.21-.72.36-.19.16-.34.34-.44.55-.1.21-.15.43-.15.66 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.05-.08-.11-.17-.15-.25zM21 12v-2H3v2h9.62c.18.07.4.14.55.2.37.17.66.34.87.51.21.17.35.36.43.57.07.2.11.43.11.69 0 .23-.05.45-.14.66-.09.2-.23.38-.42.53-.19.15-.42.26-.71.35-.29.08-.63.13-1.01.13-.43 0-.83-.04-1.18-.13s-.66-.23-.91-.42c-.25-.19-.45-.44-.59-.75-.14-.31-.25-.76-.25-1.21H6.4c0 .55.08 1.13.24 1.58.16.45.37.85.65 1.21.28.35.6.66.98.92.37.26.78.48 1.22.65.44.17.9.3 1.38.39.48.08.96.13 1.44.13.8 0 1.53-.09 2.18-.28s1.21-.45 1.67-.79c.46-.34.82-.77 1.07-1.27s.38-1.07.38-1.71c0-.6-.1-1.14-.31-1.61-.05-.11-.11-.23-.17-.33H21z");
      add_location(path, file530, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot530.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment530(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot530] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment530.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance530($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStrikethroughS", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStrikethroughS = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance530, create_fragment530, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStrikethroughS",
      options,
      id: create_fragment530.name
    });
  }
};
var MdStrikethroughS_default = MdStrikethroughS;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTextFields.svelte
var file531 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTextFields.svelte";
function create_default_slot531(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z");
      add_location(path, file531, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot531.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment531(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot531] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment531.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance531($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTextFields", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTextFields = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance531, create_fragment531, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTextFields",
      options,
      id: create_fragment531.name
    });
  }
};
var MdTextFields_default = MdTextFields;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTitle.svelte
var file532 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTitle.svelte";
function create_default_slot532(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 4v3h5.5v12h3V7H19V4z");
      add_location(path, file532, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot532.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment532(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot532] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment532.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance532($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTitle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance532, create_fragment532, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTitle",
      options,
      id: create_fragment532.name
    });
  }
};
var MdTitle_default = MdTitle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerticalAlignBottom.svelte
var file533 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerticalAlignBottom.svelte";
function create_default_slot533(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z");
      add_location(path, file533, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot533.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment533(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot533] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment533.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance533($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVerticalAlignBottom", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVerticalAlignBottom = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance533, create_fragment533, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVerticalAlignBottom",
      options,
      id: create_fragment533.name
    });
  }
};
var MdVerticalAlignBottom_default = MdVerticalAlignBottom;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerticalAlignCenter.svelte
var file534 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerticalAlignCenter.svelte";
function create_default_slot534(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z");
      add_location(path, file534, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot534.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment534(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot534] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment534.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance534($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVerticalAlignCenter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVerticalAlignCenter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance534, create_fragment534, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVerticalAlignCenter",
      options,
      id: create_fragment534.name
    });
  }
};
var MdVerticalAlignCenter_default = MdVerticalAlignCenter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerticalAlignTop.svelte
var file535 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVerticalAlignTop.svelte";
function create_default_slot535(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z");
      add_location(path, file535, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot535.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment535(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot535] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment535.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance535($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVerticalAlignTop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVerticalAlignTop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance535, create_fragment535, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVerticalAlignTop",
      options,
      id: create_fragment535.name
    });
  }
};
var MdVerticalAlignTop_default = MdVerticalAlignTop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWrapText.svelte
var file536 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWrapText.svelte";
function create_default_slot536(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z");
      add_location(path, file536, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot536.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment536(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot536] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment536.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance536($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWrapText", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWrapText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance536, create_fragment536, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWrapText",
      options,
      id: create_fragment536.name
    });
  }
};
var MdWrapText_default = MdWrapText;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAttachment.svelte
var file537 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAttachment.svelte";
function create_default_slot537(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 12.5C2 9.46 4.46 7 7.5 7H18c2.21 0 4 1.79 4 4s-1.79 4-4 4H9.5C8.12 15 7 13.88 7 12.5S8.12 10 9.5 10H17v2H9.41c-.55 0-.55 1 0 1H18c1.1 0 2-.9 2-2s-.9-2-2-2H7.5C5.57 9 4 10.57 4 12.5S5.57 16 7.5 16H17v2H7.5C4.46 18 2 15.54 2 12.5z");
      add_location(path, file537, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot537.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment537(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot537] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment537.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance537($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAttachment", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAttachment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance537, create_fragment537, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAttachment",
      options,
      id: create_fragment537.name
    });
  }
};
var MdAttachment_default = MdAttachment;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloud.svelte
var file538 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloud.svelte";
function create_default_slot538(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z");
      add_location(path, file538, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot538.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment538(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot538] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment538.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance538($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloud", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloud = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance538, create_fragment538, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloud",
      options,
      id: create_fragment538.name
    });
  }
};
var MdCloud_default = MdCloud;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudCircle.svelte
var file539 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudCircle.svelte";
function create_default_slot539(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.5 14H8c-1.66 0-3-1.34-3-3s1.34-3 3-3l.14.01C8.58 8.28 10.13 7 12 7c2.21 0 4 1.79 4 4h.5c1.38 0 2.5 1.12 2.5 2.5S17.88 16 16.5 16z");
      add_location(path, file539, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot539.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment539(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot539] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment539.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance539($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloudCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloudCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance539, create_fragment539, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloudCircle",
      options,
      id: create_fragment539.name
    });
  }
};
var MdCloudCircle_default = MdCloudCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudDone.svelte
var file540 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudDone.svelte";
function create_default_slot540(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41L10 17z");
      add_location(path, file540, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot540.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment540(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot540] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment540.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance540($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloudDone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloudDone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance540, create_fragment540, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloudDone",
      options,
      id: create_fragment540.name
    });
  }
};
var MdCloudDone_default = MdCloudDone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudDownload.svelte
var file541 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudDownload.svelte";
function create_default_slot541(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z");
      add_location(path, file541, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot541.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment541(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot541] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment541.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance541($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloudDownload", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloudDownload = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance541, create_fragment541, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloudDownload",
      options,
      id: create_fragment541.name
    });
  }
};
var MdCloudDownload_default = MdCloudDownload;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudOff.svelte
var file542 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudOff.svelte";
function create_default_slot542(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4c-1.48 0-2.85.43-4.01 1.17l1.46 1.46C10.21 6.23 11.08 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45C23.16 18.16 24 16.68 24 15c0-2.64-2.05-4.78-4.65-4.96zM3 5.27l2.75 2.74C2.56 8.15 0 10.77 0 14c0 3.31 2.69 6 6 6h11.73l2 2L21 20.73 4.27 4 3 5.27zM7.73 10l8 8H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z");
      add_location(path, file542, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot542.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment542(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot542] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment542.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance542($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloudOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloudOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance542, create_fragment542, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloudOff",
      options,
      id: create_fragment542.name
    });
  }
};
var MdCloudOff_default = MdCloudOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudQueue.svelte
var file543 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudQueue.svelte";
function create_default_slot543(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71C7.37 7.69 9.48 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3s-1.34 3-3 3z");
      add_location(path, file543, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot543.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment543(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot543] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment543.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance543($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloudQueue", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloudQueue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance543, create_fragment543, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloudQueue",
      options,
      id: create_fragment543.name
    });
  }
};
var MdCloudQueue_default = MdCloudQueue;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudUpload.svelte
var file544 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCloudUpload.svelte";
function create_default_slot544(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z");
      add_location(path, file544, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot544.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment544(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot544] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment544.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance544($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCloudUpload", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCloudUpload = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance544, create_fragment544, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCloudUpload",
      options,
      id: create_fragment544.name
    });
  }
};
var MdCloudUpload_default = MdCloudUpload;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCreateNewFolder.svelte
var file545 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCreateNewFolder.svelte";
function create_default_slot545(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-8l-2-2H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-1 8h-3v3h-2v-3h-3v-2h3V9h2v3h3v2z");
      add_location(path, file545, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot545.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment545(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot545] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment545.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance545($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCreateNewFolder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCreateNewFolder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance545, create_fragment545, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCreateNewFolder",
      options,
      id: create_fragment545.name
    });
  }
};
var MdCreateNewFolder_default = MdCreateNewFolder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFileDownload.svelte
var file546 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFileDownload.svelte";
function create_default_slot546(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z");
      add_location(path, file546, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot546.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment546(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot546] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment546.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance546($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFileDownload", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFileDownload = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance546, create_fragment546, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFileDownload",
      options,
      id: create_fragment546.name
    });
  }
};
var MdFileDownload_default = MdFileDownload;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFileUpload.svelte
var file547 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFileUpload.svelte";
function create_default_slot547(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z");
      add_location(path, file547, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot547.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment547(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot547] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment547.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance547($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFileUpload", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFileUpload = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance547, create_fragment547, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFileUpload",
      options,
      id: create_fragment547.name
    });
  }
};
var MdFileUpload_default = MdFileUpload;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolder.svelte
var file548 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolder.svelte";
function create_default_slot548(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z");
      add_location(path, file548, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot548.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment548(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot548] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment548.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance548($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFolder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFolder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance548, create_fragment548, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFolder",
      options,
      id: create_fragment548.name
    });
  }
};
var MdFolder_default = MdFolder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolderOpen.svelte
var file549 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolderOpen.svelte";
function create_default_slot549(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z");
      add_location(path, file549, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot549.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment549(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot549] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment549.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance549($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFolderOpen", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFolderOpen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance549, create_fragment549, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFolderOpen",
      options,
      id: create_fragment549.name
    });
  }
};
var MdFolderOpen_default = MdFolderOpen;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolderShared.svelte
var file550 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolderShared.svelte";
function create_default_slot550(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z");
      add_location(path, file550, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot550.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment550(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot550] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment550.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance550($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFolderShared", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFolderShared = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance550, create_fragment550, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFolderShared",
      options,
      id: create_fragment550.name
    });
  }
};
var MdFolderShared_default = MdFolderShared;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCast.svelte
var file551 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCast.svelte";
function create_default_slot551(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z");
      add_location(path, file551, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot551.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment551(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot551] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment551.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance551($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCast", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance551, create_fragment551, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCast",
      options,
      id: create_fragment551.name
    });
  }
};
var MdCast_default = MdCast;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCastConnected.svelte
var file552 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCastConnected.svelte";
function create_default_slot552(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm18-7H5v1.63c3.96 1.28 7.09 4.41 8.37 8.37H19V7zM1 10v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
      add_location(path, file552, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot552.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment552(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot552] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment552.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance552($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCastConnected", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCastConnected = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance552, create_fragment552, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCastConnected",
      options,
      id: create_fragment552.name
    });
  }
};
var MdCastConnected_default = MdCastConnected;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdComputer.svelte
var file553 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdComputer.svelte";
function create_default_slot553(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18c1.1 0 1.99-.9 1.99-2L22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2H0v2h24v-2h-4zM4 6h16v10H4V6z");
      add_location(path, file553, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot553.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment553(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot553] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment553.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance553($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdComputer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdComputer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance553, create_fragment553, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdComputer",
      options,
      id: create_fragment553.name
    });
  }
};
var MdComputer_default = MdComputer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDesktopMac.svelte
var file554 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDesktopMac.svelte";
function create_default_slot554(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7l-2 3v1h8v-1l-2-3h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 12H3V4h18v10z");
      add_location(path, file554, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot554.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment554(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot554] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment554.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance554($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDesktopMac", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDesktopMac = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance554, create_fragment554, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDesktopMac",
      options,
      id: create_fragment554.name
    });
  }
};
var MdDesktopMac_default = MdDesktopMac;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDesktopWindows.svelte
var file555 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDesktopWindows.svelte";
function create_default_slot555(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H3V4h18v12z");
      add_location(path, file555, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot555.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment555(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot555] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment555.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance555($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDesktopWindows", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDesktopWindows = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance555, create_fragment555, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDesktopWindows",
      options,
      id: create_fragment555.name
    });
  }
};
var MdDesktopWindows_default = MdDesktopWindows;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeveloperBoard.svelte
var file556 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeveloperBoard.svelte";
function create_default_slot556(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 9V7h-2V5c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-2h2v-2h-2v-2h2v-2h-2V9h2zm-4 10H4V5h14v14zM6 13h5v4H6zm6-6h4v3h-4zM6 7h5v5H6zm6 4h4v6h-4z");
      add_location(path, file556, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot556.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment556(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot556] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment556.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance556($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDeveloperBoard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDeveloperBoard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance556, create_fragment556, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDeveloperBoard",
      options,
      id: create_fragment556.name
    });
  }
};
var MdDeveloperBoard_default = MdDeveloperBoard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeviceHub.svelte
var file557 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDeviceHub.svelte";
function create_default_slot557(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 16l-4-4V8.82C14.16 8.4 15 7.3 15 6c0-1.66-1.34-3-3-3S9 4.34 9 6c0 1.3.84 2.4 2 2.82V12l-4 4H3v5h5v-3.05l4-4.2 4 4.2V21h5v-5h-4z");
      add_location(path, file557, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot557.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment557(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot557] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment557.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance557($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDeviceHub", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDeviceHub = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance557, create_fragment557, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDeviceHub",
      options,
      id: create_fragment557.name
    });
  }
};
var MdDeviceHub_default = MdDeviceHub;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDevicesOther.svelte
var file558 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDevicesOther.svelte";
function create_default_slot558(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 6h18V4H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4v-2H3V6zm10 6H9v1.78c-.61.55-1 1.33-1 2.22s.39 1.67 1 2.22V20h4v-1.78c.61-.55 1-1.34 1-2.22s-.39-1.67-1-2.22V12zm-2 5.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM22 8h-6c-.5 0-1 .5-1 1v10c0 .5.5 1 1 1h6c.5 0 1-.5 1-1V9c0-.5-.5-1-1-1zm-1 10h-4v-8h4v8z");
      add_location(path, file558, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot558.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment558(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot558] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment558.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance558($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDevicesOther", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDevicesOther = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance558, create_fragment558, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDevicesOther",
      options,
      id: create_fragment558.name
    });
  }
};
var MdDevicesOther_default = MdDevicesOther;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDock.svelte
var file559 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDock.svelte";
function create_default_slot559(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 23h8v-2H8v2zm8-21.99L8 1c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM16 15H8V5h8v10z");
      add_location(path, file559, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot559.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment559(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot559] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment559.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance559($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance559, create_fragment559, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDock",
      options,
      id: create_fragment559.name
    });
  }
};
var MdDock_default = MdDock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGamepad.svelte
var file560 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGamepad.svelte";
function create_default_slot560(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 7.5V2H9v5.5l3 3 3-3zM7.5 9H2v6h5.5l3-3-3-3zM9 16.5V22h6v-5.5l-3-3-3 3zM16.5 9l-3 3 3 3H22V9h-5.5z");
      add_location(path, file560, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot560.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment560(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot560] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment560.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance560($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGamepad", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGamepad = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance560, create_fragment560, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGamepad",
      options,
      id: create_fragment560.name
    });
  }
};
var MdGamepad_default = MdGamepad;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHeadset.svelte
var file561 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHeadset.svelte";
function create_default_slot561(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 1c-4.97 0-9 4.03-9 9v7c0 1.66 1.34 3 3 3h3v-8H5v-2c0-3.87 3.13-7 7-7s7 3.13 7 7v2h-4v8h3c1.66 0 3-1.34 3-3v-7c0-4.97-4.03-9-9-9z");
      add_location(path, file561, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot561.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment561(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot561] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment561.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance561($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHeadset", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHeadset = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance561, create_fragment561, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHeadset",
      options,
      id: create_fragment561.name
    });
  }
};
var MdHeadset_default = MdHeadset;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHeadsetMic.svelte
var file562 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHeadsetMic.svelte";
function create_default_slot562(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 1c-4.97 0-9 4.03-9 9v7c0 1.66 1.34 3 3 3h3v-8H5v-2c0-3.87 3.13-7 7-7s7 3.13 7 7v2h-4v8h4v1h-7v2h6c1.66 0 3-1.34 3-3V10c0-4.97-4.03-9-9-9z");
      add_location(path, file562, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot562.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment562(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot562] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment562.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance562($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHeadsetMic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHeadsetMic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance562, create_fragment562, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHeadsetMic",
      options,
      id: create_fragment562.name
    });
  }
};
var MdHeadsetMic_default = MdHeadsetMic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboard.svelte
var file563 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboard.svelte";
function create_default_slot563(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z");
      add_location(path, file563, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot563.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment563(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot563] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment563.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance563($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance563, create_fragment563, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboard",
      options,
      id: create_fragment563.name
    });
  }
};
var MdKeyboard_default = MdKeyboard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowDown.svelte
var file564 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowDown.svelte";
function create_default_slot564(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.41 7.84L12 12.42l4.59-4.58L18 9.25l-6 6-6-6z");
      add_location(path, file564, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot564.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment564(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot564] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment564.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance564($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardArrowDown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardArrowDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance564, create_fragment564, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardArrowDown",
      options,
      id: create_fragment564.name
    });
  }
};
var MdKeyboardArrowDown_default = MdKeyboardArrowDown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowLeft.svelte
var file565 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowLeft.svelte";
function create_default_slot565(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z");
      add_location(path, file565, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot565.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment565(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot565] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment565.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance565($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardArrowLeft", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardArrowLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance565, create_fragment565, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardArrowLeft",
      options,
      id: create_fragment565.name
    });
  }
};
var MdKeyboardArrowLeft_default = MdKeyboardArrowLeft;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowRight.svelte
var file566 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowRight.svelte";
function create_default_slot566(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z");
      add_location(path, file566, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot566.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment566(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot566] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment566.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance566($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardArrowRight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardArrowRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance566, create_fragment566, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardArrowRight",
      options,
      id: create_fragment566.name
    });
  }
};
var MdKeyboardArrowRight_default = MdKeyboardArrowRight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowUp.svelte
var file567 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardArrowUp.svelte";
function create_default_slot567(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z");
      add_location(path, file567, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot567.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment567(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot567] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment567.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance567($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardArrowUp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardArrowUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance567, create_fragment567, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardArrowUp",
      options,
      id: create_fragment567.name
    });
  }
};
var MdKeyboardArrowUp_default = MdKeyboardArrowUp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardBackspace.svelte
var file568 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardBackspace.svelte";
function create_default_slot568(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 11H6.83l3.58-3.59L9 6l-6 6 6 6 1.41-1.41L6.83 13H21z");
      add_location(path, file568, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot568.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment568(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot568] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment568.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance568($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardBackspace", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardBackspace = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance568, create_fragment568, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardBackspace",
      options,
      id: create_fragment568.name
    });
  }
};
var MdKeyboardBackspace_default = MdKeyboardBackspace;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardCapslock.svelte
var file569 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardCapslock.svelte";
function create_default_slot569(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8.41L16.59 13 18 11.59l-6-6-6 6L7.41 13 12 8.41zM6 18h12v-2H6v2z");
      add_location(path, file569, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot569.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment569(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot569] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment569.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance569($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardCapslock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardCapslock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance569, create_fragment569, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardCapslock",
      options,
      id: create_fragment569.name
    });
  }
};
var MdKeyboardCapslock_default = MdKeyboardCapslock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardHide.svelte
var file570 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardHide.svelte";
function create_default_slot570(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 3H4c-1.1 0-1.99.9-1.99 2L2 15c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 3h2v2h-2V6zm0 3h2v2h-2V9zM8 6h2v2H8V6zm0 3h2v2H8V9zm-1 2H5V9h2v2zm0-3H5V6h2v2zm9 7H8v-2h8v2zm0-4h-2V9h2v2zm0-3h-2V6h2v2zm3 3h-2V9h2v2zm0-3h-2V6h2v2zm-7 15l4-4H8l4 4z");
      add_location(path, file570, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot570.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment570(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot570] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment570.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance570($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardHide", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardHide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance570, create_fragment570, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardHide",
      options,
      id: create_fragment570.name
    });
  }
};
var MdKeyboardHide_default = MdKeyboardHide;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardReturn.svelte
var file571 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardReturn.svelte";
function create_default_slot571(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.41L5.83 13H21V7z");
      add_location(path, file571, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot571.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment571(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot571] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment571.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance571($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardReturn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardReturn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance571, create_fragment571, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardReturn",
      options,
      id: create_fragment571.name
    });
  }
};
var MdKeyboardReturn_default = MdKeyboardReturn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardTab.svelte
var file572 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardTab.svelte";
function create_default_slot572(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.59 7.41L15.17 11H1v2h14.17l-3.59 3.59L13 18l6-6-6-6-1.41 1.41zM20 6v12h2V6h-2z");
      add_location(path, file572, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot572.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment572(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot572] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment572.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance572($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardTab", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardTab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance572, create_fragment572, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardTab",
      options,
      id: create_fragment572.name
    });
  }
};
var MdKeyboardTab_default = MdKeyboardTab;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardVoice.svelte
var file573 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKeyboardVoice.svelte";
function create_default_slot573(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.42 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z");
      add_location(path, file573, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot573.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment573(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot573] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment573.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance573($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKeyboardVoice", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKeyboardVoice = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance573, create_fragment573, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKeyboardVoice",
      options,
      id: create_fragment573.name
    });
  }
};
var MdKeyboardVoice_default = MdKeyboardVoice;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptop.svelte
var file574 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptop.svelte";
function create_default_slot574(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2H0v2h24v-2h-4zM4 6h16v10H4V6z");
      add_location(path, file574, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot574.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment574(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot574] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment574.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance574($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLaptop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLaptop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance574, create_fragment574, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLaptop",
      options,
      id: create_fragment574.name
    });
  }
};
var MdLaptop_default = MdLaptop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptopChromebook.svelte
var file575 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptopChromebook.svelte";
function create_default_slot575(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 18V3H2v15H0v2h24v-2h-2zm-8 0h-4v-1h4v1zm6-3H4V5h16v10z");
      add_location(path, file575, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot575.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment575(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot575] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment575.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance575($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLaptopChromebook", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLaptopChromebook = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance575, create_fragment575, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLaptopChromebook",
      options,
      id: create_fragment575.name
    });
  }
};
var MdLaptopChromebook_default = MdLaptopChromebook;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptopMac.svelte
var file576 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptopMac.svelte";
function create_default_slot576(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18c1.1 0 1.99-.9 1.99-2L22 5c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2H0c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2h-4zM4 5h16v11H4V5zm8 14c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z");
      add_location(path, file576, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot576.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment576(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot576] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment576.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance576($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLaptopMac", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLaptopMac = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance576, create_fragment576, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLaptopMac",
      options,
      id: create_fragment576.name
    });
  }
};
var MdLaptopMac_default = MdLaptopMac;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptopWindows.svelte
var file577 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLaptopWindows.svelte";
function create_default_slot577(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18v-1c1.1 0 1.99-.9 1.99-2L22 5c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2v1H0v2h24v-2h-4zM4 5h16v10H4V5z");
      add_location(path, file577, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot577.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment577(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot577] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment577.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance577($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLaptopWindows", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLaptopWindows = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance577, create_fragment577, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLaptopWindows",
      options,
      id: create_fragment577.name
    });
  }
};
var MdLaptopWindows_default = MdLaptopWindows;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMemory.svelte
var file578 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMemory.svelte";
function create_default_slot578(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 9H9v6h6V9zm-2 4h-2v-2h2v2zm8-2V9h-2V7c0-1.1-.9-2-2-2h-2V3h-2v2h-2V3H9v2H7c-1.1 0-2 .9-2 2v2H3v2h2v2H3v2h2v2c0 1.1.9 2 2 2h2v2h2v-2h2v2h2v-2h2c1.1 0 2-.9 2-2v-2h2v-2h-2v-2h2zm-4 6H7V7h10v10z");
      add_location(path, file578, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot578.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment578(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot578] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment578.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance578($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMemory", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMemory = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance578, create_fragment578, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMemory",
      options,
      id: create_fragment578.name
    });
  }
};
var MdMemory_default = MdMemory;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMouse.svelte
var file579 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMouse.svelte";
function create_default_slot579(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 1.07V9h7c0-4.08-3.05-7.44-7-7.93zM4 15c0 4.42 3.58 8 8 8s8-3.58 8-8v-4H4v4zm7-13.93C7.05 1.56 4 4.92 4 9h7V1.07z");
      add_location(path, file579, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot579.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment579(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot579] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment579.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance579($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMouse", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMouse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance579, create_fragment579, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMouse",
      options,
      id: create_fragment579.name
    });
  }
};
var MdMouse_default = MdMouse;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneAndroid.svelte
var file580 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneAndroid.svelte";
function create_default_slot580(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 1H8C6.34 1 5 2.34 5 4v16c0 1.66 1.34 3 3 3h8c1.66 0 3-1.34 3-3V4c0-1.66-1.34-3-3-3zm-2 20h-4v-1h4v1zm3.25-3H6.75V4h10.5v14z");
      add_location(path, file580, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot580.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment580(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot580] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment580.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance580($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneAndroid", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneAndroid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance580, create_fragment580, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneAndroid",
      options,
      id: create_fragment580.name
    });
  }
};
var MdPhoneAndroid_default = MdPhoneAndroid;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneIphone.svelte
var file581 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneIphone.svelte";
function create_default_slot581(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.5 1h-8C6.12 1 5 2.12 5 3.5v17C5 21.88 6.12 23 7.5 23h8c1.38 0 2.5-1.12 2.5-2.5v-17C18 2.12 16.88 1 15.5 1zm-4 21c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm4.5-4H7V4h9v14z");
      add_location(path, file581, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot581.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment581(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot581] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment581.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance581($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneIphone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneIphone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance581, create_fragment581, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneIphone",
      options,
      id: create_fragment581.name
    });
  }
};
var MdPhoneIphone_default = MdPhoneIphone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelink.svelte
var file582 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelink.svelte";
function create_default_slot582(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6h18V4H4c-1.1 0-2 .9-2 2v11H0v3h14v-3H4V6zm19 2h-6c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-1 9h-4v-7h4v7z");
      add_location(path, file582, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot582.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment582(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot582] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment582.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance582($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonelink", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonelink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance582, create_fragment582, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonelink",
      options,
      id: create_fragment582.name
    });
  }
};
var MdPhonelink_default = MdPhonelink;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkOff.svelte
var file583 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonelinkOff.svelte";
function create_default_slot583(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 6V4H6.82l2 2H22zM1.92 1.65L.65 2.92l1.82 1.82C2.18 5.08 2 5.52 2 6v11H0v3h17.73l2.35 2.35 1.27-1.27L3.89 3.62 1.92 1.65zM4 6.27L14.73 17H4V6.27zM23 8h-6c-.55 0-1 .45-1 1v4.18l2 2V10h4v7h-2.18l3 3H23c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1z");
      add_location(path, file583, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot583.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment583(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot583] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment583.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance583($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonelinkOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonelinkOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance583, create_fragment583, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonelinkOff",
      options,
      id: create_fragment583.name
    });
  }
};
var MdPhonelinkOff_default = MdPhonelinkOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPowerInput.svelte
var file584 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPowerInput.svelte";
function create_default_slot584(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 9v2h19V9H2zm0 6h5v-2H2v2zm7 0h5v-2H9v2zm7 0h5v-2h-5v2z");
      add_location(path, file584, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot584.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment584(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot584] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment584.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance584($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPowerInput", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPowerInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance584, create_fragment584, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPowerInput",
      options,
      id: create_fragment584.name
    });
  }
};
var MdPowerInput_default = MdPowerInput;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRouter.svelte
var file585 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRouter.svelte";
function create_default_slot585(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.2 5.9l.8-.8C19.6 3.7 17.8 3 16 3s-3.6.7-5 2.1l.8.8C13 4.8 14.5 4.2 16 4.2s3 .6 4.2 1.7zm-.9.8c-.9-.9-2.1-1.4-3.3-1.4s-2.4.5-3.3 1.4l.8.8c.7-.7 1.6-1 2.5-1 .9 0 1.8.3 2.5 1l.8-.8zM19 13h-2V9h-2v4H5c-1.1 0-2 .9-2 2v4c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-4c0-1.1-.9-2-2-2zM8 18H6v-2h2v2zm3.5 0h-2v-2h2v2zm3.5 0h-2v-2h2v2z");
      add_location(path, file585, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot585.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment585(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot585] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment585.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance585($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRouter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRouter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance585, create_fragment585, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRouter",
      options,
      id: create_fragment585.name
    });
  }
};
var MdRouter_default = MdRouter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScanner.svelte
var file586 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdScanner.svelte";
function create_default_slot586(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.8 10.7L4.2 5l-.7 1.9L17.6 12H5c-1.1 0-2 .9-2 2v4c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5.5c0-.8-.5-1.6-1.2-1.8zM7 17H5v-2h2v2zm12 0H9v-2h10v2z");
      add_location(path, file586, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot586.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment586(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot586] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment586.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance586($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdScanner", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdScanner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance586, create_fragment586, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdScanner",
      options,
      id: create_fragment586.name
    });
  }
};
var MdScanner_default = MdScanner;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSecurity.svelte
var file587 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSecurity.svelte";
function create_default_slot587(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z");
      add_location(path, file587, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot587.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment587(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot587] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment587.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance587($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSecurity", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSecurity = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance587, create_fragment587, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSecurity",
      options,
      id: create_fragment587.name
    });
  }
};
var MdSecurity_default = MdSecurity;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSimCard.svelte
var file588 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSimCard.svelte";
function create_default_slot588(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.99 4c0-1.1-.89-2-1.99-2h-8L4 8v12c0 1.1.9 2 2 2h12.01c1.1 0 1.99-.9 1.99-2l-.01-16zM9 19H7v-2h2v2zm8 0h-2v-2h2v2zm-8-4H7v-4h2v4zm4 4h-2v-4h2v4zm0-6h-2v-2h2v2zm4 2h-2v-4h2v4z");
      add_location(path, file588, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot588.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment588(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot588] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment588.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance588($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSimCard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSimCard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance588, create_fragment588, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSimCard",
      options,
      id: create_fragment588.name
    });
  }
};
var MdSimCard_default = MdSimCard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmartphone.svelte
var file589 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmartphone.svelte";
function create_default_slot589(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z");
      add_location(path, file589, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot589.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment589(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot589] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment589.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance589($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSmartphone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSmartphone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance589, create_fragment589, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSmartphone",
      options,
      id: create_fragment589.name
    });
  }
};
var MdSmartphone_default = MdSmartphone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeaker.svelte
var file590 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeaker.svelte";
function create_default_slot590(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 2H7c-1.1 0-2 .9-2 2v16c0 1.1.9 1.99 2 1.99L17 22c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5 2c1.1 0 2 .9 2 2s-.9 2-2 2c-1.11 0-2-.9-2-2s.89-2 2-2zm0 16c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
      add_location(path, file590, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot590.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment590(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot590] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment590.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance590($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpeaker", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpeaker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance590, create_fragment590, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpeaker",
      options,
      id: create_fragment590.name
    });
  }
};
var MdSpeaker_default = MdSpeaker;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerGroup.svelte
var file591 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpeakerGroup.svelte";
function create_default_slot591(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M18.2 1H9.8C8.81 1 8 1.81 8 2.8v14.4c0 .99.81 1.79 1.8 1.79l8.4.01c.99 0 1.8-.81 1.8-1.8V2.8c0-.99-.81-1.8-1.8-1.8zM14 3c1.1 0 2 .89 2 2s-.9 2-2 2-2-.89-2-2 .9-2 2-2zm0 13.5c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z");
      add_location(path0, file591, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file591, 5, 0, 391);
      attr_dev(path2, "d", "M6 5H4v16c0 1.1.89 2 2 2h10v-2H6V5z");
      add_location(path2, file591, 6, 0, 414);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot591.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment591(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot591] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment591.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance591($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpeakerGroup", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpeakerGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance591, create_fragment591, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpeakerGroup",
      options,
      id: create_fragment591.name
    });
  }
};
var MdSpeakerGroup_default = MdSpeakerGroup;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTablet.svelte
var file592 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTablet.svelte";
function create_default_slot592(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 4H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h18c1.1 0 1.99-.9 1.99-2L23 6c0-1.1-.9-2-2-2zm-2 14H5V6h14v12z");
      add_location(path, file592, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot592.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment592(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot592] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment592.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance592($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTablet", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTablet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance592, create_fragment592, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTablet",
      options,
      id: create_fragment592.name
    });
  }
};
var MdTablet_default = MdTablet;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTabletAndroid.svelte
var file593 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTabletAndroid.svelte";
function create_default_slot593(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 0H6C4.34 0 3 1.34 3 3v18c0 1.66 1.34 3 3 3h12c1.66 0 3-1.34 3-3V3c0-1.66-1.34-3-3-3zm-4 22h-4v-1h4v1zm5.25-3H4.75V3h14.5v16z");
      add_location(path, file593, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot593.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment593(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot593] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment593.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance593($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTabletAndroid", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTabletAndroid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance593, create_fragment593, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTabletAndroid",
      options,
      id: create_fragment593.name
    });
  }
};
var MdTabletAndroid_default = MdTabletAndroid;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTabletMac.svelte
var file594 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTabletMac.svelte";
function create_default_slot594(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.5 0h-14C3.12 0 2 1.12 2 2.5v19C2 22.88 3.12 24 4.5 24h14c1.38 0 2.5-1.12 2.5-2.5v-19C21 1.12 19.88 0 18.5 0zm-7 23c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm7.5-4H4V3h15v16z");
      add_location(path, file594, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot594.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment594(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot594] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment594.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance594($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTabletMac", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTabletMac = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance594, create_fragment594, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTabletMac",
      options,
      id: create_fragment594.name
    });
  }
};
var MdTabletMac_default = MdTabletMac;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToys.svelte
var file595 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdToys.svelte";
function create_default_slot595(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 12c0-3 2.5-5.5 5.5-5.5S23 9 23 12H12zm0 0c0 3-2.5 5.5-5.5 5.5S1 15 1 12h11zm0 0c-3 0-5.5-2.5-5.5-5.5S9 1 12 1v11zm0 0c3 0 5.5 2.5 5.5 5.5S15 23 12 23V12z");
      add_location(path, file595, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot595.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment595(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot595] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment595.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance595($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdToys", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdToys = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance595, create_fragment595, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdToys",
      options,
      id: create_fragment595.name
    });
  }
};
var MdToys_default = MdToys;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTv.svelte
var file596 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTv.svelte";
function create_default_slot596(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z");
      add_location(path, file596, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot596.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment596(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot596] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment596.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance596($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTv", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTv = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance596, create_fragment596, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTv",
      options,
      id: create_fragment596.name
    });
  }
};
var MdTv_default = MdTv;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideogameAsset.svelte
var file597 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVideogameAsset.svelte";
function create_default_slot597(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-10 7H8v3H6v-3H3v-2h3V8h2v3h3v2zm4.5 2c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm4-3c-.83 0-1.5-.67-1.5-1.5S18.67 9 19.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file597, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot597.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment597(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot597] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment597.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance597($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVideogameAsset", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVideogameAsset = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance597, create_fragment597, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVideogameAsset",
      options,
      id: create_fragment597.name
    });
  }
};
var MdVideogameAsset_default = MdVideogameAsset;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWatch.svelte
var file598 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWatch.svelte";
function create_default_slot598(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 12c0-2.54-1.19-4.81-3.04-6.27L16 0H8l-.95 5.73C5.19 7.19 4 9.45 4 12s1.19 4.81 3.05 6.27L8 24h8l.96-5.73C18.81 16.81 20 14.54 20 12zM6 12c0-3.31 2.69-6 6-6s6 2.69 6 6-2.69 6-6 6-6-2.69-6-6z");
      add_location(path, file598, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot598.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment598(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot598] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment598.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance598($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWatch", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWatch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance598, create_fragment598, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWatch",
      options,
      id: create_fragment598.name
    });
  }
};
var MdWatch_default = MdWatch;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddAPhoto.svelte
var file599 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddAPhoto.svelte";
function create_default_slot599(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 4V1h2v3h3v2H5v3H3V6H0V4h3zm3 6V7h3V4h7l1.83 2H21c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V10h3zm7 9c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-3.2-5c0 1.77 1.43 3.2 3.2 3.2s3.2-1.43 3.2-3.2-1.43-3.2-3.2-3.2-3.2 1.43-3.2 3.2z");
      add_location(path, file599, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot599.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment599(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot599] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment599.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance599($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddAPhoto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddAPhoto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance599, create_fragment599, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddAPhoto",
      options,
      id: create_fragment599.name
    });
  }
};
var MdAddAPhoto_default = MdAddAPhoto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddToPhotos.svelte
var file600 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddToPhotos.svelte";
function create_default_slot600(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z");
      add_location(path, file600, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot600.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment600(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot600] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment600.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance600($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddToPhotos", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddToPhotos = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance600, create_fragment600, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddToPhotos",
      options,
      id: create_fragment600.name
    });
  }
};
var MdAddToPhotos_default = MdAddToPhotos;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAdjust.svelte
var file601 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAdjust.svelte";
function create_default_slot601(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3-8c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3z");
      add_location(path, file601, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot601.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment601(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot601] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment601.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance601($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAdjust", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAdjust = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance601, create_fragment601, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAdjust",
      options,
      id: create_fragment601.name
    });
  }
};
var MdAdjust_default = MdAdjust;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssistant.svelte
var file602 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssistant.svelte";
function create_default_slot602(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h4l3 3 3-3h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5.12 10.88L12 17l-1.88-4.12L6 11l4.12-1.88L12 5l1.88 4.12L18 11l-4.12 1.88z");
      add_location(path, file602, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot602.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment602(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot602] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment602.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance602($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssistant", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssistant = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance602, create_fragment602, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssistant",
      options,
      id: create_fragment602.name
    });
  }
};
var MdAssistant_default = MdAssistant;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssistantPhoto.svelte
var file603 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAssistantPhoto.svelte";
function create_default_slot603(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z");
      add_location(path, file603, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot603.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment603(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot603] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment603.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance603($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAssistantPhoto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAssistantPhoto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance603, create_fragment603, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAssistantPhoto",
      options,
      id: create_fragment603.name
    });
  }
};
var MdAssistantPhoto_default = MdAssistantPhoto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAudiotrack.svelte
var file604 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAudiotrack.svelte";
function create_default_slot604(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z");
      add_location(path, file604, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot604.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment604(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot604] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment604.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance604($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAudiotrack", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAudiotrack = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance604, create_fragment604, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAudiotrack",
      options,
      id: create_fragment604.name
    });
  }
};
var MdAudiotrack_default = MdAudiotrack;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurCircular.svelte
var file605 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurCircular.svelte";
function create_default_slot605(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM7 9.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm3 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-3-3c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm3-6c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-1.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm3 6c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-4c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm2-3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-3.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z");
      add_location(path, file605, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot605.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment605(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot605] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment605.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance605($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBlurCircular", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBlurCircular = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance605, create_fragment605, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBlurCircular",
      options,
      id: create_fragment605.name
    });
  }
};
var MdBlurCircular_default = MdBlurCircular;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurLinear.svelte
var file606 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurLinear.svelte";
function create_default_slot606(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 17.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 13c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zM3 21h18v-2H3v2zM5 9.5c.83 0 1.5-.67 1.5-1.5S5.83 6.5 5 6.5 3.5 7.17 3.5 8 4.17 9.5 5 9.5zm0 4c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5.67 1.5 1.5 1.5zM9 17c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8-.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM3 3v2h18V3H3zm14 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm0 4c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM13 9c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1z");
      add_location(path, file606, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot606.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment606(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot606] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment606.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance606($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBlurLinear", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBlurLinear = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance606, create_fragment606, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBlurLinear",
      options,
      id: create_fragment606.name
    });
  }
};
var MdBlurLinear_default = MdBlurLinear;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurOff.svelte
var file607 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurOff.svelte";
function create_default_slot607(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm-.2 4.48l.2.02c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5-1.5.67-1.5 1.5l.02.2c.09.67.61 1.19 1.28 1.28zM14 3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-4 0c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm11 7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm8 8c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-4c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm-4 13.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM2.5 5.27l3.78 3.78L6 9c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.03-.19-.06-.28l2.81 2.81c-.71.11-1.25.73-1.25 1.47 0 .83.67 1.5 1.5 1.5.74 0 1.36-.54 1.47-1.25l2.81 2.81c-.09-.03-.18-.06-.28-.06-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1c0-.1-.03-.19-.06-.28l3.78 3.78L20 20.23 3.77 4 2.5 5.27zM10 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm11-3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM3 9.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 11c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3-3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5z");
      add_location(path, file607, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot607.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment607(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot607] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment607.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance607($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBlurOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBlurOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance607, create_fragment607, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBlurOff",
      options,
      id: create_fragment607.name
    });
  }
};
var MdBlurOff_default = MdBlurOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurOn.svelte
var file608 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBlurOn.svelte";
function create_default_slot608(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3 .5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-11 10c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-17c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 5.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm8 .5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3 8.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM14 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-4-12c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 8.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-4.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-4c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
      add_location(path, file608, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot608.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment608(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot608] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment608.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance608($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBlurOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBlurOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance608, create_fragment608, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBlurOn",
      options,
      id: create_fragment608.name
    });
  }
};
var MdBlurOn_default = MdBlurOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness1.svelte
var file609 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness1.svelte";
function create_default_slot609(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "undefined");
      add_location(path, file609, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot609.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment609(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot609] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment609.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance609($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness1", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance609, create_fragment609, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness1",
      options,
      id: create_fragment609.name
    });
  }
};
var MdBrightness1_default = MdBrightness1;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness2.svelte
var file610 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness2.svelte";
function create_default_slot610(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 2c-1.82 0-3.53.5-5 1.35C7.99 5.08 10 8.3 10 12s-2.01 6.92-5 8.65C6.47 21.5 8.18 22 10 22c5.52 0 10-4.48 10-10S15.52 2 10 2z");
      add_location(path, file610, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot610.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment610(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot610] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment610.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance610($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness2", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance610, create_fragment610, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness2",
      options,
      id: create_fragment610.name
    });
  }
};
var MdBrightness2_default = MdBrightness2;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness3.svelte
var file611 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness3.svelte";
function create_default_slot611(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 2c-1.05 0-2.05.16-3 .46 4.06 1.27 7 5.06 7 9.54 0 4.48-2.94 8.27-7 9.54.95.3 1.95.46 3 .46 5.52 0 10-4.48 10-10S14.52 2 9 2z");
      add_location(path, file611, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot611.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment611(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot611] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment611.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance611($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness3", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance611, create_fragment611, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness3",
      options,
      id: create_fragment611.name
    });
  }
};
var MdBrightness3_default = MdBrightness3;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness4.svelte
var file612 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness4.svelte";
function create_default_slot612(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6c3.31 0 6 2.69 6 6s-2.69 6-6 6z");
      add_location(path, file612, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot612.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment612(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot612] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment612.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance612($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness4", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness4 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance612, create_fragment612, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness4",
      options,
      id: create_fragment612.name
    });
  }
};
var MdBrightness4_default = MdBrightness4;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness5.svelte
var file613 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness5.svelte";
function create_default_slot613(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.31L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z");
      add_location(path, file613, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot613.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment613(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot613] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment613.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance613($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness5", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance613, create_fragment613, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness5",
      options,
      id: create_fragment613.name
    });
  }
};
var MdBrightness5_default = MdBrightness5;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness6.svelte
var file614 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness6.svelte";
function create_default_slot614(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.31L23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18V6c3.31 0 6 2.69 6 6s-2.69 6-6 6z");
      add_location(path, file614, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot614.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment614(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot614] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment614.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance614($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness6", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness6 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance614, create_fragment614, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness6",
      options,
      id: create_fragment614.name
    });
  }
};
var MdBrightness6_default = MdBrightness6;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness7.svelte
var file615 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrightness7.svelte";
function create_default_slot615(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z");
      add_location(path, file615, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot615.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment615(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot615] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment615.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance615($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrightness7", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrightness7 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance615, create_fragment615, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrightness7",
      options,
      id: create_fragment615.name
    });
  }
};
var MdBrightness7_default = MdBrightness7;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrokenImage.svelte
var file616 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrokenImage.svelte";
function create_default_slot616(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 5v6.59l-3-3.01-4 4.01-4-4-4 4-3-3.01V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2zm-3 6.42l3 3.01V19c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2v-6.58l3 2.99 4-4 4 4 4-3.99z");
      add_location(path, file616, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot616.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment616(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot616] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment616.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance616($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrokenImage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrokenImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance616, create_fragment616, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrokenImage",
      options,
      id: create_fragment616.name
    });
  }
};
var MdBrokenImage_default = MdBrokenImage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrush.svelte
var file617 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBrush.svelte";
function create_default_slot617(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z");
      add_location(path, file617, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot617.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment617(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot617] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment617.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance617($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBrush", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBrush = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance617, create_fragment617, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBrush",
      options,
      id: create_fragment617.name
    });
  }
};
var MdBrush_default = MdBrush;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBurstMode.svelte
var file618 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBurstMode.svelte";
function create_default_slot618(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 5h2v14H1zm4 0h2v14H5zm17 0H10c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM11 17l2.5-3.15L15.29 16l2.5-3.22L21 17H11z");
      add_location(path, file618, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot618.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment618(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot618] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment618.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance618($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBurstMode", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBurstMode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance618, create_fragment618, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBurstMode",
      options,
      id: create_fragment618.name
    });
  }
};
var MdBurstMode_default = MdBurstMode;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCamera.svelte
var file619 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCamera.svelte";
function create_default_slot619(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.4 10.5l4.77-8.26C13.47 2.09 12.75 2 12 2c-2.4 0-4.6.85-6.32 2.25l3.66 6.35.06-.1zM21.54 9c-.92-2.92-3.15-5.26-6-6.34L11.88 9h9.66zm.26 1h-7.49l.29.5 4.76 8.25C21 16.97 22 14.61 22 12c0-.69-.07-1.35-.2-2zM8.54 12l-3.9-6.75C3.01 7.03 2 9.39 2 12c0 .69.07 1.35.2 2h7.49l-1.15-2zm-6.08 3c.92 2.92 3.15 5.26 6 6.34L12.12 15H2.46zm11.27 0l-3.9 6.76c.7.15 1.42.24 2.17.24 2.4 0 4.6-.85 6.32-2.25l-3.66-6.35-.93 1.6z");
      add_location(path, file619, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot619.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment619(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot619] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment619.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance619($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCamera", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCamera = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance619, create_fragment619, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCamera",
      options,
      id: create_fragment619.name
    });
  }
};
var MdCamera_default = MdCamera;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraAlt.svelte
var file620 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraAlt.svelte";
function create_default_slot620(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file620, 4, 10, 151);
      attr_dev(path1, "d", "M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z");
      add_location(path1, file620, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot620.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment620(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot620] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment620.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance620($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCameraAlt", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCameraAlt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance620, create_fragment620, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCameraAlt",
      options,
      id: create_fragment620.name
    });
  }
};
var MdCameraAlt_default = MdCameraAlt;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraFront.svelte
var file621 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraFront.svelte";
function create_default_slot621(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 20H5v2h5v2l3-3-3-3v2zm4 0v2h5v-2h-5zM12 8c1.1 0 2-.9 2-2s-.9-2-2-2-1.99.9-1.99 2S10.9 8 12 8zm5-8H7C5.9 0 5 .9 5 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zM7 2h10v10.5c0-1.67-3.33-2.5-5-2.5s-5 .83-5 2.5V2z");
      add_location(path, file621, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot621.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment621(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot621] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment621.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance621($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCameraFront", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCameraFront = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance621, create_fragment621, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCameraFront",
      options,
      id: create_fragment621.name
    });
  }
};
var MdCameraFront_default = MdCameraFront;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraRear.svelte
var file622 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraRear.svelte";
function create_default_slot622(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 20H5v2h5v2l3-3-3-3v2zm4 0v2h5v-2h-5zm3-20H7C5.9 0 5 .9 5 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zm-5 6c-1.11 0-2-.9-2-2s.89-2 1.99-2 2 .9 2 2C14 5.1 13.1 6 12 6z");
      add_location(path, file622, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot622.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment622(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot622] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment622.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance622($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCameraRear", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCameraRear = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance622, create_fragment622, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCameraRear",
      options,
      id: create_fragment622.name
    });
  }
};
var MdCameraRear_default = MdCameraRear;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraRoll.svelte
var file623 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCameraRoll.svelte";
function create_default_slot623(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 5c0-1.1-.9-2-2-2h-1V2c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v1H4c-1.1 0-2 .9-2 2v15c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2h8V5h-8zm-2 13h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2zm4 9h-2v-2h2v2zm0-9h-2V7h2v2z");
      add_location(path, file623, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot623.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment623(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot623] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment623.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance623($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCameraRoll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCameraRoll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance623, create_fragment623, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCameraRoll",
      options,
      id: create_fragment623.name
    });
  }
};
var MdCameraRoll_default = MdCameraRoll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCenterFocusStrong.svelte
var file624 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCenterFocusStrong.svelte";
function create_default_slot624(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm-7 7H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4z");
      add_location(path, file624, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot624.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment624(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot624] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment624.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance624($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCenterFocusStrong", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCenterFocusStrong = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance624, create_fragment624, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCenterFocusStrong",
      options,
      id: create_fragment624.name
    });
  }
};
var MdCenterFocusStrong_default = MdCenterFocusStrong;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCenterFocusWeak.svelte
var file625 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCenterFocusWeak.svelte";
function create_default_slot625(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 15H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file625, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot625.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment625(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot625] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment625.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance625($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCenterFocusWeak", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCenterFocusWeak = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance625, create_fragment625, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCenterFocusWeak",
      options,
      id: create_fragment625.name
    });
  }
};
var MdCenterFocusWeak_default = MdCenterFocusWeak;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCollections.svelte
var file626 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCollections.svelte";
function create_default_slot626(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z");
      add_location(path, file626, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot626.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment626(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot626] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment626.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance626($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCollections", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCollections = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance626, create_fragment626, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCollections",
      options,
      id: create_fragment626.name
    });
  }
};
var MdCollections_default = MdCollections;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCollectionsBookmark.svelte
var file627 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCollectionsBookmark.svelte";
function create_default_slot627(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 10l-2.5-1.5L15 12V4h5v8z");
      add_location(path, file627, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot627.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment627(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot627] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment627.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance627($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCollectionsBookmark", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCollectionsBookmark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance627, create_fragment627, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCollectionsBookmark",
      options,
      id: create_fragment627.name
    });
  }
};
var MdCollectionsBookmark_default = MdCollectionsBookmark;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdColorLens.svelte
var file628 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdColorLens.svelte";
function create_default_slot628(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file628, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot628.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment628(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot628] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment628.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance628($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdColorLens", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdColorLens = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance628, create_fragment628, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdColorLens",
      options,
      id: create_fragment628.name
    });
  }
};
var MdColorLens_default = MdColorLens;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdColorize.svelte
var file629 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdColorize.svelte";
function create_default_slot629(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.71 5.63l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42zM6.92 19L5 17.08l8.06-8.06 1.92 1.92L6.92 19z");
      add_location(path, file629, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot629.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment629(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot629] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment629.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance629($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdColorize", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdColorize = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance629, create_fragment629, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdColorize",
      options,
      id: create_fragment629.name
    });
  }
};
var MdColorize_default = MdColorize;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCompare.svelte
var file630 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCompare.svelte";
function create_default_slot630(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h5v2h2V1h-2v2zm0 15H5l5-6v6zm9-15h-5v2h5v13l-5-6v9h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
      add_location(path, file630, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot630.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment630(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot630] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment630.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance630($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCompare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCompare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance630, create_fragment630, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCompare",
      options,
      id: create_fragment630.name
    });
  }
};
var MdCompare_default = MdCompare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdControlPoint.svelte
var file631 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdControlPoint.svelte";
function create_default_slot631(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file631, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot631.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment631(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot631] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment631.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance631($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdControlPoint", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdControlPoint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance631, create_fragment631, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdControlPoint",
      options,
      id: create_fragment631.name
    });
  }
};
var MdControlPoint_default = MdControlPoint;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdControlPointDuplicate.svelte
var file632 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdControlPointDuplicate.svelte";
function create_default_slot632(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 8h-2v3h-3v2h3v3h2v-3h3v-2h-3zM2 12c0-2.79 1.64-5.2 4.01-6.32V3.52C2.52 4.76 0 8.09 0 12s2.52 7.24 6.01 8.48v-2.16C3.64 17.2 2 14.79 2 12zm13-9c-4.96 0-9 4.04-9 9s4.04 9 9 9 9-4.04 9-9-4.04-9-9-9zm0 16c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7z");
      add_location(path, file632, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot632.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment632(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot632] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment632.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance632($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdControlPointDuplicate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdControlPointDuplicate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance632, create_fragment632, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdControlPointDuplicate",
      options,
      id: create_fragment632.name
    });
  }
};
var MdControlPointDuplicate_default = MdControlPointDuplicate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop169.svelte
var file633 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop169.svelte";
function create_default_slot633(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 6H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H5V8h14v8z");
      add_location(path, file633, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot633.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment633(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot633] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment633.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance633($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCrop169", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCrop169 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance633, create_fragment633, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCrop169",
      options,
      id: create_fragment633.name
    });
  }
};
var MdCrop169_default = MdCrop169;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop.svelte
var file634 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop.svelte";
function create_default_slot634(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z");
      add_location(path, file634, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot634.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment634(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot634] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment634.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance634($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCrop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance634, create_fragment634, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCrop",
      options,
      id: create_fragment634.name
    });
  }
};
var MdCrop_default = MdCrop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop32.svelte
var file635 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop32.svelte";
function create_default_slot635(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 4H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H5V6h14v12z");
      add_location(path, file635, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot635.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment635(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot635] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment635.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance635($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCrop32", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCrop32 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance635, create_fragment635, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCrop32",
      options,
      id: create_fragment635.name
    });
  }
};
var MdCrop32_default = MdCrop32;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop54.svelte
var file636 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop54.svelte";
function create_default_slot636(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 5H5c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 12H5V7h14v10z");
      add_location(path, file636, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot636.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment636(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot636] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment636.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance636($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCrop54", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCrop54 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance636, create_fragment636, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCrop54",
      options,
      id: create_fragment636.name
    });
  }
};
var MdCrop54_default = MdCrop54;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop75.svelte
var file637 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCrop75.svelte";
function create_default_slot637(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 7H5c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zm0 8H5V9h14v6z");
      add_location(path, file637, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot637.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment637(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot637] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment637.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance637($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCrop75", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCrop75 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance637, create_fragment637, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCrop75",
      options,
      id: create_fragment637.name
    });
  }
};
var MdCrop75_default = MdCrop75;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropDin.svelte
var file638 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropDin.svelte";
function create_default_slot638(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z");
      add_location(path, file638, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot638.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment638(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot638] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment638.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance638($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropDin", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropDin = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance638, create_fragment638, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropDin",
      options,
      id: create_fragment638.name
    });
  }
};
var MdCropDin_default = MdCropDin;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropFree.svelte
var file639 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropFree.svelte";
function create_default_slot639(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5v4h2V5h4V3H5c-1.1 0-2 .9-2 2zm2 10H3v4c0 1.1.9 2 2 2h4v-2H5v-4zm14 4h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zm0-16h-4v2h4v4h2V5c0-1.1-.9-2-2-2z");
      add_location(path, file639, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot639.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment639(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot639] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment639.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance639($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropFree", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropFree = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance639, create_fragment639, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropFree",
      options,
      id: create_fragment639.name
    });
  }
};
var MdCropFree_default = MdCropFree;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropLandscape.svelte
var file640 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropLandscape.svelte";
function create_default_slot640(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 5H5c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 12H5V7h14v10z");
      add_location(path, file640, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot640.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment640(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot640] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment640.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance640($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropLandscape", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropLandscape = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance640, create_fragment640, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropLandscape",
      options,
      id: create_fragment640.name
    });
  }
};
var MdCropLandscape_default = MdCropLandscape;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropOriginal.svelte
var file641 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropOriginal.svelte";
function create_default_slot641(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-5.04-6.71l-2.75 3.54-1.96-2.36L6.5 17h11l-3.54-4.71z");
      add_location(path, file641, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot641.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment641(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot641] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment641.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance641($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropOriginal", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropOriginal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance641, create_fragment641, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropOriginal",
      options,
      id: create_fragment641.name
    });
  }
};
var MdCropOriginal_default = MdCropOriginal;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropPortrait.svelte
var file642 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropPortrait.svelte";
function create_default_slot642(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H7V5h10v14z");
      add_location(path, file642, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot642.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment642(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot642] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment642.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance642($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropPortrait", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropPortrait = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance642, create_fragment642, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropPortrait",
      options,
      id: create_fragment642.name
    });
  }
};
var MdCropPortrait_default = MdCropPortrait;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropRotate.svelte
var file643 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropRotate.svelte";
function create_default_slot643(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.47 21.49C4.2 19.93 1.86 16.76 1.5 13H0c.51 6.16 5.66 11 11.95 11 .23 0 .44-.02.66-.03L8.8 20.15l-1.33 1.34zM12.05 0c-.23 0-.44.02-.66.04l3.81 3.81 1.33-1.33C19.8 4.07 22.14 7.24 22.5 11H24c-.51-6.16-5.66-11-11.95-11zM16 14h2V8c0-1.11-.9-2-2-2h-6v2h6v6zm-8 2V4H6v2H4v2h2v8c0 1.1.89 2 2 2h8v2h2v-2h2v-2H8z");
      add_location(path, file643, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot643.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment643(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot643] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment643.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance643($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropRotate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropRotate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance643, create_fragment643, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropRotate",
      options,
      id: create_fragment643.name
    });
  }
};
var MdCropRotate_default = MdCropRotate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropSquare.svelte
var file644 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCropSquare.svelte";
function create_default_slot644(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H6V6h12v12z");
      add_location(path, file644, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot644.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment644(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot644] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment644.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance644($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCropSquare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCropSquare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance644, create_fragment644, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCropSquare",
      options,
      id: create_fragment644.name
    });
  }
};
var MdCropSquare_default = MdCropSquare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDehaze.svelte
var file645 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDehaze.svelte";
function create_default_slot645(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 15.5v2h20v-2H2zm0-5v2h20v-2H2zm0-5v2h20v-2H2z");
      add_location(path, file645, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot645.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment645(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot645] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment645.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance645($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDehaze", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDehaze = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance645, create_fragment645, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDehaze",
      options,
      id: create_fragment645.name
    });
  }
};
var MdDehaze_default = MdDehaze;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDetails.svelte
var file646 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDetails.svelte";
function create_default_slot646(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 4l9 16 9-16H3zm3.38 2h11.25L12 16 6.38 6z");
      add_location(path, file646, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot646.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment646(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot646] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment646.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance646($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDetails", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDetails = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance646, create_fragment646, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDetails",
      options,
      id: create_fragment646.name
    });
  }
};
var MdDetails_default = MdDetails;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEdit.svelte
var file647 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEdit.svelte";
function create_default_slot647(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z");
      add_location(path, file647, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot647.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment647(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot647] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment647.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance647($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEdit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEdit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance647, create_fragment647, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEdit",
      options,
      id: create_fragment647.name
    });
  }
};
var MdEdit_default = MdEdit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposure.svelte
var file648 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposure.svelte";
function create_default_slot648(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 17v2h2v-2h2v-2h-2v-2h-2v2h-2v2h2zm5-15H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM5 5h6v2H5V5zm15 15H4L20 4v16z");
      add_location(path, file648, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot648.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment648(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot648] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment648.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance648($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExposure", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExposure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance648, create_fragment648, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExposure",
      options,
      id: create_fragment648.name
    });
  }
};
var MdExposure_default = MdExposure;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposureNeg1.svelte
var file649 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposureNeg1.svelte";
function create_default_slot649(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 11v2h8v-2H4zm15 7h-2V7.38L14 8.4V6.7L18.7 5h.3v13z");
      add_location(path, file649, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot649.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment649(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot649] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment649.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance649($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExposureNeg1", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExposureNeg1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance649, create_fragment649, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExposureNeg1",
      options,
      id: create_fragment649.name
    });
  }
};
var MdExposureNeg1_default = MdExposureNeg1;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposureNeg2.svelte
var file650 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposureNeg2.svelte";
function create_default_slot650(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.05 16.29l2.86-3.07c.38-.39.72-.79 1.04-1.18.32-.39.59-.78.82-1.17.23-.39.41-.78.54-1.17s.19-.79.19-1.18c0-.53-.09-1.02-.27-1.46-.18-.44-.44-.81-.78-1.11-.34-.31-.77-.54-1.26-.71-.51-.16-1.08-.24-1.72-.24-.69 0-1.31.11-1.85.32-.54.21-1 .51-1.36.88-.37.37-.65.8-.84 1.3-.18.47-.27.97-.28 1.5h2.14c.01-.31.05-.6.13-.87.09-.29.23-.54.4-.75.18-.21.41-.37.68-.49.27-.12.6-.18.96-.18.31 0 .58.05.81.15.23.1.43.25.59.43.16.18.28.4.37.65.08.25.13.52.13.81 0 .22-.03.43-.08.65-.06.22-.15.45-.29.7-.14.25-.32.53-.56.83-.23.3-.52.65-.88 1.03l-4.17 4.55V18H21v-1.71h-5.95zM2 11v2h8v-2H2z");
      add_location(path, file650, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot650.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment650(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot650] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment650.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance650($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExposureNeg2", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExposureNeg2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance650, create_fragment650, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExposureNeg2",
      options,
      id: create_fragment650.name
    });
  }
};
var MdExposureNeg2_default = MdExposureNeg2;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposurePlus1.svelte
var file651 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposurePlus1.svelte";
function create_default_slot651(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 7H8v4H4v2h4v4h2v-4h4v-2h-4V7zm10 11h-2V7.38L15 8.4V6.7L19.7 5h.3v13z");
      add_location(path, file651, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot651.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment651(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot651] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment651.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance651($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExposurePlus1", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExposurePlus1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance651, create_fragment651, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExposurePlus1",
      options,
      id: create_fragment651.name
    });
  }
};
var MdExposurePlus1_default = MdExposurePlus1;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposurePlus2.svelte
var file652 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposurePlus2.svelte";
function create_default_slot652(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.05 16.29l2.86-3.07c.38-.39.72-.79 1.04-1.18.32-.39.59-.78.82-1.17.23-.39.41-.78.54-1.17.13-.39.19-.79.19-1.18 0-.53-.09-1.02-.27-1.46-.18-.44-.44-.81-.78-1.11-.34-.31-.77-.54-1.26-.71-.51-.16-1.08-.24-1.72-.24-.69 0-1.31.11-1.85.32-.54.21-1 .51-1.36.88-.37.37-.65.8-.84 1.3-.18.47-.27.97-.28 1.5h2.14c.01-.31.05-.6.13-.87.09-.29.23-.54.4-.75.18-.21.41-.37.68-.49.27-.12.6-.18.96-.18.31 0 .58.05.81.15.23.1.43.25.59.43.16.18.28.4.37.65.08.25.13.52.13.81 0 .22-.03.43-.08.65-.06.22-.15.45-.29.7-.14.25-.32.53-.56.83-.23.3-.52.65-.88 1.03l-4.17 4.55V18H22v-1.71h-5.95zM8 7H6v4H2v2h4v4h2v-4h4v-2H8V7z");
      add_location(path, file652, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot652.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment652(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot652] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment652.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance652($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExposurePlus2", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExposurePlus2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance652, create_fragment652, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExposurePlus2",
      options,
      id: create_fragment652.name
    });
  }
};
var MdExposurePlus2_default = MdExposurePlus2;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposureZero.svelte
var file653 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExposureZero.svelte";
function create_default_slot653(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.14 12.5c0 1-.1 1.85-.3 2.55-.2.7-.48 1.27-.83 1.7-.36.44-.79.75-1.3.95-.51.2-1.07.3-1.7.3-.62 0-1.18-.1-1.69-.3-.51-.2-.95-.51-1.31-.95-.36-.44-.65-1.01-.85-1.7-.2-.7-.3-1.55-.3-2.55v-2.04c0-1 .1-1.85.3-2.55.2-.7.48-1.26.84-1.69.36-.43.8-.74 1.31-.93C10.81 5.1 11.38 5 12 5c.63 0 1.19.1 1.7.29.51.19.95.5 1.31.93.36.43.64.99.84 1.69.2.7.3 1.54.3 2.55v2.04zm-2.11-2.36c0-.64-.05-1.18-.13-1.62-.09-.44-.22-.79-.4-1.06-.17-.27-.39-.46-.64-.58-.25-.13-.54-.19-.86-.19-.32 0-.61.06-.86.18s-.47.31-.64.58c-.17.27-.31.62-.4 1.06s-.13.98-.13 1.62v2.67c0 .64.05 1.18.14 1.62.09.45.23.81.4 1.09s.39.48.64.61.54.19.87.19c.33 0 .62-.06.87-.19s.46-.33.63-.61c.17-.28.3-.64.39-1.09.09-.45.13-.99.13-1.62v-2.66z");
      add_location(path, file653, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot653.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment653(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot653] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment653.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance653($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExposureZero", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExposureZero = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance653, create_fragment653, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExposureZero",
      options,
      id: create_fragment653.name
    });
  }
};
var MdExposureZero_default = MdExposureZero;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter1.svelte
var file654 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter1.svelte";
function create_default_slot654(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm11 10h2V5h-4v2h2v8zm7-14H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z");
      add_location(path, file654, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot654.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment654(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot654] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment654.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance654($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter1", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance654, create_fragment654, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter1",
      options,
      id: create_fragment654.name
    });
  }
};
var MdFilter1_default = MdFilter1;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter2.svelte
var file655 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter2.svelte";
function create_default_slot655(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-4-4h-4v-2h2c1.1 0 2-.89 2-2V7c0-1.11-.9-2-2-2h-4v2h4v2h-2c-1.1 0-2 .89-2 2v4h6v-2z");
      add_location(path, file655, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot655.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment655(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot655] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment655.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance655($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter2", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance655, create_fragment655, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter2",
      options,
      id: create_fragment655.name
    });
  }
};
var MdFilter2_default = MdFilter2;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter.svelte
var file656 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter.svelte";
function create_default_slot656(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.96 10.29l-2.75 3.54-1.96-2.36L8.5 15h11l-3.54-4.71zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z");
      add_location(path, file656, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot656.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment656(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot656] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment656.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance656($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance656, create_fragment656, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter",
      options,
      id: create_fragment656.name
    });
  }
};
var MdFilter_default = MdFilter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter3.svelte
var file657 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter3.svelte";
function create_default_slot657(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm14 8v-1.5c0-.83-.67-1.5-1.5-1.5.83 0 1.5-.67 1.5-1.5V7c0-1.11-.9-2-2-2h-4v2h4v2h-2v2h2v2h-4v2h4c1.1 0 2-.89 2-2z");
      add_location(path, file657, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot657.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment657(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot657] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment657.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance657($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter3", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance657, create_fragment657, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter3",
      options,
      id: create_fragment657.name
    });
  }
};
var MdFilter3_default = MdFilter3;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter4.svelte
var file658 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter4.svelte";
function create_default_slot658(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm12 10h2V5h-2v4h-2V5h-2v6h4v4zm6-14H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z");
      add_location(path, file658, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot658.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment658(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot658] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment658.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance658($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter4", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter4 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance658, create_fragment658, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter4",
      options,
      id: create_fragment658.name
    });
  }
};
var MdFilter4_default = MdFilter4;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter5.svelte
var file659 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter5.svelte";
function create_default_slot659(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 1H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zM3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm14 8v-2c0-1.11-.9-2-2-2h-2V7h4V5h-6v6h4v2h-4v2h4c1.1 0 2-.89 2-2z");
      add_location(path, file659, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot659.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment659(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot659] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment659.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance659($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter5", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance659, create_fragment659, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter5",
      options,
      id: create_fragment659.name
    });
  }
};
var MdFilter5_default = MdFilter5;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter6.svelte
var file660 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter6.svelte";
function create_default_slot660(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-8-2h2c1.1 0 2-.89 2-2v-2c0-1.11-.9-2-2-2h-2V7h4V5h-4c-1.1 0-2 .89-2 2v6c0 1.11.9 2 2 2zm0-4h2v2h-2v-2z");
      add_location(path, file660, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot660.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment660(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot660] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment660.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance660($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter6", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter6 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance660, create_fragment660, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter6",
      options,
      id: create_fragment660.name
    });
  }
};
var MdFilter6_default = MdFilter6;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter7.svelte
var file661 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter7.svelte";
function create_default_slot661(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-8-2l4-8V5h-6v2h4l-4 8h2z");
      add_location(path, file661, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot661.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment661(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot661] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment661.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance661($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter7", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter7 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance661, create_fragment661, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter7",
      options,
      id: create_fragment661.name
    });
  }
};
var MdFilter7_default = MdFilter7;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter8.svelte
var file662 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter8.svelte";
function create_default_slot662(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zm-8-2h2c1.1 0 2-.89 2-2v-1.5c0-.83-.67-1.5-1.5-1.5.83 0 1.5-.67 1.5-1.5V7c0-1.11-.9-2-2-2h-2c-1.1 0-2 .89-2 2v1.5c0 .83.67 1.5 1.5 1.5-.83 0-1.5.67-1.5 1.5V13c0 1.11.9 2 2 2zm0-8h2v2h-2V7zm0 4h2v2h-2v-2z");
      add_location(path, file662, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot662.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment662(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot662] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment662.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance662($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter8", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter8 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance662, create_fragment662, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter8",
      options,
      id: create_fragment662.name
    });
  }
};
var MdFilter8_default = MdFilter8;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter9.svelte
var file663 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter9.svelte";
function create_default_slot663(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14zM15 5h-2c-1.1 0-2 .89-2 2v2c0 1.11.9 2 2 2h2v2h-4v2h4c1.1 0 2-.89 2-2V7c0-1.11-.9-2-2-2zm0 4h-2V7h2v2z");
      add_location(path, file663, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot663.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment663(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot663] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment663.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance663($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter9", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter9 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance663, create_fragment663, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter9",
      options,
      id: create_fragment663.name
    });
  }
};
var MdFilter9_default = MdFilter9;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter9Plus.svelte
var file664 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilter9Plus.svelte";
function create_default_slot664(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm11 7V8c0-1.11-.9-2-2-2h-1c-1.1 0-2 .89-2 2v1c0 1.11.9 2 2 2h1v1H9v2h3c1.1 0 2-.89 2-2zm-3-3V8h1v1h-1zm10-8H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 8h-2V7h-2v2h-2v2h2v2h2v-2h2v6H7V3h14v6z");
      add_location(path, file664, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot664.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment664(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot664] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment664.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance664($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilter9Plus", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilter9Plus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance664, create_fragment664, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilter9Plus",
      options,
      id: create_fragment664.name
    });
  }
};
var MdFilter9Plus_default = MdFilter9Plus;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterBAndW.svelte
var file665 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterBAndW.svelte";
function create_default_slot665(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16l-7-8v8H5l7-8V5h7v14z");
      add_location(path, file665, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot665.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment665(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot665] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment665.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance665($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterBAndW", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterBAndW = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance665, create_fragment665, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterBAndW",
      options,
      id: create_fragment665.name
    });
  }
};
var MdFilterBAndW_default = MdFilterBAndW;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterCenterFocus.svelte
var file666 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterCenterFocus.svelte";
function create_default_slot666(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 15H3v4c0 1.1.9 2 2 2h4v-2H5v-4zM5 5h4V3H5c-1.1 0-2 .9-2 2v4h2V5zm14-2h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm0 16h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zM12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
      add_location(path, file666, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot666.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment666(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot666] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment666.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance666($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterCenterFocus", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterCenterFocus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance666, create_fragment666, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterCenterFocus",
      options,
      id: create_fragment666.name
    });
  }
};
var MdFilterCenterFocus_default = MdFilterCenterFocus;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterDrama.svelte
var file667 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterDrama.svelte";
function create_default_slot667(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.61 5.64 5.36 8.04 2.35 8.36 0 10.9 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4h2c0-2.76-1.86-5.08-4.4-5.78C8.61 6.88 10.2 6 12 6c3.03 0 5.5 2.47 5.5 5.5v.5H19c1.65 0 3 1.35 3 3s-1.35 3-3 3z");
      add_location(path, file667, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot667.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment667(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot667] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment667.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance667($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterDrama", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterDrama = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance667, create_fragment667, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterDrama",
      options,
      id: create_fragment667.name
    });
  }
};
var MdFilterDrama_default = MdFilterDrama;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterFrames.svelte
var file668 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterFrames.svelte";
function create_default_slot668(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4h-4l-4-4-4 4H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H4V6h4.52l3.52-3.5L15.52 6H20v14zM18 8H6v10h12");
      add_location(path, file668, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot668.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment668(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot668] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment668.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance668($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterFrames", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterFrames = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance668, create_fragment668, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterFrames",
      options,
      id: create_fragment668.name
    });
  }
};
var MdFilterFrames_default = MdFilterFrames;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterHdr.svelte
var file669 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterHdr.svelte";
function create_default_slot669(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z");
      add_location(path, file669, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot669.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment669(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot669] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment669.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance669($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterHdr", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterHdr = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance669, create_fragment669, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterHdr",
      options,
      id: create_fragment669.name
    });
  }
};
var MdFilterHdr_default = MdFilterHdr;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterNone.svelte
var file670 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterNone.svelte";
function create_default_slot670(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5H1v16c0 1.1.9 2 2 2h16v-2H3V5zm18-4H7c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zm0 16H7V3h14v14z");
      add_location(path, file670, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot670.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment670(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot670] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment670.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance670($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterNone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterNone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance670, create_fragment670, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterNone",
      options,
      id: create_fragment670.name
    });
  }
};
var MdFilterNone_default = MdFilterNone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterTiltShift.svelte
var file671 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterTiltShift.svelte";
function create_default_slot671(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 4.07V2.05c-2.01.2-3.84 1-5.32 2.21L7.1 5.69c1.11-.86 2.44-1.44 3.9-1.62zm7.32.19C16.84 3.05 15.01 2.25 13 2.05v2.02c1.46.18 2.79.76 3.9 1.62l1.42-1.43zM19.93 11h2.02c-.2-2.01-1-3.84-2.21-5.32L18.31 7.1c.86 1.11 1.44 2.44 1.62 3.9zM5.69 7.1L4.26 5.68C3.05 7.16 2.25 8.99 2.05 11h2.02c.18-1.46.76-2.79 1.62-3.9zM4.07 13H2.05c.2 2.01 1 3.84 2.21 5.32l1.43-1.43c-.86-1.1-1.44-2.43-1.62-3.89zM15 12c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3 3-1.34 3-3zm3.31 4.9l1.43 1.43c1.21-1.48 2.01-3.32 2.21-5.32h-2.02c-.18 1.45-.76 2.78-1.62 3.89zM13 19.93v2.02c2.01-.2 3.84-1 5.32-2.21l-1.43-1.43c-1.1.86-2.43 1.44-3.89 1.62zm-7.32-.19C7.16 20.95 9 21.75 11 21.95v-2.02c-1.46-.18-2.79-.76-3.9-1.62l-1.42 1.43z");
      add_location(path, file671, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot671.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment671(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot671] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment671.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance671($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterTiltShift", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterTiltShift = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance671, create_fragment671, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterTiltShift",
      options,
      id: create_fragment671.name
    });
  }
};
var MdFilterTiltShift_default = MdFilterTiltShift;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterVintage.svelte
var file672 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFilterVintage.svelte";
function create_default_slot672(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.7 12.4c-.28-.16-.57-.29-.86-.4.29-.11.58-.24.86-.4 1.92-1.11 2.99-3.12 3-5.19-1.79-1.03-4.07-1.11-6 0-.28.16-.54.35-.78.54.05-.31.08-.63.08-.95 0-2.22-1.21-4.15-3-5.19C10.21 1.85 9 3.78 9 6c0 .32.03.64.08.95-.24-.2-.5-.39-.78-.55-1.92-1.11-4.2-1.03-6 0 0 2.07 1.07 4.08 3 5.19.28.16.57.29.86.4-.29.11-.58.24-.86.4-1.92 1.11-2.99 3.12-3 5.19 1.79 1.03 4.07 1.11 6 0 .28-.16.54-.35.78-.54-.05.32-.08.64-.08.96 0 2.22 1.21 4.15 3 5.19 1.79-1.04 3-2.97 3-5.19 0-.32-.03-.64-.08-.95.24.2.5.38.78.54 1.92 1.11 4.2 1.03 6 0-.01-2.07-1.08-4.08-3-5.19zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z");
      add_location(path, file672, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot672.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment672(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot672] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment672.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance672($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFilterVintage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFilterVintage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance672, create_fragment672, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFilterVintage",
      options,
      id: create_fragment672.name
    });
  }
};
var MdFilterVintage_default = MdFilterVintage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlare.svelte
var file673 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlare.svelte";
function create_default_slot673(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 11H1v2h6v-2zm2.17-3.24L7.05 5.64 5.64 7.05l2.12 2.12 1.41-1.41zM13 1h-2v6h2V1zm5.36 6.05l-1.41-1.41-2.12 2.12 1.41 1.41 2.12-2.12zM17 11v2h6v-2h-6zm-5-2c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zm2.83 7.24l2.12 2.12 1.41-1.41-2.12-2.12-1.41 1.41zm-9.19.71l1.41 1.41 2.12-2.12-1.41-1.41-2.12 2.12zM11 23h2v-6h-2v6z");
      add_location(path, file673, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot673.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment673(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot673] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment673.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance673($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance673, create_fragment673, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlare",
      options,
      id: create_fragment673.name
    });
  }
};
var MdFlare_default = MdFlare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlashAuto.svelte
var file674 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlashAuto.svelte";
function create_default_slot674(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 2v12h3v9l7-12H9l4-9H3zm16 0h-2l-3.2 9h1.9l.7-2h3.2l.7 2h1.9L19 2zm-2.15 5.65L18 4l1.15 3.65h-2.3z");
      add_location(path, file674, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot674.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment674(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot674] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment674.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance674($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlashAuto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlashAuto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance674, create_fragment674, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlashAuto",
      options,
      id: create_fragment674.name
    });
  }
};
var MdFlashAuto_default = MdFlashAuto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlashOff.svelte
var file675 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlashOff.svelte";
function create_default_slot675(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.27 3L2 4.27l5 5V13h3v9l3.58-6.14L17.73 20 19 18.73 3.27 3zM17 10h-4l4-8H7v2.18l8.46 8.46L17 10z");
      add_location(path, file675, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot675.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment675(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot675] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment675.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance675($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlashOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlashOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance675, create_fragment675, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlashOff",
      options,
      id: create_fragment675.name
    });
  }
};
var MdFlashOff_default = MdFlashOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlashOn.svelte
var file676 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlashOn.svelte";
function create_default_slot676(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 2v11h3v9l7-12h-4l4-8z");
      add_location(path, file676, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot676.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment676(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot676] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment676.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance676($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlashOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlashOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance676, create_fragment676, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlashOn",
      options,
      id: create_fragment676.name
    });
  }
};
var MdFlashOn_default = MdFlashOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlip.svelte
var file677 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlip.svelte";
function create_default_slot677(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z");
      add_location(path, file677, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot677.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment677(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot677] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment677.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance677($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlip", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance677, create_fragment677, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlip",
      options,
      id: create_fragment677.name
    });
  }
};
var MdFlip_default = MdFlip;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGradient.svelte
var file678 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGradient.svelte";
function create_default_slot678(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 9h2v2h-2zm-2 2h2v2H9zm4 0h2v2h-2zm2-2h2v2h-2zM7 9h2v2H7zm12-6H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 18H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm2-7h-2v2h2v2h-2v-2h-2v2h-2v-2h-2v2H9v-2H7v2H5v-2h2v-2H5V5h14v6z");
      add_location(path, file678, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot678.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment678(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot678] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment678.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance678($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGradient", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGradient = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance678, create_fragment678, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGradient",
      options,
      id: create_fragment678.name
    });
  }
};
var MdGradient_default = MdGradient;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGrain.svelte
var file679 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGrain.svelte";
function create_default_slot679(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-4 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file679, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot679.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment679(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot679] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment679.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance679($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGrain", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGrain = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance679, create_fragment679, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGrain",
      options,
      id: create_fragment679.name
    });
  }
};
var MdGrain_default = MdGrain;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGridOff.svelte
var file680 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGridOff.svelte";
function create_default_slot680(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 4v1.45l2 2V4h4v4h-3.45l2 2H14v1.45l2 2V10h4v4h-3.45l2 2H20v1.45l2 2V4c0-1.1-.9-2-2-2H4.55l2 2H8zm8 0h4v4h-4V4zM1.27 1.27L0 2.55l2 2V20c0 1.1.9 2 2 2h15.46l2 2 1.27-1.27L1.27 1.27zM10 12.55L11.45 14H10v-1.45zm-6-6L5.45 8H4V6.55zM8 20H4v-4h4v4zm0-6H4v-4h3.45l.55.55V14zm6 6h-4v-4h3.45l.55.54V20zm2 0v-1.46L17.46 20H16z");
      add_location(path, file680, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot680.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment680(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot680] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment680.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance680($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGridOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGridOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance680, create_fragment680, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGridOff",
      options,
      id: create_fragment680.name
    });
  }
};
var MdGridOff_default = MdGridOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGridOn.svelte
var file681 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGridOn.svelte";
function create_default_slot681(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z");
      add_location(path, file681, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot681.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment681(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot681] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment681.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance681($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGridOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGridOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance681, create_fragment681, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGridOn",
      options,
      id: create_fragment681.name
    });
  }
};
var MdGridOn_default = MdGridOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrOff.svelte
var file682 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrOff.svelte";
function create_default_slot682(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.5 15v-2h1.1l.9 2H21l-.9-2.1c.5-.2.9-.8.9-1.4v-1c0-.8-.7-1.5-1.5-1.5H16v4.9l1.1 1.1h.4zm0-4.5h2v1h-2v-1zm-4.5 0v.4l1.5 1.5v-1.9c0-.8-.7-1.5-1.5-1.5h-1.9l1.5 1.5h.4zm-3.5-1l-7-7-1.1 1L6.9 9h-.4v2h-2V9H3v6h1.5v-2.5h2V15H8v-4.9l1.5 1.5V15h3.4l7.6 7.6 1.1-1.1-12.1-12z");
      add_location(path, file682, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot682.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment682(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot682] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment682.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance682($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHdrOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHdrOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance682, create_fragment682, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHdrOff",
      options,
      id: create_fragment682.name
    });
  }
};
var MdHdrOff_default = MdHdrOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrOn.svelte
var file683 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrOn.svelte";
function create_default_slot683(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 11.5v-1c0-.8-.7-1.5-1.5-1.5H16v6h1.5v-2h1.1l.9 2H21l-.9-2.1c.5-.3.9-.8.9-1.4zm-1.5 0h-2v-1h2v1zm-13-.5h-2V9H3v6h1.5v-2.5h2V15H8V9H6.5v2zM13 9H9.5v6H13c.8 0 1.5-.7 1.5-1.5v-3c0-.8-.7-1.5-1.5-1.5zm0 4.5h-2v-3h2v3z");
      add_location(path, file683, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot683.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment683(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot683] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment683.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance683($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHdrOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHdrOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance683, create_fragment683, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHdrOn",
      options,
      id: create_fragment683.name
    });
  }
};
var MdHdrOn_default = MdHdrOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrStrong.svelte
var file684 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrStrong.svelte";
function create_default_slot684(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zM5 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file684, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot684.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment684(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot684] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment684.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance684($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHdrStrong", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHdrStrong = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance684, create_fragment684, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHdrStrong",
      options,
      id: create_fragment684.name
    });
  }
};
var MdHdrStrong_default = MdHdrStrong;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrWeak.svelte
var file685 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHdrWeak.svelte";
function create_default_slot685(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm12-2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z");
      add_location(path, file685, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot685.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment685(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot685] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment685.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance685($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHdrWeak", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHdrWeak = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance685, create_fragment685, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHdrWeak",
      options,
      id: create_fragment685.name
    });
  }
};
var MdHdrWeak_default = MdHdrWeak;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHealing.svelte
var file686 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHealing.svelte";
function create_default_slot686(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.73 12.02l3.98-3.98c.39-.39.39-1.02 0-1.41l-4.34-4.34c-.39-.39-1.02-.39-1.41 0l-3.98 3.98L8 2.29C7.8 2.1 7.55 2 7.29 2c-.25 0-.51.1-.7.29L2.25 6.63c-.39.39-.39 1.02 0 1.41l3.98 3.98L2.25 16c-.39.39-.39 1.02 0 1.41l4.34 4.34c.39.39 1.02.39 1.41 0l3.98-3.98 3.98 3.98c.2.2.45.29.71.29.26 0 .51-.1.71-.29l4.34-4.34c.39-.39.39-1.02 0-1.41l-3.99-3.98zM12 9c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-4.71 1.96L3.66 7.34l3.63-3.63 3.62 3.62-3.62 3.63zM10 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm2 2c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm2-4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2.66 9.34l-3.63-3.62 3.63-3.63 3.62 3.62-3.62 3.63z");
      add_location(path, file686, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot686.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment686(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot686] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment686.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance686($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHealing", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHealing = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance686, create_fragment686, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHealing",
      options,
      id: create_fragment686.name
    });
  }
};
var MdHealing_default = MdHealing;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImage.svelte
var file687 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImage.svelte";
function create_default_slot687(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z");
      add_location(path, file687, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot687.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment687(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot687] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment687.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance687($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdImage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance687, create_fragment687, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdImage",
      options,
      id: create_fragment687.name
    });
  }
};
var MdImage_default = MdImage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImageAspectRatio.svelte
var file688 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdImageAspectRatio.svelte";
function create_default_slot688(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 10h-2v2h2v-2zm0 4h-2v2h2v-2zm-8-4H6v2h2v-2zm4 0h-2v2h2v-2zm8-6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V6h16v12z");
      add_location(path, file688, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot688.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment688(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot688] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment688.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance688($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdImageAspectRatio", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdImageAspectRatio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance688, create_fragment688, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdImageAspectRatio",
      options,
      id: create_fragment688.name
    });
  }
};
var MdImageAspectRatio_default = MdImageAspectRatio;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdIso.svelte
var file689 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdIso.svelte";
function create_default_slot689(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5.5 7.5h2v-2H9v2h2V9H9v2H7.5V9h-2V7.5zM19 19H5L19 5v14zm-2-2v-1.5h-5V17h5z");
      add_location(path, file689, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot689.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment689(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot689] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment689.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance689($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdIso", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdIso = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance689, create_fragment689, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdIso",
      options,
      id: create_fragment689.name
    });
  }
};
var MdIso_default = MdIso;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLandscape.svelte
var file690 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLandscape.svelte";
function create_default_slot690(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z");
      add_location(path, file690, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot690.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment690(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot690] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment690.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance690($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLandscape", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLandscape = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance690, create_fragment690, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLandscape",
      options,
      id: create_fragment690.name
    });
  }
};
var MdLandscape_default = MdLandscape;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLeakAdd.svelte
var file691 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLeakAdd.svelte";
function create_default_slot691(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 3H3v3c1.66 0 3-1.34 3-3zm8 0h-2c0 4.97-4.03 9-9 9v2c6.08 0 11-4.93 11-11zm-4 0H8c0 2.76-2.24 5-5 5v2c3.87 0 7-3.13 7-7zm0 18h2c0-4.97 4.03-9 9-9v-2c-6.07 0-11 4.93-11 11zm8 0h3v-3c-1.66 0-3 1.34-3 3zm-4 0h2c0-2.76 2.24-5 5-5v-2c-3.87 0-7 3.13-7 7z");
      add_location(path, file691, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot691.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment691(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot691] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment691.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance691($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLeakAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLeakAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance691, create_fragment691, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLeakAdd",
      options,
      id: create_fragment691.name
    });
  }
};
var MdLeakAdd_default = MdLeakAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLeakRemove.svelte
var file692 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLeakRemove.svelte";
function create_default_slot692(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 3H8c0 .37-.04.72-.12 1.06l1.59 1.59C9.81 4.84 10 3.94 10 3zM3 4.27l2.84 2.84C5.03 7.67 4.06 8 3 8v2c1.61 0 3.09-.55 4.27-1.46L8.7 9.97C7.14 11.24 5.16 12 3 12v2c2.71 0 5.19-.99 7.11-2.62l2.5 2.5C10.99 15.81 10 18.29 10 21h2c0-2.16.76-4.14 2.03-5.69l1.43 1.43C14.55 17.91 14 19.39 14 21h2c0-1.06.33-2.03.89-2.84L19.73 21 21 19.73 4.27 3 3 4.27zM14 3h-2c0 1.5-.37 2.91-1.02 4.16l1.46 1.46C13.42 6.98 14 5.06 14 3zm5.94 13.12c.34-.08.69-.12 1.06-.12v-2c-.94 0-1.84.19-2.66.52l1.6 1.6zm-4.56-4.56l1.46 1.46C18.09 12.37 19.5 12 21 12v-2c-2.06 0-3.98.58-5.62 1.56z");
      add_location(path, file692, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot692.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment692(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot692] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment692.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance692($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLeakRemove", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLeakRemove = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance692, create_fragment692, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLeakRemove",
      options,
      id: create_fragment692.name
    });
  }
};
var MdLeakRemove_default = MdLeakRemove;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLens.svelte
var file693 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLens.svelte";
function create_default_slot693(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z");
      add_location(path, file693, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot693.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment693(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot693] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment693.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance693($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLens", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLens = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance693, create_fragment693, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLens",
      options,
      id: create_fragment693.name
    });
  }
};
var MdLens_default = MdLens;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLinkedCamera.svelte
var file694 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLinkedCamera.svelte";
function create_default_slot694(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file694, 4, 10, 151);
      attr_dev(path1, "d", "M16 3.33c2.58 0 4.67 2.09 4.67 4.67H22c0-3.31-2.69-6-6-6v1.33M16 6c1.11 0 2 .89 2 2h1.33c0-1.84-1.49-3.33-3.33-3.33V6");
      add_location(path1, file694, 5, 0, 174);
      attr_dev(path2, "d", "M17 9c0-1.11-.89-2-2-2V4H9L7.17 6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9h-5zm-5 10c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z");
      add_location(path2, file694, 6, 0, 305);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot694.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment694(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot694] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment694.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance694($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLinkedCamera", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLinkedCamera = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance694, create_fragment694, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLinkedCamera",
      options,
      id: create_fragment694.name
    });
  }
};
var MdLinkedCamera_default = MdLinkedCamera;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks.svelte
var file695 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks.svelte";
function create_default_slot695(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 10c-3.86 0-7 3.14-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.86-3.14-7-7-7zm0-4C5.93 6 1 10.93 1 17h2c0-4.96 4.04-9 9-9s9 4.04 9 9h2c0-6.07-4.93-11-11-11z");
      add_location(path, file695, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot695.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment695(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot695] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment695.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance695($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooks", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooks = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance695, create_fragment695, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooks",
      options,
      id: create_fragment695.name
    });
  }
};
var MdLooks_default = MdLooks;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks3.svelte
var file696 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks3.svelte";
function create_default_slot696(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.01 3h-14c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 7.5c0 .83-.67 1.5-1.5 1.5.83 0 1.5.67 1.5 1.5V15c0 1.11-.9 2-2 2h-4v-2h4v-2h-2v-2h2V9h-4V7h4c1.1 0 2 .89 2 2v1.5z");
      add_location(path, file696, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot696.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment696(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot696] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment696.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance696($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooks3", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooks3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance696, create_fragment696, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooks3",
      options,
      id: create_fragment696.name
    });
  }
};
var MdLooks3_default = MdLooks3;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks4.svelte
var file697 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks4.svelte";
function create_default_slot697(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 14h-2v-4H9V7h2v4h2V7h2v10z");
      add_location(path, file697, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot697.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment697(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot697] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment697.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance697($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooks4", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooks4 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance697, create_fragment697, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooks4",
      options,
      id: create_fragment697.name
    });
  }
};
var MdLooks4_default = MdLooks4;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks5.svelte
var file698 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks5.svelte";
function create_default_slot698(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h2c1.1 0 2 .89 2 2v2c0 1.11-.9 2-2 2H9v-2h4v-2H9V7h6v2z");
      add_location(path, file698, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot698.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment698(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot698] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment698.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance698($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooks5", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooks5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance698, create_fragment698, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooks5",
      options,
      id: create_fragment698.name
    });
  }
};
var MdLooks5_default = MdLooks5;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks6.svelte
var file699 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooks6.svelte";
function create_default_slot699(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 15h2v-2h-2v2zm8-12H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 6h-4v2h2c1.1 0 2 .89 2 2v2c0 1.11-.9 2-2 2h-2c-1.1 0-2-.89-2-2V9c0-1.11.9-2 2-2h4v2z");
      add_location(path, file699, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot699.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment699(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot699] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment699.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance699($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooks6", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooks6 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance699, create_fragment699, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooks6",
      options,
      id: create_fragment699.name
    });
  }
};
var MdLooks6_default = MdLooks6;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooksOne.svelte
var file700 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooksOne.svelte";
function create_default_slot700(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14h-2V9h-2V7h4v10z");
      add_location(path, file700, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot700.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment700(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot700] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment700.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance700($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooksOne", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooksOne = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance700, create_fragment700, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooksOne",
      options,
      id: create_fragment700.name
    });
  }
};
var MdLooksOne_default = MdLooksOne;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooksTwo.svelte
var file701 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLooksTwo.svelte";
function create_default_slot701(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4 8c0 1.11-.9 2-2 2h-2v2h4v2H9v-4c0-1.11.9-2 2-2h2V9H9V7h4c1.1 0 2 .89 2 2v2z");
      add_location(path, file701, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot701.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment701(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot701] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment701.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance701($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLooksTwo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLooksTwo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance701, create_fragment701, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLooksTwo",
      options,
      id: create_fragment701.name
    });
  }
};
var MdLooksTwo_default = MdLooksTwo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLoupe.svelte
var file702 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLoupe.svelte";
function create_default_slot702(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10h8c1.1 0 2-.9 2-2v-8c0-5.51-4.49-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file702, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot702.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment702(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot702] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment702.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance702($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLoupe", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLoupe = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance702, create_fragment702, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLoupe",
      options,
      id: create_fragment702.name
    });
  }
};
var MdLoupe_default = MdLoupe;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMonochromePhotos.svelte
var file703 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMonochromePhotos.svelte";
function create_default_slot703(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 5h-3.2L15 3H9L7.2 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14h-8v-1c-2.8 0-5-2.2-5-5s2.2-5 5-5V7h8v12zm-3-6c0-2.8-2.2-5-5-5v1.8c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2V18c2.8 0 5-2.2 5-5zm-8.2 0c0 1.8 1.4 3.2 3.2 3.2V9.8c-1.8 0-3.2 1.4-3.2 3.2z");
      add_location(path, file703, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot703.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment703(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot703] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment703.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance703($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMonochromePhotos", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMonochromePhotos = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance703, create_fragment703, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMonochromePhotos",
      options,
      id: create_fragment703.name
    });
  }
};
var MdMonochromePhotos_default = MdMonochromePhotos;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMovieCreation.svelte
var file704 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMovieCreation.svelte";
function create_default_slot704(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z");
      add_location(path, file704, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot704.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment704(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot704] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment704.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance704($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMovieCreation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMovieCreation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance704, create_fragment704, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMovieCreation",
      options,
      id: create_fragment704.name
    });
  }
};
var MdMovieCreation_default = MdMovieCreation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMovieFilter.svelte
var file705 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMovieFilter.svelte";
function create_default_slot705(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 4l2 3h-3l-2-3h-2l2 3h-3l-2-3H8l2 3H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4zm-6.75 11.25L10 18l-1.25-2.75L6 14l2.75-1.25L10 10l1.25 2.75L14 14l-2.75 1.25zm5.69-3.31L16 14l-.94-2.06L13 11l2.06-.94L16 8l.94 2.06L19 11l-2.06.94z");
      add_location(path, file705, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot705.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment705(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot705] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment705.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance705($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMovieFilter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMovieFilter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance705, create_fragment705, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMovieFilter",
      options,
      id: create_fragment705.name
    });
  }
};
var MdMovieFilter_default = MdMovieFilter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMusicNote.svelte
var file706 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMusicNote.svelte";
function create_default_slot706(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z");
      add_location(path, file706, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot706.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment706(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot706] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment706.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance706($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMusicNote", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMusicNote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance706, create_fragment706, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMusicNote",
      options,
      id: create_fragment706.name
    });
  }
};
var MdMusicNote_default = MdMusicNote;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNature.svelte
var file707 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNature.svelte";
function create_default_slot707(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 16.12c3.47-.41 6.17-3.36 6.17-6.95 0-3.87-3.13-7-7-7s-7 3.13-7 7c0 3.47 2.52 6.34 5.83 6.89V20H5v2h14v-2h-6v-3.88z");
      add_location(path, file707, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot707.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment707(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot707] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment707.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance707($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNature", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNature = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance707, create_fragment707, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNature",
      options,
      id: create_fragment707.name
    });
  }
};
var MdNature_default = MdNature;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNaturePeople.svelte
var file708 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNaturePeople.svelte";
function create_default_slot708(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.17 9.17c0-3.87-3.13-7-7-7s-7 3.13-7 7c0 3.47 2.52 6.34 5.83 6.89V20H6v-3h1v-4c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v4h1v5h16v-2h-3v-3.88c3.47-.41 6.17-3.36 6.17-6.95zM4.5 11c.83 0 1.5-.67 1.5-1.5S5.33 8 4.5 8 3 8.67 3 9.5 3.67 11 4.5 11z");
      add_location(path, file708, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot708.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment708(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot708] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment708.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance708($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNaturePeople", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNaturePeople = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance708, create_fragment708, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNaturePeople",
      options,
      id: create_fragment708.name
    });
  }
};
var MdNaturePeople_default = MdNaturePeople;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNavigateBefore.svelte
var file709 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNavigateBefore.svelte";
function create_default_slot709(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z");
      add_location(path, file709, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot709.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment709(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot709] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment709.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance709($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNavigateBefore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNavigateBefore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance709, create_fragment709, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNavigateBefore",
      options,
      id: create_fragment709.name
    });
  }
};
var MdNavigateBefore_default = MdNavigateBefore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNavigateNext.svelte
var file710 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNavigateNext.svelte";
function create_default_slot710(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z");
      add_location(path, file710, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot710.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment710(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot710] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment710.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance710($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNavigateNext", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNavigateNext = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance710, create_fragment710, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNavigateNext",
      options,
      id: create_fragment710.name
    });
  }
};
var MdNavigateNext_default = MdNavigateNext;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPalette.svelte
var file711 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPalette.svelte";
function create_default_slot711(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.5-.67 1.5-1.5 0-.39-.15-.74-.39-1.01-.23-.26-.38-.61-.38-.99 0-.83.67-1.5 1.5-1.5H16c2.76 0 5-2.24 5-5 0-4.42-4.03-8-9-8zm-5.5 9c-.83 0-1.5-.67-1.5-1.5S5.67 9 6.5 9 8 9.67 8 10.5 7.33 12 6.5 12zm3-4C8.67 8 8 7.33 8 6.5S8.67 5 9.5 5s1.5.67 1.5 1.5S10.33 8 9.5 8zm5 0c-.83 0-1.5-.67-1.5-1.5S13.67 5 14.5 5s1.5.67 1.5 1.5S15.33 8 14.5 8zm3 4c-.83 0-1.5-.67-1.5-1.5S16.67 9 17.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file711, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot711.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment711(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot711] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment711.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance711($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPalette", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPalette = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance711, create_fragment711, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPalette",
      options,
      id: create_fragment711.name
    });
  }
};
var MdPalette_default = MdPalette;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanorama.svelte
var file712 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanorama.svelte";
function create_default_slot712(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 18V6c0-1.1-.9-2-2-2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zM8.5 12.5l2.5 3.01L14.5 11l4.5 6H5l3.5-4.5z");
      add_location(path, file712, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot712.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment712(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot712] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment712.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance712($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPanorama", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPanorama = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance712, create_fragment712, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPanorama",
      options,
      id: create_fragment712.name
    });
  }
};
var MdPanorama_default = MdPanorama;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaFishEye.svelte
var file713 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaFishEye.svelte";
function create_default_slot713(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z");
      add_location(path, file713, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot713.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment713(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot713] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment713.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance713($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPanoramaFishEye", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPanoramaFishEye = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance713, create_fragment713, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPanoramaFishEye",
      options,
      id: create_fragment713.name
    });
  }
};
var MdPanoramaFishEye_default = MdPanoramaFishEye;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaHorizontal.svelte
var file714 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaHorizontal.svelte";
function create_default_slot714(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6.54v10.91c-2.6-.77-5.28-1.16-8-1.16-2.72 0-5.4.39-8 1.16V6.54c2.6.77 5.28 1.16 8 1.16 2.72.01 5.4-.38 8-1.16M21.43 4c-.1 0-.2.02-.31.06C18.18 5.16 15.09 5.7 12 5.7c-3.09 0-6.18-.55-9.12-1.64-.11-.04-.22-.06-.31-.06-.34 0-.57.23-.57.63v14.75c0 .39.23.62.57.62.1 0 .2-.02.31-.06 2.94-1.1 6.03-1.64 9.12-1.64 3.09 0 6.18.55 9.12 1.64.11.04.21.06.31.06.33 0 .57-.23.57-.63V4.63c0-.4-.24-.63-.57-.63z");
      add_location(path, file714, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot714.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment714(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot714] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment714.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance714($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPanoramaHorizontal", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPanoramaHorizontal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance714, create_fragment714, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPanoramaHorizontal",
      options,
      id: create_fragment714.name
    });
  }
};
var MdPanoramaHorizontal_default = MdPanoramaHorizontal;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaVertical.svelte
var file715 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaVertical.svelte";
function create_default_slot715(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.94 21.12c-1.1-2.94-1.64-6.03-1.64-9.12 0-3.09.55-6.18 1.64-9.12.04-.11.06-.22.06-.31 0-.34-.23-.57-.63-.57H4.63c-.4 0-.63.23-.63.57 0 .1.02.2.06.31C5.16 5.82 5.71 8.91 5.71 12c0 3.09-.55 6.18-1.64 9.12-.05.11-.07.22-.07.31 0 .33.23.57.63.57h14.75c.39 0 .63-.24.63-.57-.01-.1-.03-.2-.07-.31zM6.54 20c.77-2.6 1.16-5.28 1.16-8 0-2.72-.39-5.4-1.16-8h10.91c-.77 2.6-1.16 5.28-1.16 8 0 2.72.39 5.4 1.16 8H6.54z");
      add_location(path, file715, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot715.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment715(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot715] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment715.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance715($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPanoramaVertical", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPanoramaVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance715, create_fragment715, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPanoramaVertical",
      options,
      id: create_fragment715.name
    });
  }
};
var MdPanoramaVertical_default = MdPanoramaVertical;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaWideAngle.svelte
var file716 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPanoramaWideAngle.svelte";
function create_default_slot716(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 6c2.45 0 4.71.2 7.29.64.47 1.78.71 3.58.71 5.36 0 1.78-.24 3.58-.71 5.36-2.58.44-4.84.64-7.29.64s-4.71-.2-7.29-.64C4.24 15.58 4 13.78 4 12c0-1.78.24-3.58.71-5.36C7.29 6.2 9.55 6 12 6m0-2c-2.73 0-5.22.24-7.95.72l-.93.16-.25.9C2.29 7.85 2 9.93 2 12s.29 4.15.87 6.22l.25.89.93.16c2.73.49 5.22.73 7.95.73s5.22-.24 7.95-.72l.93-.16.25-.89c.58-2.08.87-4.16.87-6.23s-.29-4.15-.87-6.22l-.25-.89-.93-.16C17.22 4.24 14.73 4 12 4z");
      add_location(path, file716, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot716.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment716(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot716] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment716.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance716($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPanoramaWideAngle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPanoramaWideAngle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance716, create_fragment716, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPanoramaWideAngle",
      options,
      id: create_fragment716.name
    });
  }
};
var MdPanoramaWideAngle_default = MdPanoramaWideAngle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoto.svelte
var file717 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoto.svelte";
function create_default_slot717(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z");
      add_location(path, file717, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot717.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment717(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot717] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment717.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance717($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance717, create_fragment717, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoto",
      options,
      id: create_fragment717.name
    });
  }
};
var MdPhoto_default = MdPhoto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoAlbum.svelte
var file718 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoAlbum.svelte";
function create_default_slot718(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4zm0 15l3-3.86 2.14 2.58 3-3.86L18 19H6z");
      add_location(path, file718, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot718.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment718(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot718] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment718.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance718($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoAlbum", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoAlbum = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance718, create_fragment718, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoAlbum",
      options,
      id: create_fragment718.name
    });
  }
};
var MdPhotoAlbum_default = MdPhotoAlbum;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoCamera.svelte
var file719 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoCamera.svelte";
function create_default_slot719(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file719, 4, 10, 151);
      attr_dev(path1, "d", "M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z");
      add_location(path1, file719, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot719.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment719(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot719] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment719.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance719($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoCamera", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoCamera = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance719, create_fragment719, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoCamera",
      options,
      id: create_fragment719.name
    });
  }
};
var MdPhotoCamera_default = MdPhotoCamera;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoFilter.svelte
var file720 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoFilter.svelte";
function create_default_slot720(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.02 10v9H5V5h9V3H5.02c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-9h-2zM17 10l.94-2.06L20 7l-2.06-.94L17 4l-.94 2.06L14 7l2.06.94zm-3.75.75L12 8l-1.25 2.75L8 12l2.75 1.25L12 16l1.25-2.75L16 12z");
      add_location(path, file720, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot720.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment720(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot720] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment720.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance720($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoFilter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoFilter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance720, create_fragment720, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoFilter",
      options,
      id: create_fragment720.name
    });
  }
};
var MdPhotoFilter_default = MdPhotoFilter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoLibrary.svelte
var file721 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoLibrary.svelte";
function create_default_slot721(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z");
      add_location(path, file721, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot721.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment721(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot721] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment721.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance721($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoLibrary", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoLibrary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance721, create_fragment721, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoLibrary",
      options,
      id: create_fragment721.name
    });
  }
};
var MdPhotoLibrary_default = MdPhotoLibrary;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoSizeSelectActual.svelte
var file722 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoSizeSelectActual.svelte";
function create_default_slot722(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3C2 3 1 4 1 5v14c0 1.1.9 2 2 2h18c1 0 2-1 2-2V5c0-1-1-2-2-2zM5 17l3.5-4.5 2.5 3.01L14.5 11l4.5 6H5z");
      add_location(path, file722, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot722.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment722(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot722] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment722.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance722($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoSizeSelectActual", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoSizeSelectActual = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance722, create_fragment722, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoSizeSelectActual",
      options,
      id: create_fragment722.name
    });
  }
};
var MdPhotoSizeSelectActual_default = MdPhotoSizeSelectActual;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoSizeSelectLarge.svelte
var file723 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoSizeSelectLarge.svelte";
function create_default_slot723(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 15h2v2h-2v-2zm0-4h2v2h-2v-2zm2 8h-2v2c1 0 2-1 2-2zM13 3h2v2h-2V3zm8 4h2v2h-2V7zm0-4v2h2c0-1-1-2-2-2zM1 7h2v2H1V7zm16-4h2v2h-2V3zm0 16h2v2h-2v-2zM3 3C2 3 1 4 1 5h2V3zm6 0h2v2H9V3zM5 3h2v2H5V3zm-4 8v8c0 1.1.9 2 2 2h12V11H1zm2 8l2.5-3.21 1.79 2.15 2.5-3.22L13 19H3z");
      add_location(path, file723, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot723.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment723(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot723] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment723.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance723($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoSizeSelectLarge", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoSizeSelectLarge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance723, create_fragment723, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoSizeSelectLarge",
      options,
      id: create_fragment723.name
    });
  }
};
var MdPhotoSizeSelectLarge_default = MdPhotoSizeSelectLarge;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoSizeSelectSmall.svelte
var file724 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhotoSizeSelectSmall.svelte";
function create_default_slot724(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 15h-2v2h2v-2zm0-4h-2v2h2v-2zm0 8h-2v2c1 0 2-1 2-2zM15 3h-2v2h2V3zm8 4h-2v2h2V7zm-2-4v2h2c0-1-1-2-2-2zM3 21h8v-6H1v4c0 1.1.9 2 2 2zM3 7H1v2h2V7zm12 12h-2v2h2v-2zm4-16h-2v2h2V3zm0 16h-2v2h2v-2zM3 3C2 3 1 4 1 5h2V3zm0 8H1v2h2v-2zm8-8H9v2h2V3zM7 3H5v2h2V3z");
      add_location(path, file724, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot724.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment724(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot724] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment724.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance724($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhotoSizeSelectSmall", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhotoSizeSelectSmall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance724, create_fragment724, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhotoSizeSelectSmall",
      options,
      id: create_fragment724.name
    });
  }
};
var MdPhotoSizeSelectSmall_default = MdPhotoSizeSelectSmall;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPictureAsPdf.svelte
var file725 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPictureAsPdf.svelte";
function create_default_slot725(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z");
      add_location(path, file725, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot725.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment725(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot725] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment725.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance725($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPictureAsPdf", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPictureAsPdf = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance725, create_fragment725, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPictureAsPdf",
      options,
      id: create_fragment725.name
    });
  }
};
var MdPictureAsPdf_default = MdPictureAsPdf;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPortrait.svelte
var file726 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPortrait.svelte";
function create_default_slot726(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 12.25c1.24 0 2.25-1.01 2.25-2.25S13.24 7.75 12 7.75 9.75 8.76 9.75 10s1.01 2.25 2.25 2.25zm4.5 4c0-1.5-3-2.25-4.5-2.25s-4.5.75-4.5 2.25V17h9v-.75zM19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z");
      add_location(path, file726, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot726.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment726(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot726] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment726.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance726($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPortrait", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPortrait = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance726, create_fragment726, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPortrait",
      options,
      id: create_fragment726.name
    });
  }
};
var MdPortrait_default = MdPortrait;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveRedEye.svelte
var file727 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRemoveRedEye.svelte";
function create_default_slot727(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
      add_location(path, file727, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot727.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment727(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot727] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment727.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance727($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRemoveRedEye", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRemoveRedEye = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance727, create_fragment727, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRemoveRedEye",
      options,
      id: create_fragment727.name
    });
  }
};
var MdRemoveRedEye_default = MdRemoveRedEye;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRotate90DegreesCcw.svelte
var file728 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRotate90DegreesCcw.svelte";
function create_default_slot728(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.34 6.41L.86 12.9l6.49 6.48 6.49-6.48-6.5-6.49zM3.69 12.9l3.66-3.66L11 12.9l-3.66 3.66-3.65-3.66zm15.67-6.26C17.61 4.88 15.3 4 13 4V.76L8.76 5 13 9.24V6c1.79 0 3.58.68 4.95 2.05 2.73 2.73 2.73 7.17 0 9.9C16.58 19.32 14.79 20 13 20c-.97 0-1.94-.21-2.84-.61l-1.49 1.49C10.02 21.62 11.51 22 13 22c2.3 0 4.61-.88 6.36-2.64 3.52-3.51 3.52-9.21 0-12.72z");
      add_location(path, file728, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot728.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment728(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot728] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment728.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance728($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRotate90DegreesCcw", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRotate90DegreesCcw = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance728, create_fragment728, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRotate90DegreesCcw",
      options,
      id: create_fragment728.name
    });
  }
};
var MdRotate90DegreesCcw_default = MdRotate90DegreesCcw;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRotateLeft.svelte
var file729 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRotateLeft.svelte";
function create_default_slot729(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z");
      add_location(path, file729, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot729.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment729(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot729] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment729.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance729($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRotateLeft", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRotateLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance729, create_fragment729, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRotateLeft",
      options,
      id: create_fragment729.name
    });
  }
};
var MdRotateLeft_default = MdRotateLeft;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRotateRight.svelte
var file730 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRotateRight.svelte";
function create_default_slot730(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z");
      add_location(path, file730, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot730.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment730(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot730] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment730.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance730($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRotateRight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRotateRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance730, create_fragment730, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRotateRight",
      options,
      id: create_fragment730.name
    });
  }
};
var MdRotateRight_default = MdRotateRight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSlideshow.svelte
var file731 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSlideshow.svelte";
function create_default_slot731(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 8v8l5-4-5-4zm9-5H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z");
      add_location(path, file731, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot731.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment731(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot731] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment731.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance731($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSlideshow", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSlideshow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance731, create_fragment731, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSlideshow",
      options,
      id: create_fragment731.name
    });
  }
};
var MdSlideshow_default = MdSlideshow;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStraighten.svelte
var file732 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStraighten.svelte";
function create_default_slot732(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H3V8h2v4h2V8h2v4h2V8h2v4h2V8h2v4h2V8h2v8z");
      add_location(path, file732, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot732.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment732(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot732] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment732.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance732($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStraighten", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStraighten = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance732, create_fragment732, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStraighten",
      options,
      id: create_fragment732.name
    });
  }
};
var MdStraighten_default = MdStraighten;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStyle.svelte
var file733 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStyle.svelte";
function create_default_slot733(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2.53 19.65l1.34.56v-9.03l-2.43 5.86c-.41 1.02.08 2.19 1.09 2.61zm19.5-3.7L17.07 3.98c-.31-.75-1.04-1.21-1.81-1.23-.26 0-.53.04-.79.15L7.1 5.95c-.75.31-1.21 1.03-1.23 1.8-.01.27.04.54.15.8l4.96 11.97c.31.76 1.05 1.22 1.83 1.23.26 0 .52-.05.77-.15l7.36-3.05c1.02-.42 1.51-1.59 1.09-2.6zM7.88 8.75c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-2 11c0 1.1.9 2 2 2h1.45l-3.45-8.34v6.34z");
      add_location(path, file733, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot733.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment733(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot733] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment733.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance733($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStyle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStyle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance733, create_fragment733, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStyle",
      options,
      id: create_fragment733.name
    });
  }
};
var MdStyle_default = MdStyle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwitchCamera.svelte
var file734 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwitchCamera.svelte";
function create_default_slot734(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5l3.5 3.5-3.5 3.5z");
      add_location(path, file734, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot734.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment734(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot734] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment734.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance734($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSwitchCamera", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSwitchCamera = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance734, create_fragment734, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSwitchCamera",
      options,
      id: create_fragment734.name
    });
  }
};
var MdSwitchCamera_default = MdSwitchCamera;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwitchVideo.svelte
var file735 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSwitchVideo.svelte";
function create_default_slot735(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 9.5V6c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-3.5l4 4v-13l-4 4zm-5 6V13H7v2.5L3.5 12 7 8.5V11h6V8.5l3.5 3.5-3.5 3.5z");
      add_location(path, file735, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot735.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment735(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot735] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment735.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance735($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSwitchVideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSwitchVideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance735, create_fragment735, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSwitchVideo",
      options,
      id: create_fragment735.name
    });
  }
};
var MdSwitchVideo_default = MdSwitchVideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTagFaces.svelte
var file736 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTagFaces.svelte";
function create_default_slot736(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z");
      add_location(path, file736, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot736.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment736(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot736] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment736.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance736($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTagFaces", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTagFaces = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance736, create_fragment736, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTagFaces",
      options,
      id: create_fragment736.name
    });
  }
};
var MdTagFaces_default = MdTagFaces;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTexture.svelte
var file737 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTexture.svelte";
function create_default_slot737(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.51 3.08L3.08 19.51c.09.34.27.65.51.9.25.24.56.42.9.51L20.93 4.49c-.19-.69-.73-1.23-1.42-1.41zM11.88 3L3 11.88v2.83L14.71 3h-2.83zM5 3c-1.1 0-2 .9-2 2v2l4-4H5zm14 18c.55 0 1.05-.22 1.41-.59.37-.36.59-.86.59-1.41v-2l-4 4h2zm-9.71 0h2.83L21 12.12V9.29L9.29 21z");
      add_location(path, file737, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot737.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment737(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot737] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment737.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance737($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTexture", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTexture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance737, create_fragment737, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTexture",
      options,
      id: create_fragment737.name
    });
  }
};
var MdTexture_default = MdTexture;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimelapse.svelte
var file738 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimelapse.svelte";
function create_default_slot738(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.24 7.76C15.07 6.59 13.54 6 12 6v6l-4.24 4.24c2.34 2.34 6.14 2.34 8.49 0 2.34-2.34 2.34-6.14-.01-8.48zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z");
      add_location(path, file738, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot738.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment738(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot738] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment738.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance738($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimelapse", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimelapse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance738, create_fragment738, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimelapse",
      options,
      id: create_fragment738.name
    });
  }
};
var MdTimelapse_default = MdTimelapse;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimer10.svelte
var file739 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimer10.svelte";
function create_default_slot739(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M0 7.72V9.4l3-1V18h2V6h-.25L0 7.72zm23.78 6.65c-.14-.28-.35-.53-.63-.74-.28-.21-.61-.39-1.01-.53s-.85-.27-1.35-.38c-.35-.07-.64-.15-.87-.23-.23-.08-.41-.16-.55-.25-.14-.09-.23-.19-.28-.3-.05-.11-.08-.24-.08-.39 0-.14.03-.28.09-.41.06-.13.15-.25.27-.34.12-.1.27-.18.45-.24s.4-.09.64-.09c.25 0 .47.04.66.11.19.07.35.17.48.29.13.12.22.26.29.42.06.16.1.32.1.49h1.95c0-.39-.08-.75-.24-1.09-.16-.34-.39-.63-.69-.88-.3-.25-.66-.44-1.09-.59C21.49 9.07 21 9 20.46 9c-.51 0-.98.07-1.39.21-.41.14-.77.33-1.06.57-.29.24-.51.52-.67.84-.16.32-.23.65-.23 1.01s.08.69.23.96c.15.28.36.52.64.73.27.21.6.38.98.53.38.14.81.26 1.27.36.39.08.71.17.95.26s.43.19.57.29c.13.1.22.22.27.34.05.12.07.25.07.39 0 .32-.13.57-.4.77-.27.2-.66.29-1.17.29-.22 0-.43-.02-.64-.08-.21-.05-.4-.13-.56-.24-.17-.11-.3-.26-.41-.44-.11-.18-.17-.41-.18-.67h-1.89c0 .36.08.71.24 1.05.16.34.39.65.7.93.31.27.69.49 1.15.66.46.17.98.25 1.58.25.53 0 1.01-.06 1.44-.19.43-.13.8-.31 1.11-.54.31-.23.54-.51.71-.83.17-.32.25-.67.25-1.06-.02-.4-.09-.74-.24-1.02zm-9.96-7.32c-.34-.4-.75-.7-1.23-.88-.47-.18-1.01-.27-1.59-.27-.58 0-1.11.09-1.59.27-.48.18-.89.47-1.23.88-.34.41-.6.93-.79 1.59-.18.65-.28 1.45-.28 2.39v1.92c0 .94.09 1.74.28 2.39.19.66.45 1.19.8 1.6.34.41.75.71 1.23.89.48.18 1.01.28 1.59.28.59 0 1.12-.09 1.59-.28.48-.18.88-.48 1.22-.89.34-.41.6-.94.78-1.6.18-.65.28-1.45.28-2.39v-1.92c0-.94-.09-1.74-.28-2.39-.18-.66-.44-1.19-.78-1.59zm-.92 6.17c0 .6-.04 1.11-.12 1.53-.08.42-.2.76-.36 1.02-.16.26-.36.45-.59.57-.23.12-.51.18-.82.18-.3 0-.58-.06-.82-.18s-.44-.31-.6-.57c-.16-.26-.29-.6-.38-1.02-.09-.42-.13-.93-.13-1.53v-2.5c0-.6.04-1.11.13-1.52.09-.41.21-.74.38-1 .16-.25.36-.43.6-.55.24-.11.51-.17.81-.17.31 0 .58.06.81.17.24.11.44.29.6.55.16.25.29.58.37.99.08.41.13.92.13 1.52v2.51z");
      add_location(path, file739, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot739.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment739(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot739] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment739.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance739($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimer10", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimer10 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance739, create_fragment739, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimer10",
      options,
      id: create_fragment739.name
    });
  }
};
var MdTimer10_default = MdTimer10;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimer.svelte
var file740 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimer.svelte";
function create_default_slot740(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file740, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot740.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment740(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot740] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment740.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance740($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance740, create_fragment740, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimer",
      options,
      id: create_fragment740.name
    });
  }
};
var MdTimer_default = MdTimer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimer3.svelte
var file741 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimer3.svelte";
function create_default_slot741(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.61 12.97c-.16-.24-.36-.46-.62-.65-.25-.19-.56-.35-.93-.48.3-.14.57-.3.8-.5.23-.2.42-.41.57-.64.15-.23.27-.46.34-.71.08-.24.11-.49.11-.73 0-.55-.09-1.04-.28-1.46-.18-.42-.44-.77-.78-1.06-.33-.28-.73-.5-1.2-.64-.45-.13-.97-.2-1.53-.2-.55 0-1.06.08-1.52.24-.47.17-.87.4-1.2.69-.33.29-.6.63-.78 1.03-.2.39-.29.83-.29 1.29h1.98c0-.26.05-.49.14-.69.09-.2.22-.38.38-.52.17-.14.36-.25.58-.33.22-.08.46-.12.73-.12.61 0 1.06.16 1.36.47.3.31.44.75.44 1.32 0 .27-.04.52-.12.74-.08.22-.21.41-.38.57-.17.16-.38.28-.63.37-.25.09-.55.13-.89.13H6.72v1.57H7.9c.34 0 .64.04.91.11.27.08.5.19.69.35.19.16.34.36.44.61.1.24.16.54.16.87 0 .62-.18 1.09-.53 1.42-.35.33-.84.49-1.45.49-.29 0-.56-.04-.8-.13-.24-.08-.44-.2-.61-.36-.17-.16-.3-.34-.39-.56-.09-.22-.14-.46-.14-.72H4.19c0 .55.11 1.03.32 1.45.21.42.5.77.86 1.05s.77.49 1.24.63.96.21 1.48.21c.57 0 1.09-.08 1.58-.23.49-.15.91-.38 1.26-.68.36-.3.64-.66.84-1.1.2-.43.3-.93.3-1.48 0-.29-.04-.58-.11-.86-.08-.25-.19-.51-.35-.76zm9.26 1.4c-.14-.28-.35-.53-.63-.74-.28-.21-.61-.39-1.01-.53s-.85-.27-1.35-.38c-.35-.07-.64-.15-.87-.23-.23-.08-.41-.16-.55-.25-.14-.09-.23-.19-.28-.3-.05-.11-.08-.24-.08-.39s.03-.28.09-.41c.06-.13.15-.25.27-.34.12-.1.27-.18.45-.24s.4-.09.64-.09c.25 0 .47.04.66.11.19.07.35.17.48.29.13.12.22.26.29.42.06.16.1.32.1.49h1.95c0-.39-.08-.75-.24-1.09-.16-.34-.39-.63-.69-.88-.3-.25-.66-.44-1.09-.59-.43-.15-.92-.22-1.46-.22-.51 0-.98.07-1.39.21-.41.14-.77.33-1.06.57-.29.24-.51.52-.67.84-.16.32-.23.65-.23 1.01s.08.68.23.96c.15.28.37.52.64.73.27.21.6.38.98.53.38.14.81.26 1.27.36.39.08.71.17.95.26s.43.19.57.29c.13.1.22.22.27.34.05.12.07.25.07.39 0 .32-.13.57-.4.77-.27.2-.66.29-1.17.29-.22 0-.43-.02-.64-.08-.21-.05-.4-.13-.56-.24-.17-.11-.3-.26-.41-.44-.11-.18-.17-.41-.18-.67h-1.89c0 .36.08.71.24 1.05.16.34.39.65.7.93.31.27.69.49 1.15.66.46.17.98.25 1.58.25.53 0 1.01-.06 1.44-.19.43-.13.8-.31 1.11-.54.31-.23.54-.51.71-.83.17-.32.25-.67.25-1.06-.02-.4-.09-.74-.24-1.02z");
      add_location(path, file741, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot741.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment741(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot741] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment741.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance741($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimer3", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimer3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance741, create_fragment741, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimer3",
      options,
      id: create_fragment741.name
    });
  }
};
var MdTimer3_default = MdTimer3;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimerOff.svelte
var file742 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimerOff.svelte";
function create_default_slot742(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.04 4.55l-1.42 1.42C16.07 4.74 14.12 4 12 4c-1.83 0-3.53.55-4.95 1.48l1.46 1.46C9.53 6.35 10.73 6 12 6c3.87 0 7 3.13 7 7 0 1.27-.35 2.47-.94 3.49l1.45 1.45C20.45 16.53 21 14.83 21 13c0-2.12-.74-4.07-1.97-5.61l1.42-1.42-1.41-1.42zM15 1H9v2h6V1zm-4 8.44l2 2V8h-2v1.44zM3.02 4L1.75 5.27 4.5 8.03C3.55 9.45 3 11.16 3 13c0 4.97 4.02 9 9 9 1.84 0 3.55-.55 4.98-1.5l2.5 2.5 1.27-1.27-7.71-7.71L3.02 4zM12 20c-3.87 0-7-3.13-7-7 0-1.28.35-2.48.95-3.52l9.56 9.56c-1.03.61-2.23.96-3.51.96z");
      add_location(path, file742, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot742.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment742(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot742] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment742.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance742($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimerOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimerOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance742, create_fragment742, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimerOff",
      options,
      id: create_fragment742.name
    });
  }
};
var MdTimerOff_default = MdTimerOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTonality.svelte
var file743 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTonality.svelte";
function create_default_slot743(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93s3.05-7.44 7-7.93v15.86zm2-15.86c1.03.13 2 .45 2.87.93H13v-.93zM13 7h5.24c.25.31.48.65.68 1H13V7zm0 3h6.74c.08.33.15.66.19 1H13v-1zm0 9.93V19h2.87c-.87.48-1.84.8-2.87.93zM18.24 17H13v-1h5.92c-.2.35-.43.69-.68 1zm1.5-3H13v-1h6.93c-.04.34-.11.67-.19 1z");
      add_location(path, file743, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot743.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment743(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot743] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment743.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance743($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTonality", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTonality = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance743, create_fragment743, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTonality",
      options,
      id: create_fragment743.name
    });
  }
};
var MdTonality_default = MdTonality;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTransform.svelte
var file744 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTransform.svelte";
function create_default_slot744(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 18v-2H8V4h2L7 1 4 4h2v2H2v2h4v8c0 1.1.9 2 2 2h8v2h-2l3 3 3-3h-2v-2h4zM10 8h6v6h2V8c0-1.1-.9-2-2-2h-6v2z");
      add_location(path, file744, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot744.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment744(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot744] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment744.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance744($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTransform", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTransform = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance744, create_fragment744, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTransform",
      options,
      id: create_fragment744.name
    });
  }
};
var MdTransform_default = MdTransform;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTune.svelte
var file745 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTune.svelte";
function create_default_slot745(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z");
      add_location(path, file745, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot745.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment745(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot745] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment745.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance745($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTune", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTune = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance745, create_fragment745, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTune",
      options,
      id: create_fragment745.name
    });
  }
};
var MdTune_default = MdTune;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewComfy.svelte
var file746 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewComfy.svelte";
function create_default_slot746(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9h4V5H3v4zm0 5h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zM8 9h4V5H8v4zm5-4v4h4V5h-4zm5 9h4v-4h-4v4zM3 19h4v-4H3v4zm5 0h4v-4H8v4zm5 0h4v-4h-4v4zm5 0h4v-4h-4v4zm0-14v4h4V5h-4z");
      add_location(path, file746, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot746.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment746(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot746] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment746.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance746($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewComfy", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewComfy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance746, create_fragment746, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewComfy",
      options,
      id: create_fragment746.name
    });
  }
};
var MdViewComfy_default = MdViewComfy;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewCompact.svelte
var file747 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdViewCompact.svelte";
function create_default_slot747(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 19h6v-7H3v7zm7 0h12v-7H10v7zM3 5v6h19V5H3z");
      add_location(path, file747, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot747.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment747(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot747] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment747.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance747($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdViewCompact", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdViewCompact = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance747, create_fragment747, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdViewCompact",
      options,
      id: create_fragment747.name
    });
  }
};
var MdViewCompact_default = MdViewCompact;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVignette.svelte
var file748 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVignette.svelte";
function create_default_slot748(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 15c-4.42 0-8-2.69-8-6s3.58-6 8-6 8 2.69 8 6-3.58 6-8 6z");
      add_location(path, file748, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot748.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment748(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot748] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment748.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance748($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVignette", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVignette = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance748, create_fragment748, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVignette",
      options,
      id: create_fragment748.name
    });
  }
};
var MdVignette_default = MdVignette;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbAuto.svelte
var file749 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbAuto.svelte";
function create_default_slot749(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.85 12.65h2.3L8 9l-1.15 3.65zM22 7l-1.2 6.29L19.3 7h-1.6l-1.49 6.29L15 7h-.76C12.77 5.17 10.53 4 8 4c-4.42 0-8 3.58-8 8s3.58 8 8 8c3.13 0 5.84-1.81 7.15-4.43l.1.43H17l1.5-6.1L20 16h1.75l2.05-9H22zm-11.7 9l-.7-2H6.4l-.7 2H3.8L7 7h2l3.2 9h-1.9z");
      add_location(path, file749, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot749.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment749(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot749] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment749.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance749($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWbAuto", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWbAuto = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance749, create_fragment749, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWbAuto",
      options,
      id: create_fragment749.name
    });
  }
};
var MdWbAuto_default = MdWbAuto;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbCloudy.svelte
var file750 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbCloudy.svelte";
function create_default_slot750(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.36 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.64-4.96z");
      add_location(path, file750, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot750.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment750(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot750] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment750.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance750($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWbCloudy", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWbCloudy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance750, create_fragment750, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWbCloudy",
      options,
      id: create_fragment750.name
    });
  }
};
var MdWbCloudy_default = MdWbCloudy;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbIncandescent.svelte
var file751 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbIncandescent.svelte";
function create_default_slot751(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.55 18.54l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8zM11 22.45h2V19.5h-2v2.95zM4 10.5H1v2h3v-2zm11-4.19V1.5H9v4.81C7.21 7.35 6 9.28 6 11.5c0 3.31 2.69 6 6 6s6-2.69 6-6c0-2.22-1.21-4.15-3-5.19zm5 4.19v2h3v-2h-3zm-2.76 7.66l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4z");
      add_location(path, file751, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot751.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment751(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot751] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment751.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance751($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWbIncandescent", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWbIncandescent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance751, create_fragment751, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWbIncandescent",
      options,
      id: create_fragment751.name
    });
  }
};
var MdWbIncandescent_default = MdWbIncandescent;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbIridescent.svelte
var file752 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbIridescent.svelte";
function create_default_slot752(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 14.5h14v-6H5v6zM11 .55V3.5h2V.55h-2zm8.04 2.5l-1.79 1.79 1.41 1.41 1.8-1.79-1.42-1.41zM13 22.45V19.5h-2v2.95h2zm7.45-3.91l-1.8-1.79-1.41 1.41 1.79 1.8 1.42-1.42zM3.55 4.46l1.79 1.79 1.41-1.41-1.79-1.79-1.41 1.41zm1.41 15.49l1.79-1.8-1.41-1.41-1.79 1.79 1.41 1.42z");
      add_location(path, file752, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot752.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment752(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot752] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment752.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance752($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWbIridescent", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWbIridescent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance752, create_fragment752, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWbIridescent",
      options,
      id: create_fragment752.name
    });
  }
};
var MdWbIridescent_default = MdWbIridescent;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbSunny.svelte
var file753 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWbSunny.svelte";
function create_default_slot753(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z");
      add_location(path, file753, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot753.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment753(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot753] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment753.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance753($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWbSunny", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWbSunny = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance753, create_fragment753, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWbSunny",
      options,
      id: create_fragment753.name
    });
  }
};
var MdWbSunny_default = MdWbSunny;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddLocation.svelte
var file754 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAddLocation.svelte";
function create_default_slot754(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm4 8h-3v3h-2v-3H8V8h3V5h2v3h3v2z");
      add_location(path, file754, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot754.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment754(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot754] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment754.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance754($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAddLocation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAddLocation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance754, create_fragment754, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAddLocation",
      options,
      id: create_fragment754.name
    });
  }
};
var MdAddLocation_default = MdAddLocation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBeenhere.svelte
var file755 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBeenhere.svelte";
function create_default_slot755(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 1H5c-1.1 0-1.99.9-1.99 2L3 15.93c0 .69.35 1.3.88 1.66L12 23l8.11-5.41c.53-.36.88-.97.88-1.66L21 3c0-1.1-.9-2-2-2zm-9 15l-5-5 1.41-1.41L10 13.17l7.59-7.59L19 7l-9 9z");
      add_location(path, file755, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot755.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment755(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot755] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment755.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance755($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBeenhere", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBeenhere = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance755, create_fragment755, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBeenhere",
      options,
      id: create_fragment755.name
    });
  }
};
var MdBeenhere_default = MdBeenhere;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirections.svelte
var file756 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirections.svelte";
function create_default_slot756(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.71 11.29l-9-9c-.39-.39-1.02-.39-1.41 0l-9 9c-.39.39-.39 1.02 0 1.41l9 9c.39.39 1.02.39 1.41 0l9-9c.39-.38.39-1.01 0-1.41zM14 14.5V12h-4v3H8v-4c0-.55.45-1 1-1h5V7.5l3.5 3.5-3.5 3.5z");
      add_location(path, file756, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot756.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment756(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot756] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment756.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance756($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirections", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirections = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance756, create_fragment756, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirections",
      options,
      id: create_fragment756.name
    });
  }
};
var MdDirections_default = MdDirections;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsBike.svelte
var file757 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsBike.svelte";
function create_default_slot757(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM5 12c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 8.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5zm5.8-10l2.4-2.4.8.8c1.3 1.3 3 2.1 5.1 2.1V9c-1.5 0-2.7-.6-3.6-1.5l-1.9-1.9c-.5-.4-1-.6-1.6-.6s-1.1.2-1.4.6L7.8 8.4c-.4.4-.6.9-.6 1.4 0 .6.2 1.1.6 1.4L11 14v5h2v-6.2l-2.2-2.3zM19 12c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 8.5c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5-1.6 3.5-3.5 3.5z");
      add_location(path, file757, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot757.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment757(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot757] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment757.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance757($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsBike", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsBike = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance757, create_fragment757, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsBike",
      options,
      id: create_fragment757.name
    });
  }
};
var MdDirectionsBike_default = MdDirectionsBike;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsBoat.svelte
var file758 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsBoat.svelte";
function create_default_slot758(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 21c-1.39 0-2.78-.47-4-1.32-2.44 1.71-5.56 1.71-8 0C6.78 20.53 5.39 21 4 21H2v2h2c1.38 0 2.74-.35 4-.99 2.52 1.29 5.48 1.29 8 0 1.26.65 2.62.99 4 .99h2v-2h-2zM3.95 19H4c1.6 0 3.02-.88 4-2 .98 1.12 2.4 2 4 2s3.02-.88 4-2c.98 1.12 2.4 2 4 2h.05l1.89-6.68c.08-.26.06-.54-.06-.78s-.34-.42-.6-.5L20 10.62V6c0-1.1-.9-2-2-2h-3V1H9v3H6c-1.1 0-2 .9-2 2v4.62l-1.29.42c-.26.08-.48.26-.6.5s-.15.52-.06.78L3.95 19zM6 6h12v3.97L12 8 6 9.97V6z");
      add_location(path, file758, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot758.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment758(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot758] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment758.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance758($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsBoat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsBoat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance758, create_fragment758, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsBoat",
      options,
      id: create_fragment758.name
    });
  }
};
var MdDirectionsBoat_default = MdDirectionsBoat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsBus.svelte
var file759 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsBus.svelte";
function create_default_slot759(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 16c0 .88.39 1.67 1 2.22V20c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h8v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.78c.61-.55 1-1.34 1-2.22V6c0-3.5-3.58-4-8-4s-8 .5-8 4v10zm3.5 1c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm9 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6H6V6h12v5z");
      add_location(path, file759, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot759.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment759(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot759] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment759.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance759($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsBus", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsBus = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance759, create_fragment759, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsBus",
      options,
      id: create_fragment759.name
    });
  }
};
var MdDirectionsBus_default = MdDirectionsBus;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsCar.svelte
var file760 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsCar.svelte";
function create_default_slot760(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z");
      add_location(path, file760, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot760.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment760(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot760] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment760.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance760($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsCar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsCar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance760, create_fragment760, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsCar",
      options,
      id: create_fragment760.name
    });
  }
};
var MdDirectionsCar_default = MdDirectionsCar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsRailway.svelte
var file761 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsRailway.svelte";
function create_default_slot761(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 15.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V5c0-3.5-3.58-4-8-4s-8 .5-8 4v10.5zm8 1.5c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6-7H6V5h12v5z");
      add_location(path, file761, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot761.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment761(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot761] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment761.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance761($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsRailway", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsRailway = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance761, create_fragment761, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsRailway",
      options,
      id: create_fragment761.name
    });
  }
};
var MdDirectionsRailway_default = MdDirectionsRailway;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsRun.svelte
var file762 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsRun.svelte";
function create_default_slot762(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13.49 5.48c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-3.6 13.9l1-4.4 2.1 2v6h2v-7.5l-2.1-2 .6-3c1.3 1.5 3.3 2.5 5.5 2.5v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1l-5.2 2.2v4.7h2v-3.4l1.8-.7-1.6 8.1-4.9-1-.4 2 7 1.4z");
      add_location(path, file762, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot762.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment762(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot762] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment762.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance762($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsRun", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsRun = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance762, create_fragment762, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsRun",
      options,
      id: create_fragment762.name
    });
  }
};
var MdDirectionsRun_default = MdDirectionsRun;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsSubway.svelte
var file763 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsSubway.svelte";
function create_default_slot763(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2c-4.42 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-6H6V6h5v5zm5.5 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6h-5V6h5v5z");
      add_location(path, file763, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot763.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment763(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot763] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment763.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance763($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsSubway", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsSubway = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance763, create_fragment763, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsSubway",
      options,
      id: create_fragment763.name
    });
  }
};
var MdDirectionsSubway_default = MdDirectionsSubway;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsTransit.svelte
var file764 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsTransit.svelte";
function create_default_slot764(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2c-4.42 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h12v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-6H6V6h5v5zm5.5 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-6h-5V6h5v5z");
      add_location(path, file764, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot764.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment764(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot764] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment764.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance764($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsTransit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsTransit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance764, create_fragment764, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsTransit",
      options,
      id: create_fragment764.name
    });
  }
};
var MdDirectionsTransit_default = MdDirectionsTransit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsWalk.svelte
var file765 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDirectionsWalk.svelte";
function create_default_slot765(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM9.8 8.9L7 23h2.1l1.8-8 2.1 2v6h2v-7.5l-2.1-2 .6-3C14.8 12 16.8 13 19 13v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1L6 8.3V13h2V9.6l1.8-.7");
      add_location(path, file765, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot765.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment765(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot765] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment765.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance765($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDirectionsWalk", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDirectionsWalk = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance765, create_fragment765, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDirectionsWalk",
      options,
      id: create_fragment765.name
    });
  }
};
var MdDirectionsWalk_default = MdDirectionsWalk;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEditLocation.svelte
var file766 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEditLocation.svelte";
function create_default_slot766(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm-1.56 10H9v-1.44l3.35-3.34 1.43 1.43L10.44 12zm4.45-4.45l-.7.7-1.44-1.44.7-.7c.15-.15.39-.15.54 0l.9.9c.15.15.15.39 0 .54z");
      add_location(path, file766, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot766.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment766(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot766] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment766.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance766($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEditLocation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEditLocation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance766, create_fragment766, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEditLocation",
      options,
      id: create_fragment766.name
    });
  }
};
var MdEditLocation_default = MdEditLocation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEvStation.svelte
var file767 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEvStation.svelte";
function create_default_slot767(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.77 7.23l.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33 0 1.38 1.12 2.5 2.5 2.5.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V9c0-.69-.28-1.32-.73-1.77zM18 10c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zM8 18v-4.5H6L10 6v5h2l-4 7z");
      add_location(path, file767, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot767.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment767(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot767] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment767.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance767($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEvStation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEvStation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance767, create_fragment767, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEvStation",
      options,
      id: create_fragment767.name
    });
  }
};
var MdEvStation_default = MdEvStation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlight.svelte
var file768 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFlight.svelte";
function create_default_slot768(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M10.18 9");
      add_location(path0, file768, 4, 10, 151);
      attr_dev(path1, "d", "M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z");
      add_location(path1, file768, 5, 0, 173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot768.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment768(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot768] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment768.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance768($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFlight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFlight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance768, create_fragment768, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFlight",
      options,
      id: create_fragment768.name
    });
  }
};
var MdFlight_default = MdFlight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHotel.svelte
var file769 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHotel.svelte";
function create_default_slot769(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 13c1.66 0 3-1.34 3-3S8.66 7 7 7s-3 1.34-3 3 1.34 3 3 3zm12-6h-8v7H3V5H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4z");
      add_location(path, file769, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot769.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment769(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot769] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment769.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance769($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHotel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHotel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance769, create_fragment769, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHotel",
      options,
      id: create_fragment769.name
    });
  }
};
var MdHotel_default = MdHotel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLayers.svelte
var file770 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLayers.svelte";
function create_default_slot770(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z");
      add_location(path, file770, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot770.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment770(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot770] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment770.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance770($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLayers", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLayers = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance770, create_fragment770, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLayers",
      options,
      id: create_fragment770.name
    });
  }
};
var MdLayers_default = MdLayers;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLayersClear.svelte
var file771 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLayersClear.svelte";
function create_default_slot771(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.81 14.99l1.19-.92-1.43-1.43-1.19.92 1.43 1.43zm-.45-4.72L21 9l-9-7-2.91 2.27 7.87 7.88 2.4-1.88zM3.27 1L2 2.27l4.22 4.22L3 9l1.63 1.27L12 16l2.1-1.63 1.43 1.43L12 18.54l-7.37-5.73L3 14.07l9 7 4.95-3.85L20.73 21 22 19.73 3.27 1z");
      add_location(path, file771, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot771.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment771(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot771] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment771.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance771($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLayersClear", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLayersClear = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance771, create_fragment771, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLayersClear",
      options,
      id: create_fragment771.name
    });
  }
};
var MdLayersClear_default = MdLayersClear;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalActivity.svelte
var file772 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalActivity.svelte";
function create_default_slot772(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 12c0-1.1.9-2 2-2V6c0-1.1-.9-2-2-2H4c-1.1 0-1.99.9-1.99 2v4c1.1 0 1.99.9 1.99 2s-.89 2-2 2v4c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-4c-1.1 0-2-.9-2-2zm-4.42 4.8L12 14.5l-3.58 2.3 1.08-4.12-3.29-2.69 4.24-.25L12 5.8l1.54 3.95 4.24.25-3.29 2.69 1.09 4.11z");
      add_location(path, file772, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot772.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment772(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot772] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment772.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance772($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalActivity", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalActivity = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance772, create_fragment772, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalActivity",
      options,
      id: create_fragment772.name
    });
  }
};
var MdLocalActivity_default = MdLocalActivity;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalAirport.svelte
var file773 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalAirport.svelte";
function create_default_slot773(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z");
      add_location(path, file773, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot773.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment773(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot773] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment773.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance773($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalAirport", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalAirport = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance773, create_fragment773, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalAirport",
      options,
      id: create_fragment773.name
    });
  }
};
var MdLocalAirport_default = MdLocalAirport;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalAtm.svelte
var file774 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalAtm.svelte";
function create_default_slot774(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 17h2v-1h1c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1h-3v-1h4V8h-2V7h-2v1h-1c-.55 0-1 .45-1 1v3c0 .55.45 1 1 1h3v1H9v2h2v1zm9-13H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4V6h16v12z");
      add_location(path, file774, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot774.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment774(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot774] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment774.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance774($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalAtm", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalAtm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance774, create_fragment774, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalAtm",
      options,
      id: create_fragment774.name
    });
  }
};
var MdLocalAtm_default = MdLocalAtm;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalBar.svelte
var file775 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalBar.svelte";
function create_default_slot775(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 5V3H3v2l8 9v5H6v2h12v-2h-5v-5l8-9zM7.43 7L5.66 5h12.69l-1.78 2H7.43z");
      add_location(path, file775, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot775.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment775(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot775] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment775.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance775($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalBar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance775, create_fragment775, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalBar",
      options,
      id: create_fragment775.name
    });
  }
};
var MdLocalBar_default = MdLocalBar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalCafe.svelte
var file776 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalCafe.svelte";
function create_default_slot776(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2c1.11 0 2-.89 2-2V5c0-1.11-.89-2-2-2zm0 5h-2V5h2v3zM2 21h18v-2H2v2z");
      add_location(path, file776, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot776.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment776(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot776] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment776.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance776($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalCafe", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalCafe = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance776, create_fragment776, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalCafe",
      options,
      id: create_fragment776.name
    });
  }
};
var MdLocalCafe_default = MdLocalCafe;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalCarWash.svelte
var file777 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalCarWash.svelte";
function create_default_slot777(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 5c.83 0 1.5-.67 1.5-1.5 0-1-1.5-2.7-1.5-2.7s-1.5 1.7-1.5 2.7c0 .83.67 1.5 1.5 1.5zm-5 0c.83 0 1.5-.67 1.5-1.5 0-1-1.5-2.7-1.5-2.7s-1.5 1.7-1.5 2.7c0 .83.67 1.5 1.5 1.5zM7 5c.83 0 1.5-.67 1.5-1.5C8.5 2.5 7 .8 7 .8S5.5 2.5 5.5 3.5C5.5 4.33 6.17 5 7 5zm11.92 3.01C18.72 7.42 18.16 7 17.5 7h-11c-.66 0-1.21.42-1.42 1.01L3 14v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 18c-.83 0-1.5-.67-1.5-1.5S5.67 15 6.5 15s1.5.67 1.5 1.5S7.33 18 6.5 18zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 13l1.5-4.5h11L19 13H5z");
      add_location(path, file777, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot777.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment777(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot777] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment777.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance777($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalCarWash", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalCarWash = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance777, create_fragment777, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalCarWash",
      options,
      id: create_fragment777.name
    });
  }
};
var MdLocalCarWash_default = MdLocalCarWash;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalConvenienceStore.svelte
var file778 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalConvenienceStore.svelte";
function create_default_slot778(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 7V4H5v3H2v13h8v-4h4v4h8V7h-3zm-8 3H9v1h2v1H8V9h2V8H8V7h3v3zm5 2h-1v-2h-2V7h1v2h1V7h1v5z");
      add_location(path, file778, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot778.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment778(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot778] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment778.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance778($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalConvenienceStore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalConvenienceStore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance778, create_fragment778, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalConvenienceStore",
      options,
      id: create_fragment778.name
    });
  }
};
var MdLocalConvenienceStore_default = MdLocalConvenienceStore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalDining.svelte
var file779 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalDining.svelte";
function create_default_slot779(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8.1 13.34l2.83-2.83L3.91 3.5c-1.56 1.56-1.56 4.09 0 5.66l4.19 4.18zm6.78-1.81c1.53.71 3.68.21 5.27-1.38 1.91-1.91 2.28-4.65.81-6.12-1.46-1.46-4.2-1.1-6.12.81-1.59 1.59-2.09 3.74-1.38 5.27L3.7 19.87l1.41 1.41L12 14.41l6.88 6.88 1.41-1.41L13.41 13l1.47-1.47z");
      add_location(path, file779, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot779.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment779(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot779] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment779.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance779($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalDining", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalDining = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance779, create_fragment779, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalDining",
      options,
      id: create_fragment779.name
    });
  }
};
var MdLocalDining_default = MdLocalDining;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalDrink.svelte
var file780 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalDrink.svelte";
function create_default_slot780(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 2l2.01 18.23C5.13 21.23 5.97 22 7 22h10c1.03 0 1.87-.77 1.99-1.77L21 2H3zm9 17c-1.66 0-3-1.34-3-3 0-2 3-5.4 3-5.4s3 3.4 3 5.4c0 1.66-1.34 3-3 3zm6.33-11H5.67l-.44-4h13.53l-.43 4z");
      add_location(path, file780, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot780.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment780(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot780] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment780.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance780($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalDrink", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalDrink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance780, create_fragment780, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalDrink",
      options,
      id: create_fragment780.name
    });
  }
};
var MdLocalDrink_default = MdLocalDrink;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalFlorist.svelte
var file781 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalFlorist.svelte";
function create_default_slot781(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 22c4.97 0 9-4.03 9-9-4.97 0-9 4.03-9 9zM5.6 10.25c0 1.38 1.12 2.5 2.5 2.5.53 0 1.01-.16 1.42-.44l-.02.19c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5l-.02-.19c.4.28.89.44 1.42.44 1.38 0 2.5-1.12 2.5-2.5 0-1-.59-1.85-1.43-2.25.84-.4 1.43-1.25 1.43-2.25 0-1.38-1.12-2.5-2.5-2.5-.53 0-1.01.16-1.42.44l.02-.19C14.5 2.12 13.38 1 12 1S9.5 2.12 9.5 3.5l.02.19c-.4-.28-.89-.44-1.42-.44-1.38 0-2.5 1.12-2.5 2.5 0 1 .59 1.85 1.43 2.25-.84.4-1.43 1.25-1.43 2.25zM12 5.5c1.38 0 2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8s1.12-2.5 2.5-2.5zM3 13c0 4.97 4.03 9 9 9 0-4.97-4.03-9-9-9z");
      add_location(path, file781, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot781.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment781(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot781] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment781.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance781($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalFlorist", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalFlorist = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance781, create_fragment781, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalFlorist",
      options,
      id: create_fragment781.name
    });
  }
};
var MdLocalFlorist_default = MdLocalFlorist;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalGasStation.svelte
var file782 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalGasStation.svelte";
function create_default_slot782(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.77 7.23l.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33 0 1.38 1.12 2.5 2.5 2.5.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V9c0-.69-.28-1.32-.73-1.77zM12 10H6V5h6v5zm6 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z");
      add_location(path, file782, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot782.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment782(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot782] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment782.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance782($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalGasStation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalGasStation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance782, create_fragment782, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalGasStation",
      options,
      id: create_fragment782.name
    });
  }
};
var MdLocalGasStation_default = MdLocalGasStation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalGroceryStore.svelte
var file783 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalGroceryStore.svelte";
function create_default_slot783(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file783, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot783.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment783(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot783] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment783.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance783($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalGroceryStore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalGroceryStore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance783, create_fragment783, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalGroceryStore",
      options,
      id: create_fragment783.name
    });
  }
};
var MdLocalGroceryStore_default = MdLocalGroceryStore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalHospital.svelte
var file784 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalHospital.svelte";
function create_default_slot784(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4v4z");
      add_location(path, file784, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot784.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment784(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot784] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment784.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance784($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalHospital", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalHospital = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance784, create_fragment784, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalHospital",
      options,
      id: create_fragment784.name
    });
  }
};
var MdLocalHospital_default = MdLocalHospital;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalHotel.svelte
var file785 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalHotel.svelte";
function create_default_slot785(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 13c1.66 0 3-1.34 3-3S8.66 7 7 7s-3 1.34-3 3 1.34 3 3 3zm12-6h-8v7H3V5H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4z");
      add_location(path, file785, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot785.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment785(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot785] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment785.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance785($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalHotel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalHotel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance785, create_fragment785, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalHotel",
      options,
      id: create_fragment785.name
    });
  }
};
var MdLocalHotel_default = MdLocalHotel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalLaundryService.svelte
var file786 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalLaundryService.svelte";
function create_default_slot786(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.17 16.83c1.56 1.56 4.1 1.56 5.66 0 1.56-1.56 1.56-4.1 0-5.66l-5.66 5.66zM18 2.01L6 2c-1.11 0-2 .89-2 2v16c0 1.11.89 2 2 2h12c1.11 0 2-.89 2-2V4c0-1.11-.89-1.99-2-1.99zM10 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM7 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm5 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z");
      add_location(path, file786, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot786.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment786(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot786] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment786.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance786($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalLaundryService", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalLaundryService = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance786, create_fragment786, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalLaundryService",
      options,
      id: create_fragment786.name
    });
  }
};
var MdLocalLaundryService_default = MdLocalLaundryService;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalLibrary.svelte
var file787 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalLibrary.svelte";
function create_default_slot787(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z");
      add_location(path, file787, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot787.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment787(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot787] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment787.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance787($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalLibrary", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalLibrary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance787, create_fragment787, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalLibrary",
      options,
      id: create_fragment787.name
    });
  }
};
var MdLocalLibrary_default = MdLocalLibrary;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalMall.svelte
var file788 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalMall.svelte";
function create_default_slot788(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 6h-2c0-2.76-2.24-5-5-5S7 3.24 7 6H5c-1.1 0-1.99.9-1.99 2L3 20c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-7-3c1.66 0 3 1.34 3 3H9c0-1.66 1.34-3 3-3zm0 10c-2.76 0-5-2.24-5-5h2c0 1.66 1.34 3 3 3s3-1.34 3-3h2c0 2.76-2.24 5-5 5z");
      add_location(path, file788, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot788.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment788(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot788] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment788.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance788($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalMall", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalMall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance788, create_fragment788, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalMall",
      options,
      id: create_fragment788.name
    });
  }
};
var MdLocalMall_default = MdLocalMall;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalMovies.svelte
var file789 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalMovies.svelte";
function create_default_slot789(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z");
      add_location(path, file789, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot789.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment789(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot789] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment789.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance789($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalMovies", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalMovies = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance789, create_fragment789, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalMovies",
      options,
      id: create_fragment789.name
    });
  }
};
var MdLocalMovies_default = MdLocalMovies;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalOffer.svelte
var file790 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalOffer.svelte";
function create_default_slot790(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z");
      add_location(path, file790, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot790.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment790(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot790] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment790.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance790($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalOffer", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalOffer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance790, create_fragment790, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalOffer",
      options,
      id: create_fragment790.name
    });
  }
};
var MdLocalOffer_default = MdLocalOffer;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalParking.svelte
var file791 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalParking.svelte";
function create_default_slot791(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 3H6v18h4v-6h3c3.31 0 6-2.69 6-6s-2.69-6-6-6zm.2 8H10V7h3.2c1.1 0 2 .9 2 2s-.9 2-2 2z");
      add_location(path, file791, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot791.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment791(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot791] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment791.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance791($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalParking", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalParking = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance791, create_fragment791, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalParking",
      options,
      id: create_fragment791.name
    });
  }
};
var MdLocalParking_default = MdLocalParking;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPharmacy.svelte
var file792 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPharmacy.svelte";
function create_default_slot792(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 5h-2.64l1.14-3.14L17.15 1l-1.46 4H3v2l2 6-2 6v2h18v-2l-2-6 2-6V5zm-5 9h-3v3h-2v-3H8v-2h3V9h2v3h3v2z");
      add_location(path, file792, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot792.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment792(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot792] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment792.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance792($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalPharmacy", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalPharmacy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance792, create_fragment792, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalPharmacy",
      options,
      id: create_fragment792.name
    });
  }
};
var MdLocalPharmacy_default = MdLocalPharmacy;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPhone.svelte
var file793 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPhone.svelte";
function create_default_slot793(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z");
      add_location(path, file793, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot793.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment793(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot793] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment793.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance793($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalPhone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalPhone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance793, create_fragment793, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalPhone",
      options,
      id: create_fragment793.name
    });
  }
};
var MdLocalPhone_default = MdLocalPhone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPizza.svelte
var file794 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPizza.svelte";
function create_default_slot794(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.43 2 5.23 3.54 3.01 6L12 22l8.99-16C18.78 3.55 15.57 2 12 2zM7 7c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm5 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file794, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot794.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment794(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot794] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment794.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance794($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalPizza", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalPizza = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance794, create_fragment794, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalPizza",
      options,
      id: create_fragment794.name
    });
  }
};
var MdLocalPizza_default = MdLocalPizza;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPlay.svelte
var file795 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPlay.svelte";
function create_default_slot795(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 12c0-1.1.9-2 2-2V6c0-1.1-.9-2-2-2H4c-1.1 0-1.99.9-1.99 2v4c1.1 0 1.99.9 1.99 2s-.89 2-2 2v4c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-4c-1.1 0-2-.9-2-2zm-4.42 4.8L12 14.5l-3.58 2.3 1.08-4.12-3.29-2.69 4.24-.25L12 5.8l1.54 3.95 4.24.25-3.29 2.69 1.09 4.11z");
      add_location(path, file795, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot795.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment795(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot795] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment795.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance795($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalPlay", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalPlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance795, create_fragment795, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalPlay",
      options,
      id: create_fragment795.name
    });
  }
};
var MdLocalPlay_default = MdLocalPlay;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPostOffice.svelte
var file796 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPostOffice.svelte";
function create_default_slot796(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z");
      add_location(path, file796, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot796.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment796(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot796] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment796.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance796($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalPostOffice", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalPostOffice = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance796, create_fragment796, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalPostOffice",
      options,
      id: create_fragment796.name
    });
  }
};
var MdLocalPostOffice_default = MdLocalPostOffice;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPrintshop.svelte
var file797 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalPrintshop.svelte";
function create_default_slot797(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z");
      add_location(path, file797, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot797.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment797(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot797] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment797.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance797($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalPrintshop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalPrintshop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance797, create_fragment797, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalPrintshop",
      options,
      id: create_fragment797.name
    });
  }
};
var MdLocalPrintshop_default = MdLocalPrintshop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalSee.svelte
var file798 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalSee.svelte";
function create_default_slot798(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file798, 4, 10, 151);
      attr_dev(path1, "d", "M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z");
      add_location(path1, file798, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot798.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment798(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot798] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment798.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance798($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalSee", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalSee = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance798, create_fragment798, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalSee",
      options,
      id: create_fragment798.name
    });
  }
};
var MdLocalSee_default = MdLocalSee;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalShipping.svelte
var file799 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalShipping.svelte";
function create_default_slot799(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5l-3-4zM6 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm13.5-9l1.96 2.5H17V9.5h2.5zm-1.5 9c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file799, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot799.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment799(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot799] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment799.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance799($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalShipping", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalShipping = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance799, create_fragment799, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalShipping",
      options,
      id: create_fragment799.name
    });
  }
};
var MdLocalShipping_default = MdLocalShipping;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalTaxi.svelte
var file800 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocalTaxi.svelte";
function create_default_slot800(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.92 6.01C18.72 5.42 18.16 5 17.5 5H15V3H9v2H6.5c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z");
      add_location(path, file800, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot800.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment800(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot800] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment800.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance800($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocalTaxi", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocalTaxi = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance800, create_fragment800, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocalTaxi",
      options,
      id: create_fragment800.name
    });
  }
};
var MdLocalTaxi_default = MdLocalTaxi;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMap.svelte
var file801 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMap.svelte";
function create_default_slot801(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.5 3l-.16.03L15 5.1 9 3 3.36 4.9c-.21.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.21-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5zM15 19l-6-2.11V5l6 2.11V19z");
      add_location(path, file801, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot801.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment801(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot801] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment801.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance801($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMap", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance801, create_fragment801, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMap",
      options,
      id: create_fragment801.name
    });
  }
};
var MdMap_default = MdMap;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMyLocation.svelte
var file802 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMyLocation.svelte";
function create_default_slot802(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z");
      add_location(path, file802, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot802.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment802(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot802] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment802.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance802($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMyLocation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMyLocation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance802, create_fragment802, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMyLocation",
      options,
      id: create_fragment802.name
    });
  }
};
var MdMyLocation_default = MdMyLocation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNavigation.svelte
var file803 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNavigation.svelte";
function create_default_slot803(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z");
      add_location(path, file803, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot803.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment803(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot803] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment803.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance803($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNavigation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNavigation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance803, create_fragment803, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNavigation",
      options,
      id: create_fragment803.name
    });
  }
};
var MdNavigation_default = MdNavigation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNearMe.svelte
var file804 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNearMe.svelte";
function create_default_slot804(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3L3 10.53v.98l6.84 2.65L12.48 21h.98L21 3z");
      add_location(path, file804, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot804.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment804(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot804] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment804.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance804($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNearMe", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNearMe = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance804, create_fragment804, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNearMe",
      options,
      id: create_fragment804.name
    });
  }
};
var MdNearMe_default = MdNearMe;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonPin.svelte
var file805 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonPin.svelte";
function create_default_slot805(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h4l3 3 3-3h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 3.3c1.49 0 2.7 1.21 2.7 2.7 0 1.49-1.21 2.7-2.7 2.7-1.49 0-2.7-1.21-2.7-2.7 0-1.49 1.21-2.7 2.7-2.7zM18 16H6v-.9c0-2 4-3.1 6-3.1s6 1.1 6 3.1v.9z");
      add_location(path, file805, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot805.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment805(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot805] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment805.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance805($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPersonPin", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPersonPin = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance805, create_fragment805, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPersonPin",
      options,
      id: create_fragment805.name
    });
  }
};
var MdPersonPin_default = MdPersonPin;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonPinCircle.svelte
var file806 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonPinCircle.svelte";
function create_default_slot806(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm0 2c1.1 0 2 .9 2 2 0 1.11-.9 2-2 2s-2-.89-2-2c0-1.1.9-2 2-2zm0 10c-1.67 0-3.14-.85-4-2.15.02-1.32 2.67-2.05 4-2.05s3.98.73 4 2.05c-.86 1.3-2.33 2.15-4 2.15z");
      add_location(path, file806, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot806.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment806(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot806] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment806.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance806($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPersonPinCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPersonPinCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance806, create_fragment806, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPersonPinCircle",
      options,
      id: create_fragment806.name
    });
  }
};
var MdPersonPinCircle_default = MdPersonPinCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPinDrop.svelte
var file807 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPinDrop.svelte";
function create_default_slot807(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 8c0-3.31-2.69-6-6-6S6 4.69 6 8c0 4.5 6 11 6 11s6-6.5 6-11zm-8 0c0-1.1.9-2 2-2s2 .9 2 2-.89 2-2 2c-1.1 0-2-.9-2-2zM5 20v2h14v-2H5z");
      add_location(path, file807, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot807.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment807(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot807] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment807.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance807($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPinDrop", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPinDrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance807, create_fragment807, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPinDrop",
      options,
      id: create_fragment807.name
    });
  }
};
var MdPinDrop_default = MdPinDrop;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlace.svelte
var file808 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlace.svelte";
function create_default_slot808(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z");
      add_location(path, file808, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot808.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment808(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot808] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment808.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance808($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlace", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlace = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance808, create_fragment808, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlace",
      options,
      id: create_fragment808.name
    });
  }
};
var MdPlace_default = MdPlace;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRateReview.svelte
var file809 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRateReview.svelte";
function create_default_slot809(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 14v-2.47l6.88-6.88c.2-.2.51-.2.71 0l1.77 1.77c.2.2.2.51 0 .71L8.47 14H6zm12 0h-7.5l2-2H18v2z");
      add_location(path, file809, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot809.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment809(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot809] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment809.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance809($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRateReview", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRateReview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance809, create_fragment809, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRateReview",
      options,
      id: create_fragment809.name
    });
  }
};
var MdRateReview_default = MdRateReview;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestaurant.svelte
var file810 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestaurant.svelte";
function create_default_slot810(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7zm5-3v8h2.5v8H21V2c-2.76 0-5 2.24-5 4z");
      add_location(path, file810, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot810.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment810(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot810] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment810.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance810($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRestaurant", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRestaurant = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance810, create_fragment810, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRestaurant",
      options,
      id: create_fragment810.name
    });
  }
};
var MdRestaurant_default = MdRestaurant;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestaurantMenu.svelte
var file811 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRestaurantMenu.svelte";
function create_default_slot811(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8.1 13.34l2.83-2.83L3.91 3.5c-1.56 1.56-1.56 4.09 0 5.66l4.19 4.18zm6.78-1.81c1.53.71 3.68.21 5.27-1.38 1.91-1.91 2.28-4.65.81-6.12-1.46-1.46-4.2-1.1-6.12.81-1.59 1.59-2.09 3.74-1.38 5.27L3.7 19.87l1.41 1.41L12 14.41l6.88 6.88 1.41-1.41L13.41 13l1.47-1.47z");
      add_location(path, file811, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot811.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment811(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot811] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment811.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance811($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRestaurantMenu", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRestaurantMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance811, create_fragment811, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRestaurantMenu",
      options,
      id: create_fragment811.name
    });
  }
};
var MdRestaurantMenu_default = MdRestaurantMenu;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSatellite.svelte
var file812 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSatellite.svelte";
function create_default_slot812(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5 4.99h3C8 6.65 6.66 8 5 8V4.99zM5 12v-2c2.76 0 5-2.25 5-5.01h2C12 8.86 8.87 12 5 12zm0 6l3.5-4.5 2.5 3.01L14.5 12l4.5 6H5z");
      add_location(path, file812, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot812.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment812(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot812] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment812.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance812($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSatellite", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSatellite = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance812, create_fragment812, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSatellite",
      options,
      id: create_fragment812.name
    });
  }
};
var MdSatellite_default = MdSatellite;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStoreMallDirectory.svelte
var file813 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStoreMallDirectory.svelte";
function create_default_slot813(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z");
      add_location(path, file813, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot813.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment813(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot813] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment813.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance813($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStoreMallDirectory", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStoreMallDirectory = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance813, create_fragment813, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStoreMallDirectory",
      options,
      id: create_fragment813.name
    });
  }
};
var MdStoreMallDirectory_default = MdStoreMallDirectory;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStreetview.svelte
var file814 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStreetview.svelte";
function create_default_slot814(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12.56 14.33c-.34.27-.56.7-.56 1.17V21h7c1.1 0 2-.9 2-2v-5.98c-.94-.33-1.95-.52-3-.52-2.03 0-3.93.7-5.44 1.83z");
      add_location(path0, file814, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file814, 5, 0, 275);
      attr_dev(path2, "d", "M11.5 6c0-1.08.27-2.1.74-3H5c-1.1 0-2 .9-2 2v14c0 .55.23 1.05.59 1.41l9.82-9.82C12.23 9.42 11.5 7.8 11.5 6z");
      add_location(path2, file814, 6, 0, 298);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot814.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment814(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot814] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment814.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance814($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStreetview", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStreetview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance814, create_fragment814, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStreetview",
      options,
      id: create_fragment814.name
    });
  }
};
var MdStreetview_default = MdStreetview;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubway.svelte
var file815 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubway.svelte";
function create_default_slot815(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file815, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file815, 5, 0, 174);
      attr_dev(path2, "d", "M7.01 9h10v5h-10zM17.8 2.8C16 2.09 13.86 2 12 2c-1.86 0-4 .09-5.8.8C3.53 3.84 2 6.05 2 8.86V22h20V8.86c0-2.81-1.53-5.02-4.2-6.06zm.2 13.08c0 1.45-1.18 2.62-2.63 2.62l1.13 1.12V20H15l-1.5-1.5h-2.83L9.17 20H7.5v-.38l1.12-1.12C7.18 18.5 6 17.32 6 15.88V9c0-2.63 3-3 6-3 3.32 0 6 .38 6 3v6.88z");
      add_location(path2, file815, 6, 0, 197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot815.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment815(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot815] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment815.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance815($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSubway", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSubway = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance815, create_fragment815, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSubway",
      options,
      id: create_fragment815.name
    });
  }
};
var MdSubway_default = MdSubway;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTerrain.svelte
var file816 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTerrain.svelte";
function create_default_slot816(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 6l-3.75 5 2.85 3.8-1.6 1.2C9.81 13.75 7 10 7 10l-6 8h22L14 6z");
      add_location(path, file816, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot816.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment816(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot816] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment816.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance816($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTerrain", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTerrain = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance816, create_fragment816, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTerrain",
      options,
      id: create_fragment816.name
    });
  }
};
var MdTerrain_default = MdTerrain;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTraffic.svelte
var file817 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTraffic.svelte";
function create_default_slot817(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 10h-3V8.86c1.72-.45 3-2 3-3.86h-3V4c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v1H4c0 1.86 1.28 3.41 3 3.86V10H4c0 1.86 1.28 3.41 3 3.86V15H4c0 1.86 1.28 3.41 3 3.86V20c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-1.14c1.72-.45 3-2 3-3.86h-3v-1.14c1.72-.45 3-2 3-3.86zm-8 9c-1.11 0-2-.9-2-2s.89-2 2-2c1.1 0 2 .9 2 2s-.89 2-2 2zm0-5c-1.11 0-2-.9-2-2s.89-2 2-2c1.1 0 2 .9 2 2s-.89 2-2 2zm0-5c-1.11 0-2-.9-2-2 0-1.11.89-2 2-2 1.1 0 2 .89 2 2 0 1.1-.89 2-2 2z");
      add_location(path, file817, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot817.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment817(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot817] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment817.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance817($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTraffic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTraffic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance817, create_fragment817, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTraffic",
      options,
      id: create_fragment817.name
    });
  }
};
var MdTraffic_default = MdTraffic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrain.svelte
var file818 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTrain.svelte";
function create_default_slot818(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2c-4 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h2.23l2-2H14l2 2h2v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-3.58-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-7H6V6h5v4zm2 0V6h5v4h-5zm3.5 7c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file818, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot818.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment818(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot818] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment818.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance818($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTrain", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTrain = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance818, create_fragment818, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTrain",
      options,
      id: create_fragment818.name
    });
  }
};
var MdTrain_default = MdTrain;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTram.svelte
var file819 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTram.svelte";
function create_default_slot819(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 16.94V8.5c0-2.79-2.61-3.4-6.01-3.49l.76-1.51H17V2H7v1.5h4.75l-.76 1.52C7.86 5.11 5 5.73 5 8.5v8.44c0 1.45 1.19 2.66 2.59 2.97L6 21.5v.5h2.23l2-2H14l2 2h2v-.5L16.5 20h-.08c1.69 0 2.58-1.37 2.58-3.06zm-7 1.56c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm5-4.5H7V9h10v5z");
      add_location(path, file819, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot819.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment819(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot819] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment819.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance819($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTram", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTram = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance819, create_fragment819, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTram",
      options,
      id: create_fragment819.name
    });
  }
};
var MdTram_default = MdTram;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTransferWithinAStation.svelte
var file820 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTransferWithinAStation.svelte";
function create_default_slot820(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.49 15.5v-1.75L14 16.25l2.49 2.5V17H22v-1.5zm3.02 4.25H14v1.5h5.51V23L22 20.5 19.51 18zM9.5 5.5c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zM5.75 8.9L3 23h2.1l1.75-8L9 17v6h2v-7.55L8.95 13.4l.6-3C10.85 12 12.8 13 15 13v-2c-1.85 0-3.45-1-4.35-2.45l-.95-1.6C9.35 6.35 8.7 6 8 6c-.25 0-.5.05-.75.15L2 8.3V13h2V9.65l1.75-.75");
      add_location(path, file820, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot820.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment820(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot820] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment820.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance820($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTransferWithinAStation", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTransferWithinAStation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance820, create_fragment820, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTransferWithinAStation",
      options,
      id: create_fragment820.name
    });
  }
};
var MdTransferWithinAStation_default = MdTransferWithinAStation;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdZoomOutMap.svelte
var file821 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdZoomOutMap.svelte";
function create_default_slot821(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z");
      add_location(path, file821, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot821.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment821(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot821] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment821.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance821($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdZoomOutMap", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdZoomOutMap = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance821, create_fragment821, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdZoomOutMap",
      options,
      id: create_fragment821.name
    });
  }
};
var MdZoomOutMap_default = MdZoomOutMap;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdApps.svelte
var file822 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdApps.svelte";
function create_default_slot822(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z");
      add_location(path, file822, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot822.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment822(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot822] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment822.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance822($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdApps", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdApps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance822, create_fragment822, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdApps",
      options,
      id: create_fragment822.name
    });
  }
};
var MdApps_default = MdApps;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowBack.svelte
var file823 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowBack.svelte";
function create_default_slot823(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z");
      add_location(path, file823, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot823.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment823(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot823] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment823.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance823($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowBack", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowBack = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance823, create_fragment823, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowBack",
      options,
      id: create_fragment823.name
    });
  }
};
var MdArrowBack_default = MdArrowBack;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDownward.svelte
var file824 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDownward.svelte";
function create_default_slot824(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z");
      add_location(path, file824, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot824.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment824(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot824] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment824.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance824($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowDownward", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowDownward = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance824, create_fragment824, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowDownward",
      options,
      id: create_fragment824.name
    });
  }
};
var MdArrowDownward_default = MdArrowDownward;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDropDown.svelte
var file825 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDropDown.svelte";
function create_default_slot825(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 10l5 5 5-5z");
      add_location(path, file825, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot825.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment825(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot825] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment825.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance825($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowDropDown", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowDropDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance825, create_fragment825, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowDropDown",
      options,
      id: create_fragment825.name
    });
  }
};
var MdArrowDropDown_default = MdArrowDropDown;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDropDownCircle.svelte
var file826 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDropDownCircle.svelte";
function create_default_slot826(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z");
      add_location(path, file826, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot826.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment826(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot826] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment826.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance826($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowDropDownCircle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowDropDownCircle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance826, create_fragment826, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowDropDownCircle",
      options,
      id: create_fragment826.name
    });
  }
};
var MdArrowDropDownCircle_default = MdArrowDropDownCircle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDropUp.svelte
var file827 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowDropUp.svelte";
function create_default_slot827(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 14l5-5 5 5z");
      add_location(path, file827, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot827.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment827(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot827] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment827.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance827($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowDropUp", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowDropUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance827, create_fragment827, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowDropUp",
      options,
      id: create_fragment827.name
    });
  }
};
var MdArrowDropUp_default = MdArrowDropUp;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowForward.svelte
var file828 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowForward.svelte";
function create_default_slot828(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z");
      add_location(path, file828, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot828.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment828(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot828] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment828.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance828($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowForward", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowForward = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance828, create_fragment828, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowForward",
      options,
      id: create_fragment828.name
    });
  }
};
var MdArrowForward_default = MdArrowForward;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowUpward.svelte
var file829 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdArrowUpward.svelte";
function create_default_slot829(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z");
      add_location(path, file829, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot829.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment829(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot829] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment829.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance829($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdArrowUpward", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdArrowUpward = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance829, create_fragment829, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdArrowUpward",
      options,
      id: create_fragment829.name
    });
  }
};
var MdArrowUpward_default = MdArrowUpward;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCancel.svelte
var file830 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCancel.svelte";
function create_default_slot830(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z");
      add_location(path, file830, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot830.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment830(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot830] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment830.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance830($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCancel", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCancel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance830, create_fragment830, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCancel",
      options,
      id: create_fragment830.name
    });
  }
};
var MdCancel_default = MdCancel;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheck.svelte
var file831 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheck.svelte";
function create_default_slot831(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z");
      add_location(path, file831, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot831.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment831(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot831] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment831.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance831($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCheck", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance831, create_fragment831, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCheck",
      options,
      id: create_fragment831.name
    });
  }
};
var MdCheck_default = MdCheck;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChevronLeft.svelte
var file832 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChevronLeft.svelte";
function create_default_slot832(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z");
      add_location(path, file832, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot832.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment832(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot832] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment832.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance832($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChevronLeft", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChevronLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance832, create_fragment832, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChevronLeft",
      options,
      id: create_fragment832.name
    });
  }
};
var MdChevronLeft_default = MdChevronLeft;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChevronRight.svelte
var file833 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChevronRight.svelte";
function create_default_slot833(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z");
      add_location(path, file833, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot833.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment833(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot833] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment833.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance833($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChevronRight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChevronRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance833, create_fragment833, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChevronRight",
      options,
      id: create_fragment833.name
    });
  }
};
var MdChevronRight_default = MdChevronRight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClose.svelte
var file834 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdClose.svelte";
function create_default_slot834(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
      add_location(path, file834, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot834.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment834(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot834] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment834.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance834($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdClose", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdClose = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance834, create_fragment834, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdClose",
      options,
      id: create_fragment834.name
    });
  }
};
var MdClose_default = MdClose;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExpandLess.svelte
var file835 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExpandLess.svelte";
function create_default_slot835(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z");
      add_location(path, file835, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot835.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment835(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot835] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment835.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance835($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExpandLess", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExpandLess = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance835, create_fragment835, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExpandLess",
      options,
      id: create_fragment835.name
    });
  }
};
var MdExpandLess_default = MdExpandLess;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExpandMore.svelte
var file836 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdExpandMore.svelte";
function create_default_slot836(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z");
      add_location(path, file836, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot836.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment836(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot836] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment836.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance836($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdExpandMore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdExpandMore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance836, create_fragment836, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdExpandMore",
      options,
      id: create_fragment836.name
    });
  }
};
var MdExpandMore_default = MdExpandMore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFirstPage.svelte
var file837 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFirstPage.svelte";
function create_default_slot837(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z");
      add_location(path, file837, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot837.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment837(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot837] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment837.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance837($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFirstPage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFirstPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance837, create_fragment837, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFirstPage",
      options,
      id: create_fragment837.name
    });
  }
};
var MdFirstPage_default = MdFirstPage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFullscreen.svelte
var file838 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFullscreen.svelte";
function create_default_slot838(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z");
      add_location(path, file838, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot838.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment838(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot838] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment838.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance838($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFullscreen", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFullscreen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance838, create_fragment838, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFullscreen",
      options,
      id: create_fragment838.name
    });
  }
};
var MdFullscreen_default = MdFullscreen;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFullscreenExit.svelte
var file839 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFullscreenExit.svelte";
function create_default_slot839(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z");
      add_location(path, file839, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot839.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment839(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot839] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment839.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance839($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFullscreenExit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFullscreenExit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance839, create_fragment839, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFullscreenExit",
      options,
      id: create_fragment839.name
    });
  }
};
var MdFullscreenExit_default = MdFullscreenExit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLastPage.svelte
var file840 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLastPage.svelte";
function create_default_slot840(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z");
      add_location(path, file840, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot840.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment840(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot840] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment840.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance840($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLastPage", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLastPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance840, create_fragment840, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLastPage",
      options,
      id: create_fragment840.name
    });
  }
};
var MdLastPage_default = MdLastPage;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMenu.svelte
var file841 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMenu.svelte";
function create_default_slot841(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z");
      add_location(path, file841, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot841.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment841(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot841] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment841.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance841($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMenu", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance841, create_fragment841, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMenu",
      options,
      id: create_fragment841.name
    });
  }
};
var MdMenu_default = MdMenu;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoreHoriz.svelte
var file842 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoreHoriz.svelte";
function create_default_slot842(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file842, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot842.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment842(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot842] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment842.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance842($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMoreHoriz", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMoreHoriz = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance842, create_fragment842, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMoreHoriz",
      options,
      id: create_fragment842.name
    });
  }
};
var MdMoreHoriz_default = MdMoreHoriz;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoreVert.svelte
var file843 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoreVert.svelte";
function create_default_slot843(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
      add_location(path, file843, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot843.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment843(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot843] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment843.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance843($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMoreVert", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMoreVert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance843, create_fragment843, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMoreVert",
      options,
      id: create_fragment843.name
    });
  }
};
var MdMoreVert_default = MdMoreVert;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRefresh.svelte
var file844 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRefresh.svelte";
function create_default_slot844(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z");
      add_location(path, file844, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot844.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment844(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot844] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment844.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance844($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRefresh", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRefresh = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance844, create_fragment844, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRefresh",
      options,
      id: create_fragment844.name
    });
  }
};
var MdRefresh_default = MdRefresh;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubdirectoryArrowLeft.svelte
var file845 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubdirectoryArrowLeft.svelte";
function create_default_slot845(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11 9l1.42 1.42L8.83 14H18V4h2v12H8.83l3.59 3.58L11 21l-6-6 6-6z");
      add_location(path, file845, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot845.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment845(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot845] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment845.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance845($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSubdirectoryArrowLeft", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSubdirectoryArrowLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance845, create_fragment845, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSubdirectoryArrowLeft",
      options,
      id: create_fragment845.name
    });
  }
};
var MdSubdirectoryArrowLeft_default = MdSubdirectoryArrowLeft;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubdirectoryArrowRight.svelte
var file846 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSubdirectoryArrowRight.svelte";
function create_default_slot846(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 15l-6 6-1.42-1.42L15.17 16H4V4h2v10h9.17l-3.59-3.58L13 9l6 6z");
      add_location(path, file846, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot846.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment846(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot846] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment846.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance846($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSubdirectoryArrowRight", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSubdirectoryArrowRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance846, create_fragment846, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSubdirectoryArrowRight",
      options,
      id: create_fragment846.name
    });
  }
};
var MdSubdirectoryArrowRight_default = MdSubdirectoryArrowRight;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUnfoldLess.svelte
var file847 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUnfoldLess.svelte";
function create_default_slot847(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z");
      add_location(path, file847, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot847.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment847(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot847] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment847.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance847($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdUnfoldLess", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdUnfoldLess = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance847, create_fragment847, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdUnfoldLess",
      options,
      id: create_fragment847.name
    });
  }
};
var MdUnfoldLess_default = MdUnfoldLess;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUnfoldMore.svelte
var file848 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdUnfoldMore.svelte";
function create_default_slot848(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z");
      add_location(path, file848, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot848.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment848(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot848] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment848.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance848($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdUnfoldMore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdUnfoldMore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance848, create_fragment848, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdUnfoldMore",
      options,
      id: create_fragment848.name
    });
  }
};
var MdUnfoldMore_default = MdUnfoldMore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAdb.svelte
var file849 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAdb.svelte";
function create_default_slot849(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 16c0 3.87 3.13 7 7 7s7-3.13 7-7v-4H5v4zM16.12 4.37l2.1-2.1-.82-.83-2.3 2.31C14.16 3.28 13.12 3 12 3s-2.16.28-3.09.75L6.6 1.44l-.82.83 2.1 2.1C6.14 5.64 5 7.68 5 10v1h14v-1c0-2.32-1.14-4.36-2.88-5.63zM9 9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm6 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z");
      add_location(path, file849, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot849.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment849(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot849] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment849.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance849($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAdb", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAdb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance849, create_fragment849, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAdb",
      options,
      id: create_fragment849.name
    });
  }
};
var MdAdb_default = MdAdb;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatFlat.svelte
var file850 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatFlat.svelte";
function create_default_slot850(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 11v2H9V7h9c2.21 0 4 1.79 4 4zM2 14v2h6v2h8v-2h6v-2H2zm5.14-1.9c1.16-1.19 1.14-3.08-.04-4.24-1.19-1.16-3.08-1.14-4.24.04-1.16 1.19-1.14 3.08.04 4.24 1.19 1.16 3.08 1.14 4.24-.04z");
      add_location(path, file850, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot850.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment850(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot850] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment850.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance850($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatFlat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatFlat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance850, create_fragment850, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatFlat",
      options,
      id: create_fragment850.name
    });
  }
};
var MdAirlineSeatFlat_default = MdAirlineSeatFlat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatFlatAngled.svelte
var file851 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatFlatAngled.svelte";
function create_default_slot851(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.25 14.29l-.69 1.89L9.2 11.71l2.08-5.66 8.56 3.09c2.1.76 3.18 3.06 2.41 5.15zM1.5 12.14L8 14.48V19h8v-1.63L20.52 19l.69-1.89-19.02-6.86-.69 1.89zm5.8-1.94c1.49-.72 2.12-2.51 1.41-4C7.99 4.71 6.2 4.08 4.7 4.8c-1.49.71-2.12 2.5-1.4 4 .71 1.49 2.5 2.12 4 1.4z");
      add_location(path, file851, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot851.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment851(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot851] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment851.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance851($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatFlatAngled", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatFlatAngled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance851, create_fragment851, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatFlatAngled",
      options,
      id: create_fragment851.name
    });
  }
};
var MdAirlineSeatFlatAngled_default = MdAirlineSeatFlatAngled;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatIndividualSuite.svelte
var file852 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatIndividualSuite.svelte";
function create_default_slot852(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7 13c1.65 0 3-1.35 3-3S8.65 7 7 7s-3 1.35-3 3 1.35 3 3 3zm12-6h-8v7H3V7H1v10h22v-6c0-2.21-1.79-4-4-4z");
      add_location(path, file852, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot852.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment852(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot852] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment852.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance852($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatIndividualSuite", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatIndividualSuite = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance852, create_fragment852, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatIndividualSuite",
      options,
      id: create_fragment852.name
    });
  }
};
var MdAirlineSeatIndividualSuite_default = MdAirlineSeatIndividualSuite;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatLegroomExtra.svelte
var file853 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatLegroomExtra.svelte";
function create_default_slot853(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 12V3H2v9c0 2.76 2.24 5 5 5h6v-2H7c-1.66 0-3-1.34-3-3zm18.83 5.24c-.38-.72-1.29-.97-2.03-.63l-1.09.5-3.41-6.98c-.34-.68-1.03-1.12-1.79-1.12L11 9V3H5v8c0 1.66 1.34 3 3 3h7l3.41 7 3.72-1.7c.77-.36 1.1-1.3.7-2.06z");
      add_location(path, file853, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot853.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment853(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot853] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment853.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance853($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatLegroomExtra", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatLegroomExtra = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance853, create_fragment853, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatLegroomExtra",
      options,
      id: create_fragment853.name
    });
  }
};
var MdAirlineSeatLegroomExtra_default = MdAirlineSeatLegroomExtra;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatLegroomNormal.svelte
var file854 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatLegroomNormal.svelte";
function create_default_slot854(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 12V3H3v9c0 2.76 2.24 5 5 5h6v-2H8c-1.66 0-3-1.34-3-3zm15.5 6H19v-7c0-1.1-.9-2-2-2h-5V3H6v8c0 1.65 1.35 3 3 3h7v7h4.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5z");
      add_location(path, file854, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot854.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment854(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot854] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment854.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance854($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatLegroomNormal", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatLegroomNormal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance854, create_fragment854, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatLegroomNormal",
      options,
      id: create_fragment854.name
    });
  }
};
var MdAirlineSeatLegroomNormal_default = MdAirlineSeatLegroomNormal;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatLegroomReduced.svelte
var file855 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatLegroomReduced.svelte";
function create_default_slot855(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.97 19.2c.18.96-.55 1.8-1.47 1.8H14v-3l1-4H9c-1.65 0-3-1.35-3-3V3h6v6h5c1.1 0 2 .9 2 2l-2 7h1.44c.73 0 1.39.49 1.53 1.2zM5 12V3H3v9c0 2.76 2.24 5 5 5h4v-2H8c-1.66 0-3-1.34-3-3z");
      add_location(path, file855, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot855.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment855(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot855] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment855.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance855($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatLegroomReduced", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatLegroomReduced = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance855, create_fragment855, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatLegroomReduced",
      options,
      id: create_fragment855.name
    });
  }
};
var MdAirlineSeatLegroomReduced_default = MdAirlineSeatLegroomReduced;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatReclineExtra.svelte
var file856 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatReclineExtra.svelte";
function create_default_slot856(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5.35 5.64c-.9-.64-1.12-1.88-.49-2.79.63-.9 1.88-1.12 2.79-.49.9.64 1.12 1.88.49 2.79-.64.9-1.88 1.12-2.79.49zM16 19H8.93c-1.48 0-2.74-1.08-2.96-2.54L4 7H2l1.99 9.76C4.37 19.2 6.47 21 8.94 21H16v-2zm.23-4h-4.88l-1.03-4.1c1.58.89 3.28 1.54 5.15 1.22V9.99c-1.63.31-3.44-.27-4.69-1.25L9.14 7.47c-.23-.18-.49-.3-.76-.38-.32-.09-.66-.12-.99-.06h-.02c-1.23.22-2.05 1.39-1.84 2.61l1.35 5.92C7.16 16.98 8.39 18 9.83 18h6.85l3.82 3 1.5-1.5-5.77-4.5z");
      add_location(path, file856, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot856.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment856(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot856] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment856.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance856($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatReclineExtra", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatReclineExtra = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance856, create_fragment856, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatReclineExtra",
      options,
      id: create_fragment856.name
    });
  }
};
var MdAirlineSeatReclineExtra_default = MdAirlineSeatReclineExtra;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatReclineNormal.svelte
var file857 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirlineSeatReclineNormal.svelte";
function create_default_slot857(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.59 5.41c-.78-.78-.78-2.05 0-2.83.78-.78 2.05-.78 2.83 0 .78.78.78 2.05 0 2.83-.79.79-2.05.79-2.83 0zM6 16V7H4v9c0 2.76 2.24 5 5 5h6v-2H9c-1.66 0-3-1.34-3-3zm14 4.07L14.93 15H11.5v-3.68c1.4 1.15 3.6 2.16 5.5 2.16v-2.16c-1.66.02-3.61-.87-4.67-2.04l-1.4-1.55c-.19-.21-.43-.38-.69-.5-.29-.14-.62-.23-.96-.23h-.03C8.01 7 7 8.01 7 9.25V15c0 1.66 1.34 3 3 3h5.07l3.5 3.5L20 20.07z");
      add_location(path, file857, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot857.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment857(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot857] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment857.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance857($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirlineSeatReclineNormal", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirlineSeatReclineNormal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance857, create_fragment857, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirlineSeatReclineNormal",
      options,
      id: create_fragment857.name
    });
  }
};
var MdAirlineSeatReclineNormal_default = MdAirlineSeatReclineNormal;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothAudio.svelte
var file858 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBluetoothAudio.svelte";
function create_default_slot858(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z");
      add_location(path, file858, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot858.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment858(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot858] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment858.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance858($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBluetoothAudio", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBluetoothAudio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance858, create_fragment858, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBluetoothAudio",
      options,
      id: create_fragment858.name
    });
  }
};
var MdBluetoothAudio_default = MdBluetoothAudio;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdConfirmationNumber.svelte
var file859 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdConfirmationNumber.svelte";
function create_default_slot859(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 10V6c0-1.11-.9-2-2-2H4c-1.1 0-1.99.89-1.99 2v4c1.1 0 1.99.9 1.99 2s-.89 2-2 2v4c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-4c-1.1 0-2-.9-2-2s.9-2 2-2zm-9 7.5h-2v-2h2v2zm0-4.5h-2v-2h2v2zm0-4.5h-2v-2h2v2z");
      add_location(path, file859, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot859.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment859(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot859] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment859.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance859($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdConfirmationNumber", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdConfirmationNumber = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance859, create_fragment859, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdConfirmationNumber",
      options,
      id: create_fragment859.name
    });
  }
};
var MdConfirmationNumber_default = MdConfirmationNumber;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDiscFull.svelte
var file860 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDiscFull.svelte";
function create_default_slot860(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 16h2v-2h-2v2zm0-9v5h2V7h-2zM10 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 10c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
      add_location(path, file860, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot860.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment860(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot860] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment860.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance860($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDiscFull", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDiscFull = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance860, create_fragment860, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDiscFull",
      options,
      id: create_fragment860.name
    });
  }
};
var MdDiscFull_default = MdDiscFull;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturb.svelte
var file861 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturb.svelte";
function create_default_slot861(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z");
      add_location(path, file861, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot861.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment861(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot861] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment861.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance861($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDoNotDisturb", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDoNotDisturb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance861, create_fragment861, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDoNotDisturb",
      options,
      id: create_fragment861.name
    });
  }
};
var MdDoNotDisturb_default = MdDoNotDisturb;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturbAlt.svelte
var file862 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturbAlt.svelte";
function create_default_slot862(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zM4 12c0-4.4 3.6-8 8-8 1.8 0 3.5.6 4.9 1.7L5.7 16.9C4.6 15.5 4 13.8 4 12zm8 8c-1.8 0-3.5-.6-4.9-1.7L18.3 7.1C19.4 8.5 20 10.2 20 12c0 4.4-3.6 8-8 8z");
      add_location(path, file862, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot862.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment862(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot862] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment862.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance862($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDoNotDisturbAlt", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDoNotDisturbAlt = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance862, create_fragment862, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDoNotDisturbAlt",
      options,
      id: create_fragment862.name
    });
  }
};
var MdDoNotDisturbAlt_default = MdDoNotDisturbAlt;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturbOff.svelte
var file863 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturbOff.svelte";
function create_default_slot863(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 11v2h-1.46l4.68 4.68C21.34 16.07 22 14.11 22 12c0-5.52-4.48-10-10-10-2.11 0-4.07.66-5.68 1.78L13.54 11H17zM2.27 2.27L1 3.54l2.78 2.78C2.66 7.93 2 9.89 2 12c0 5.52 4.48 10 10 10 2.11 0 4.07-.66 5.68-1.78L20.46 23l1.27-1.27L11 11 2.27 2.27zM7 13v-2h1.46l2 2H7z");
      add_location(path, file863, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot863.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment863(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot863] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment863.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance863($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDoNotDisturbOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDoNotDisturbOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance863, create_fragment863, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDoNotDisturbOff",
      options,
      id: create_fragment863.name
    });
  }
};
var MdDoNotDisturbOff_default = MdDoNotDisturbOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturbOn.svelte
var file864 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDoNotDisturbOn.svelte";
function create_default_slot864(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z");
      add_location(path, file864, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot864.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment864(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot864] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment864.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance864($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDoNotDisturbOn", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDoNotDisturbOn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance864, create_fragment864, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDoNotDisturbOn",
      options,
      id: create_fragment864.name
    });
  }
};
var MdDoNotDisturbOn_default = MdDoNotDisturbOn;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDriveEta.svelte
var file865 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDriveEta.svelte";
function create_default_slot865(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.92 5.01C18.72 4.42 18.16 4 17.5 4h-11c-.66 0-1.21.42-1.42 1.01L3 11v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 15c-.83 0-1.5-.67-1.5-1.5S5.67 12 6.5 12s1.5.67 1.5 1.5S7.33 15 6.5 15zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 10l1.5-4.5h11L19 10H5z");
      add_location(path, file865, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot865.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment865(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot865] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment865.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance865($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDriveEta", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDriveEta = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance865, create_fragment865, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDriveEta",
      options,
      id: create_fragment865.name
    });
  }
};
var MdDriveEta_default = MdDriveEta;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEnhancedEncryption.svelte
var file866 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEnhancedEncryption.svelte";
function create_default_slot866(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H8.9V6zM16 16h-3v3h-2v-3H8v-2h3v-3h2v3h3v2z");
      add_location(path, file866, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot866.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment866(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot866] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment866.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance866($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEnhancedEncryption", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEnhancedEncryption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance866, create_fragment866, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEnhancedEncryption",
      options,
      id: create_fragment866.name
    });
  }
};
var MdEnhancedEncryption_default = MdEnhancedEncryption;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventAvailable.svelte
var file867 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventAvailable.svelte";
function create_default_slot867(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.53 11.06L15.47 10l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 17l5.94-5.94zM19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11z");
      add_location(path, file867, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot867.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment867(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot867] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment867.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance867($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEventAvailable", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEventAvailable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance867, create_fragment867, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEventAvailable",
      options,
      id: create_fragment867.name
    });
  }
};
var MdEventAvailable_default = MdEventAvailable;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventBusy.svelte
var file868 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventBusy.svelte";
function create_default_slot868(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.31 17l2.44-2.44L14.19 17l1.06-1.06-2.44-2.44 2.44-2.44L14.19 10l-2.44 2.44L9.31 10l-1.06 1.06 2.44 2.44-2.44 2.44L9.31 17zM19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11z");
      add_location(path, file868, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot868.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment868(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot868] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment868.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance868($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEventBusy", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEventBusy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance868, create_fragment868, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEventBusy",
      options,
      id: create_fragment868.name
    });
  }
};
var MdEventBusy_default = MdEventBusy;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventNote.svelte
var file869 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdEventNote.svelte";
function create_default_slot869(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 10H7v2h10v-2zm2-7h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zm-5-5H7v2h7v-2z");
      add_location(path, file869, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot869.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment869(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot869] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment869.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance869($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdEventNote", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdEventNote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance869, create_fragment869, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdEventNote",
      options,
      id: create_fragment869.name
    });
  }
};
var MdEventNote_default = MdEventNote;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolderSpecial.svelte
var file870 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFolderSpecial.svelte";
function create_default_slot870(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-2.06 11L15 15.28 12.06 17l.78-3.33-2.59-2.24 3.41-.29L15 8l1.34 3.14 3.41.29-2.59 2.24.78 3.33z");
      add_location(path, file870, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot870.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment870(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot870] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment870.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance870($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFolderSpecial", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFolderSpecial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance870, create_fragment870, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFolderSpecial",
      options,
      id: create_fragment870.name
    });
  }
};
var MdFolderSpecial_default = MdFolderSpecial;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLiveTv.svelte
var file871 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLiveTv.svelte";
function create_default_slot871(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 6h-7.59l3.29-3.29L16 2l-4 4-4-4-.71.71L10.59 6H3c-1.1 0-2 .89-2 2v12c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.11-.9-2-2-2zm0 14H3V8h18v12zM9 10v8l7-4z");
      add_location(path, file871, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot871.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment871(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot871] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment871.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance871($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLiveTv", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLiveTv = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance871, create_fragment871, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLiveTv",
      options,
      id: create_fragment871.name
    });
  }
};
var MdLiveTv_default = MdLiveTv;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMms.svelte
var file872 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMms.svelte";
function create_default_slot872(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM5 14l3.5-4.5 2.5 3.01L14.5 8l4.5 6H5z");
      add_location(path, file872, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot872.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment872(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot872] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment872.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance872($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMms", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMms = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance872, create_fragment872, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMms",
      options,
      id: create_fragment872.name
    });
  }
};
var MdMms_default = MdMms;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMore.svelte
var file873 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMore.svelte";
function create_default_slot873(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.97.89 1.66.89H22c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 13.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm5 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm5 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path, file873, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot873.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment873(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot873] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment873.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance873($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMore", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMore = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance873, create_fragment873, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMore",
      options,
      id: create_fragment873.name
    });
  }
};
var MdMore_default = MdMore;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkCheck.svelte
var file874 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkCheck.svelte";
function create_default_slot874(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.9 5c-.17 0-.32.09-.41.23l-.07.15-5.18 11.65c-.16.29-.26.61-.26.96 0 1.11.9 2.01 2.01 2.01.96 0 1.77-.68 1.96-1.59l.01-.03L16.4 5.5c0-.28-.22-.5-.5-.5zM1 9l2 2c2.88-2.88 6.79-4.08 10.53-3.62l1.19-2.68C9.89 3.84 4.74 5.27 1 9zm20 2l2-2c-1.64-1.64-3.55-2.82-5.59-3.57l-.53 2.82c1.5.62 2.9 1.53 4.12 2.75zm-4 4l2-2c-.8-.8-1.7-1.42-2.66-1.89l-.55 2.92c.42.27.83.59 1.21.97zM5 13l2 2c1.13-1.13 2.56-1.79 4.03-2l1.28-2.88c-2.63-.08-5.3.87-7.31 2.88z");
      add_location(path, file874, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot874.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment874(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot874] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment874.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance874($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNetworkCheck", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNetworkCheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance874, create_fragment874, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNetworkCheck",
      options,
      id: create_fragment874.name
    });
  }
};
var MdNetworkCheck_default = MdNetworkCheck;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkLocked.svelte
var file875 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNetworkLocked.svelte";
function create_default_slot875(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19.5 10c.17 0 .33.03.5.05V1L1 20h13v-3c0-.89.39-1.68 1-2.23v-.27c0-2.48 2.02-4.5 4.5-4.5zm2.5 6v-1.5c0-1.38-1.12-2.5-2.5-2.5S17 13.12 17 14.5V16c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1zm-1 0h-3v-1.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V16z");
      add_location(path, file875, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot875.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment875(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot875] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment875.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance875($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNetworkLocked", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNetworkLocked = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance875, create_fragment875, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNetworkLocked",
      options,
      id: create_fragment875.name
    });
  }
};
var MdNetworkLocked_default = MdNetworkLocked;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNoEncryption.svelte
var file876 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNoEncryption.svelte";
function create_default_slot876(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 21.78L4.22 5 3 6.22l2.04 2.04C4.42 8.6 4 9.25 4 10v10c0 1.1.9 2 2 2h12c.23 0 .45-.05.66-.12L19.78 23 21 21.78zM8.9 6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H9.66L20 18.34V10c0-1.1-.9-2-2-2h-1V6c0-2.76-2.24-5-5-5-2.56 0-4.64 1.93-4.94 4.4L8.9 7.24V6z");
      add_location(path, file876, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot876.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment876(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot876] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment876.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance876($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNoEncryption", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNoEncryption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance876, create_fragment876, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNoEncryption",
      options,
      id: create_fragment876.name
    });
  }
};
var MdNoEncryption_default = MdNoEncryption;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOndemandVideo.svelte
var file877 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdOndemandVideo.svelte";
function create_default_slot877(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12zm-5-6l-7 4V7z");
      add_location(path, file877, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot877.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment877(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot877] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment877.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance877($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdOndemandVideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdOndemandVideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance877, create_fragment877, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdOndemandVideo",
      options,
      id: create_fragment877.name
    });
  }
};
var MdOndemandVideo_default = MdOndemandVideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonalVideo.svelte
var file878 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonalVideo.svelte";
function create_default_slot878(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12z");
      add_location(path, file878, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot878.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment878(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot878] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment878.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance878($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPersonalVideo", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPersonalVideo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance878, create_fragment878, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPersonalVideo",
      options,
      id: create_fragment878.name
    });
  }
};
var MdPersonalVideo_default = MdPersonalVideo;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneBluetoothSpeaker.svelte
var file879 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneBluetoothSpeaker.svelte";
function create_default_slot879(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.71 9.5L17 7.21V11h.5l2.85-2.85L18.21 6l2.15-2.15L17.5 1H17v3.79L14.71 2.5l-.71.71L16.79 6 14 8.79l.71.71zM18 2.91l.94.94-.94.94V2.91zm0 4.3l.94.94-.94.94V7.21zm2 8.29c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.21c.28-.26.36-.65.25-1C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1z");
      add_location(path, file879, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot879.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment879(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot879] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment879.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance879($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneBluetoothSpeaker", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneBluetoothSpeaker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance879, create_fragment879, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneBluetoothSpeaker",
      options,
      id: create_fragment879.name
    });
  }
};
var MdPhoneBluetoothSpeaker_default = MdPhoneBluetoothSpeaker;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneForwarded.svelte
var file880 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneForwarded.svelte";
function create_default_slot880(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 11l5-5-5-5v3h-4v4h4v3zm2 4.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.21c.28-.26.36-.65.25-1C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1z");
      add_location(path, file880, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot880.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment880(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot880] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment880.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance880($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneForwarded", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneForwarded = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance880, create_fragment880, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneForwarded",
      options,
      id: create_fragment880.name
    });
  }
};
var MdPhoneForwarded_default = MdPhoneForwarded;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneInTalk.svelte
var file881 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneInTalk.svelte";
function create_default_slot881(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.21c.28-.26.36-.65.25-1C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 12h2c0-4.97-4.03-9-9-9v2c3.87 0 7 3.13 7 7zm-4 0h2c0-2.76-2.24-5-5-5v2c1.66 0 3 1.34 3 3z");
      add_location(path, file881, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot881.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment881(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot881] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment881.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance881($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneInTalk", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneInTalk = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance881, create_fragment881, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneInTalk",
      options,
      id: create_fragment881.name
    });
  }
};
var MdPhoneInTalk_default = MdPhoneInTalk;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneLocked.svelte
var file882 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneLocked.svelte";
function create_default_slot882(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.21c.28-.26.36-.65.25-1C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM20 4v-.5C20 2.12 18.88 1 17.5 1S15 2.12 15 3.5V4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-.8 0h-3.4v-.5c0-.94.76-1.7 1.7-1.7s1.7.76 1.7 1.7V4z");
      add_location(path, file882, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot882.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment882(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot882] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment882.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance882($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneLocked", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneLocked = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance882, create_fragment882, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneLocked",
      options,
      id: create_fragment882.name
    });
  }
};
var MdPhoneLocked_default = MdPhoneLocked;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneMissed.svelte
var file883 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhoneMissed.svelte";
function create_default_slot883(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6.5 5.5L12 11l7-7-1-1-6 6-4.5-4.5H11V3H5v6h1.5V5.5zm17.21 11.17C20.66 13.78 16.54 12 12 12 7.46 12 3.34 13.78.29 16.67c-.18.18-.29.43-.29.71s.11.53.29.71l2.48 2.48c.18.18.43.29.71.29.27 0 .52-.11.7-.28.79-.74 1.69-1.36 2.66-1.85.33-.16.56-.5.56-.9v-3.1c1.45-.48 3-.73 4.6-.73 1.6 0 3.15.25 4.6.72v3.1c0 .39.23.74.56.9.98.49 1.87 1.12 2.67 1.85.18.18.43.28.7.28.28 0 .53-.11.71-.29l2.48-2.48c.18-.18.29-.43.29-.71s-.12-.52-.3-.7z");
      add_location(path, file883, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot883.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment883(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot883] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment883.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance883($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhoneMissed", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhoneMissed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance883, create_fragment883, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhoneMissed",
      options,
      id: create_fragment883.name
    });
  }
};
var MdPhoneMissed_default = MdPhoneMissed;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonePaused.svelte
var file884 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPhonePaused.svelte";
function create_default_slot884(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3h-2v7h2V3zm3 12.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.21c.28-.26.36-.65.25-1C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 3v7h2V3h-2z");
      add_location(path, file884, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot884.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment884(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot884] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment884.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance884($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPhonePaused", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPhonePaused = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance884, create_fragment884, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPhonePaused",
      options,
      id: create_fragment884.name
    });
  }
};
var MdPhonePaused_default = MdPhonePaused;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPower.svelte
var file885 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPower.svelte";
function create_default_slot885(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.01 7L16 3h-2v4h-4V3H8v4h-.01C7 6.99 6 7.99 6 8.99v5.49L9.5 18v3h5v-3l3.5-3.51v-5.5c0-1-1-2-1.99-1.99z");
      add_location(path, file885, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot885.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment885(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot885] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment885.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance885($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPower", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPower = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance885, create_fragment885, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPower",
      options,
      id: create_fragment885.name
    });
  }
};
var MdPower_default = MdPower;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPriorityHigh.svelte
var file886 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPriorityHigh.svelte";
function create_default_slot886(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file886, 4, 10, 151);
      attr_dev(path1, "d", "M10 3h4v12h-4z");
      add_location(path1, file886, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot886.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment886(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot886] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment886.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance886($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPriorityHigh", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPriorityHigh = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance886, create_fragment886, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPriorityHigh",
      options,
      id: create_fragment886.name
    });
  }
};
var MdPriorityHigh_default = MdPriorityHigh;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRvHookup.svelte
var file887 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRvHookup.svelte";
function create_default_slot887(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 17v-6c0-1.1-.9-2-2-2H7V7l-3 3 3 3v-2h4v3H4v3c0 1.1.9 2 2 2h2c0 1.66 1.34 3 3 3s3-1.34 3-3h8v-2h-2zm-9 3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm7-6h-4v-3h4v3zM17 2v2H9v2h8v2l3-3z");
      add_location(path, file887, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot887.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment887(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot887] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment887.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance887($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRvHookup", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRvHookup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance887, create_fragment887, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRvHookup",
      options,
      id: create_fragment887.name
    });
  }
};
var MdRvHookup_default = MdRvHookup;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSdCard.svelte
var file888 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSdCard.svelte";
function create_default_slot888(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2h-8L4.02 8 4 20c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-6 6h-2V4h2v4zm3 0h-2V4h2v4zm3 0h-2V4h2v4z");
      add_location(path, file888, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot888.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment888(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot888] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment888.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance888($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSdCard", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSdCard = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance888, create_fragment888, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSdCard",
      options,
      id: create_fragment888.name
    });
  }
};
var MdSdCard_default = MdSdCard;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSimCardAlert.svelte
var file889 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSimCardAlert.svelte";
function create_default_slot889(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2h-8L4.02 8 4 20c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5 15h-2v-2h2v2zm0-4h-2V8h2v5z");
      add_location(path, file889, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot889.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment889(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot889] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment889.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance889($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSimCardAlert", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSimCardAlert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance889, create_fragment889, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSimCardAlert",
      options,
      id: create_fragment889.name
    });
  }
};
var MdSimCardAlert_default = MdSimCardAlert;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSms.svelte
var file890 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSms.svelte";
function create_default_slot890(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM9 11H7V9h2v2zm4 0h-2V9h2v2zm4 0h-2V9h2v2z");
      add_location(path, file890, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot890.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment890(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot890] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment890.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance890($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSms", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSms = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance890, create_fragment890, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSms",
      options,
      id: create_fragment890.name
    });
  }
};
var MdSms_default = MdSms;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmsFailed.svelte
var file891 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmsFailed.svelte";
function create_default_slot891(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z");
      add_location(path, file891, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot891.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment891(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot891] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment891.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance891($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSmsFailed", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSmsFailed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance891, create_fragment891, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSmsFailed",
      options,
      id: create_fragment891.name
    });
  }
};
var MdSmsFailed_default = MdSmsFailed;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSync.svelte
var file892 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSync.svelte";
function create_default_slot892(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z");
      add_location(path, file892, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot892.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment892(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot892] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment892.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance892($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSync", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSync = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance892, create_fragment892, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSync",
      options,
      id: create_fragment892.name
    });
  }
};
var MdSync_default = MdSync;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSyncDisabled.svelte
var file893 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSyncDisabled.svelte";
function create_default_slot893(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 6.35V4.26c-.8.21-1.55.54-2.23.96l1.46 1.46c.25-.12.5-.24.77-.33zm-7.14-.94l2.36 2.36C4.45 8.99 4 10.44 4 12c0 2.21.91 4.2 2.36 5.64L4 20h6v-6l-2.24 2.24C6.68 15.15 6 13.66 6 12c0-1 .25-1.94.68-2.77l8.08 8.08c-.25.13-.5.25-.77.34v2.09c.8-.21 1.55-.54 2.23-.96l2.36 2.36 1.27-1.27L4.14 4.14 2.86 5.41zM20 4h-6v6l2.24-2.24C17.32 8.85 18 10.34 18 12c0 1-.25 1.94-.68 2.77l1.46 1.46C19.55 15.01 20 13.56 20 12c0-2.21-.91-4.2-2.36-5.64L20 4z");
      add_location(path, file893, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot893.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment893(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot893] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment893.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance893($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSyncDisabled", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSyncDisabled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance893, create_fragment893, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSyncDisabled",
      options,
      id: create_fragment893.name
    });
  }
};
var MdSyncDisabled_default = MdSyncDisabled;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSyncProblem.svelte
var file894 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSyncProblem.svelte";
function create_default_slot894(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 12c0 2.21.91 4.2 2.36 5.64L3 20h6v-6l-2.24 2.24C5.68 15.15 5 13.66 5 12c0-2.61 1.67-4.83 4-5.65V4.26C5.55 5.15 3 8.27 3 12zm8 5h2v-2h-2v2zM21 4h-6v6l2.24-2.24C18.32 8.85 19 10.34 19 12c0 2.61-1.67 4.83-4 5.65v2.09c3.45-.89 6-4.01 6-7.74 0-2.21-.91-4.2-2.36-5.64L21 4zm-10 9h2V7h-2v6z");
      add_location(path, file894, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot894.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment894(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot894] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment894.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance894($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSyncProblem", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSyncProblem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance894, create_fragment894, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSyncProblem",
      options,
      id: create_fragment894.name
    });
  }
};
var MdSyncProblem_default = MdSyncProblem;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSystemUpdate.svelte
var file895 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSystemUpdate.svelte";
function create_default_slot895(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 1.01L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14zm-1-6h-3V8h-2v5H8l4 4 4-4z");
      add_location(path, file895, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot895.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment895(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot895] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment895.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance895($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSystemUpdate", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSystemUpdate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance895, create_fragment895, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSystemUpdate",
      options,
      id: create_fragment895.name
    });
  }
};
var MdSystemUpdate_default = MdSystemUpdate;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTapAndPlay.svelte
var file896 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTapAndPlay.svelte";
function create_default_slot896(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 16v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0 4v3h3c0-1.66-1.34-3-3-3zm0-8v2c4.97 0 9 4.03 9 9h2c0-6.08-4.92-11-11-11zM17 1.01L7 1c-1.1 0-2 .9-2 2v7.37c.69.16 1.36.37 2 .64V5h10v13h-3.03c.52 1.25.84 2.59.95 4H17c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99z");
      add_location(path, file896, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot896.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment896(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot896] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment896.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance896($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTapAndPlay", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTapAndPlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance896, create_fragment896, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTapAndPlay",
      options,
      id: create_fragment896.name
    });
  }
};
var MdTapAndPlay_default = MdTapAndPlay;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimeToLeave.svelte
var file897 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdTimeToLeave.svelte";
function create_default_slot897(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.92 5.01C18.72 4.42 18.16 4 17.5 4h-11c-.66 0-1.21.42-1.42 1.01L3 11v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 15c-.83 0-1.5-.67-1.5-1.5S5.67 12 6.5 12s1.5.67 1.5 1.5S7.33 15 6.5 15zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 10l1.5-4.5h11L19 10H5z");
      add_location(path, file897, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot897.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment897(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot897] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment897.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance897($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdTimeToLeave", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdTimeToLeave = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance897, create_fragment897, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdTimeToLeave",
      options,
      id: create_fragment897.name
    });
  }
};
var MdTimeToLeave_default = MdTimeToLeave;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVibration.svelte
var file898 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVibration.svelte";
function create_default_slot898(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M0 15h2V9H0v6zm3 2h2V7H3v10zm19-8v6h2V9h-2zm-3 8h2V7h-2v10zM16.5 3h-9C6.67 3 6 3.67 6 4.5v15c0 .83.67 1.5 1.5 1.5h9c.83 0 1.5-.67 1.5-1.5v-15c0-.83-.67-1.5-1.5-1.5zM16 19H8V5h8v14z");
      add_location(path, file898, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot898.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment898(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot898] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment898.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance898($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVibration", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVibration = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance898, create_fragment898, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVibration",
      options,
      id: create_fragment898.name
    });
  }
};
var MdVibration_default = MdVibration;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVoiceChat.svelte
var file899 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVoiceChat.svelte";
function create_default_slot899(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12l-4-3.2V14H6V6h8v3.2L18 6v8z");
      add_location(path, file899, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot899.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment899(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot899] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment899.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance899($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVoiceChat", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVoiceChat = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance899, create_fragment899, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVoiceChat",
      options,
      id: create_fragment899.name
    });
  }
};
var MdVoiceChat_default = MdVoiceChat;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVpnLock.svelte
var file900 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdVpnLock.svelte";
function create_default_slot900(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 4v-.5C22 2.12 20.88 1 19.5 1S17 2.12 17 3.5V4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h5c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zm-.8 0h-3.4v-.5c0-.94.76-1.7 1.7-1.7s1.7.76 1.7 1.7V4zm-2.28 8c.04.33.08.66.08 1 0 2.08-.8 3.97-2.1 5.39-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H7v-2h2c.55 0 1-.45 1-1V8h2c1.1 0 2-.9 2-2V3.46c-.95-.3-1.95-.46-3-.46C5.48 3 1 7.48 1 13s4.48 10 10 10 10-4.48 10-10c0-.34-.02-.67-.05-1h-2.03zM10 20.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L8 16v1c0 1.1.9 2 2 2v1.93z");
      add_location(path, file900, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot900.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment900(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot900] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment900.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance900($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdVpnLock", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdVpnLock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance900, create_fragment900, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdVpnLock",
      options,
      id: create_fragment900.name
    });
  }
};
var MdVpnLock_default = MdVpnLock;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWc.svelte
var file901 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWc.svelte";
function create_default_slot901(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5.5 22v-7.5H4V9c0-1.1.9-2 2-2h3c1.1 0 2 .9 2 2v5.5H9.5V22h-4zM18 22v-6h3l-2.54-7.63C18.18 7.55 17.42 7 16.56 7h-.12c-.86 0-1.63.55-1.9 1.37L12 16h3v6h3zM7.5 6c1.11 0 2-.89 2-2s-.89-2-2-2-2 .89-2 2 .89 2 2 2zm9 0c1.11 0 2-.89 2-2s-.89-2-2-2-2 .89-2 2 .89 2 2 2z");
      add_location(path, file901, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot901.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment901(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot901] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment901.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance901($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWc", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWc = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance901, create_fragment901, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWc",
      options,
      id: create_fragment901.name
    });
  }
};
var MdWc_default = MdWc;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWifi.svelte
var file902 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWifi.svelte";
function create_default_slot902(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 9l2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z");
      add_location(path, file902, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot902.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment902(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot902] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment902.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance902($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWifi", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWifi = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance902, create_fragment902, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWifi",
      options,
      id: create_fragment902.name
    });
  }
};
var MdWifi_default = MdWifi;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAcUnit.svelte
var file903 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAcUnit.svelte";
function create_default_slot903(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 11h-4.17l3.24-3.24-1.41-1.42L15 11h-2V9l4.66-4.66-1.42-1.41L13 6.17V2h-2v4.17L7.76 2.93 6.34 4.34 11 9v2H9L4.34 6.34 2.93 7.76 6.17 11H2v2h4.17l-3.24 3.24 1.41 1.42L9 13h2v2l-4.66 4.66 1.42 1.41L11 17.83V22h2v-4.17l3.24 3.24 1.42-1.41L13 15v-2h2l4.66 4.66 1.41-1.42L17.83 13H22z");
      add_location(path, file903, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot903.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment903(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot903] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment903.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance903($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAcUnit", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAcUnit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance903, create_fragment903, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAcUnit",
      options,
      id: create_fragment903.name
    });
  }
};
var MdAcUnit_default = MdAcUnit;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirportShuttle.svelte
var file904 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAirportShuttle.svelte";
function create_default_slot904(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 5H3c-1.1 0-2 .89-2 2v9h2c0 1.65 1.34 3 3 3s3-1.35 3-3h5.5c0 1.65 1.34 3 3 3s3-1.35 3-3H23v-5l-6-6zM3 11V7h4v4H3zm3 6.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm7-6.5H9V7h4v4zm4.5 6.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM15 11V7h1l4 4h-5z");
      add_location(path, file904, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot904.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment904(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot904] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment904.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance904($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAirportShuttle", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAirportShuttle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance904, create_fragment904, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAirportShuttle",
      options,
      id: create_fragment904.name
    });
  }
};
var MdAirportShuttle_default = MdAirportShuttle;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAllInclusive.svelte
var file905 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdAllInclusive.svelte";
function create_default_slot905(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.6 6.62c-1.44 0-2.8.56-3.77 1.53L12 10.66 10.48 12h.01L7.8 14.39c-.64.64-1.49.99-2.4.99-1.87 0-3.39-1.51-3.39-3.38S3.53 8.62 5.4 8.62c.91 0 1.76.35 2.44 1.03l1.13 1 1.51-1.34L9.22 8.2C8.2 7.18 6.84 6.62 5.4 6.62 2.42 6.62 0 9.04 0 12s2.42 5.38 5.4 5.38c1.44 0 2.8-.56 3.77-1.53l2.83-2.5.01.01L13.52 12h-.01l2.69-2.39c.64-.64 1.49-.99 2.4-.99 1.87 0 3.39 1.51 3.39 3.38s-1.52 3.38-3.39 3.38c-.9 0-1.76-.35-2.44-1.03l-1.14-1.01-1.51 1.34 1.27 1.12c1.02 1.01 2.37 1.57 3.82 1.57 2.98 0 5.4-2.41 5.4-5.38s-2.42-5.37-5.4-5.37z");
      add_location(path, file905, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot905.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment905(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot905] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment905.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance905($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdAllInclusive", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdAllInclusive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance905, create_fragment905, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdAllInclusive",
      options,
      id: create_fragment905.name
    });
  }
};
var MdAllInclusive_default = MdAllInclusive;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBeachAccess.svelte
var file906 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBeachAccess.svelte";
function create_default_slot906(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13.127 14.56l1.43-1.43 6.44 6.443L19.57 21zm4.293-5.73l2.86-2.86c-3.95-3.95-10.35-3.96-14.3-.02 3.93-1.3 8.31-.25 11.44 2.88zM5.95 5.98c-3.94 3.95-3.93 10.35.02 14.3l2.86-2.86C5.7 14.29 4.65 9.91 5.95 5.98zm.02-.02l-.01.01c-.38 3.01 1.17 6.88 4.3 10.02l5.73-5.73c-3.13-3.13-7.01-4.68-10.02-4.3z");
      add_location(path, file906, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot906.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment906(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot906] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment906.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance906($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBeachAccess", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBeachAccess = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance906, create_fragment906, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBeachAccess",
      options,
      id: create_fragment906.name
    });
  }
};
var MdBeachAccess_default = MdBeachAccess;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBusinessCenter.svelte
var file907 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdBusinessCenter.svelte";
function create_default_slot907(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 16v-1H3.01L3 19c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2v-4h-7v1h-4zm10-9h-4.01V5l-2-2h-4l-2 2v2H4c-1.1 0-2 .9-2 2v3c0 1.11.89 2 2 2h6v-2h4v2h6c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zm-6 0h-4V5h4v2z");
      add_location(path, file907, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot907.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment907(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot907] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment907.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance907($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdBusinessCenter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdBusinessCenter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance907, create_fragment907, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdBusinessCenter",
      options,
      id: create_fragment907.name
    });
  }
};
var MdBusinessCenter_default = MdBusinessCenter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCasino.svelte
var file908 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCasino.svelte";
function create_default_slot908(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM7.5 18c-.83 0-1.5-.67-1.5-1.5S6.67 15 7.5 15s1.5.67 1.5 1.5S8.33 18 7.5 18zm0-9C6.67 9 6 8.33 6 7.5S6.67 6 7.5 6 9 6.67 9 7.5 8.33 9 7.5 9zm4.5 4.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm4.5 4.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm0-9c-.83 0-1.5-.67-1.5-1.5S15.67 6 16.5 6s1.5.67 1.5 1.5S17.33 9 16.5 9z");
      add_location(path, file908, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot908.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment908(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot908] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment908.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance908($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCasino", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCasino = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance908, create_fragment908, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCasino",
      options,
      id: create_fragment908.name
    });
  }
};
var MdCasino_default = MdCasino;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChildCare.svelte
var file909 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChildCare.svelte";
function create_default_slot909(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file909, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file909, 5, 0, 174);
      attr_dev(path2, "d", "M22.94 12.66c.04-.21.06-.43.06-.66s-.02-.45-.06-.66c-.25-1.51-1.36-2.74-2.81-3.17-.53-1.12-1.28-2.1-2.19-2.91C16.36 3.85 14.28 3 12 3s-4.36.85-5.94 2.26c-.92.81-1.67 1.8-2.19 2.91-1.45.43-2.56 1.65-2.81 3.17-.04.21-.06.43-.06.66s.02.45.06.66c.25 1.51 1.36 2.74 2.81 3.17.52 1.11 1.27 2.09 2.17 2.89C7.62 20.14 9.71 21 12 21s4.38-.86 5.97-2.28c.9-.8 1.65-1.79 2.17-2.89 1.44-.43 2.55-1.65 2.8-3.17zM19 14c-.1 0-.19-.02-.29-.03-.2.67-.49 1.29-.86 1.86C16.6 17.74 14.45 19 12 19s-4.6-1.26-5.85-3.17c-.37-.57-.66-1.19-.86-1.86-.1.01-.19.03-.29.03-1.1 0-2-.9-2-2s.9-2 2-2c.1 0 .19.02.29.03.2-.67.49-1.29.86-1.86C7.4 6.26 9.55 5 12 5s4.6 1.26 5.85 3.17c.37.57.66 1.19.86 1.86.1-.01.19-.03.29-.03 1.1 0 2 .9 2 2s-.9 2-2 2zM7.5 14c.76 1.77 2.49 3 4.5 3s3.74-1.23 4.5-3h-9z");
      add_location(path2, file909, 6, 0, 197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot909.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment909(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot909] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment909.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance909($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChildCare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChildCare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance909, create_fragment909, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChildCare",
      options,
      id: create_fragment909.name
    });
  }
};
var MdChildCare_default = MdChildCare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChildFriendly.svelte
var file910 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdChildFriendly.svelte";
function create_default_slot910(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 2v8h8c0-4.42-3.58-8-8-8zm6.32 13.89C20.37 14.54 21 12.84 21 11H6.44l-.95-2H2v2h2.22s1.89 4.07 2.12 4.42c-1.1.59-1.84 1.75-1.84 3.08C4.5 20.43 6.07 22 8 22c1.76 0 3.22-1.3 3.46-3h2.08c.24 1.7 1.7 3 3.46 3 1.93 0 3.5-1.57 3.5-3.5 0-1.04-.46-1.97-1.18-2.61zM8 20c-.83 0-1.5-.67-1.5-1.5S7.17 17 8 17s1.5.67 1.5 1.5S8.83 20 8 20zm9 0c-.83 0-1.5-.67-1.5-1.5S16.17 17 17 17s1.5.67 1.5 1.5S17.83 20 17 20z");
      add_location(path, file910, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot910.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment910(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot910] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment910.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance910($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdChildFriendly", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdChildFriendly = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance910, create_fragment910, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdChildFriendly",
      options,
      id: create_fragment910.name
    });
  }
};
var MdChildFriendly_default = MdChildFriendly;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFitnessCenter.svelte
var file911 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFitnessCenter.svelte";
function create_default_slot911(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.57 14.86L22 13.43 20.57 12 17 15.57 8.43 7 12 3.43 10.57 2 9.14 3.43 7.71 2 5.57 4.14 4.14 2.71 2.71 4.14l1.43 1.43L2 7.71l1.43 1.43L2 10.57 3.43 12 7 8.43 15.57 17 12 20.57 13.43 22l1.43-1.43L16.29 22l2.14-2.14 1.43 1.43 1.43-1.43-1.43-1.43L22 16.29z");
      add_location(path, file911, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot911.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment911(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot911] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment911.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance911($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFitnessCenter", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFitnessCenter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance911, create_fragment911, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFitnessCenter",
      options,
      id: create_fragment911.name
    });
  }
};
var MdFitnessCenter_default = MdFitnessCenter;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFreeBreakfast.svelte
var file912 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdFreeBreakfast.svelte";
function create_default_slot912(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zm0 5h-2V5h2v3zM4 19h16v2H4z");
      add_location(path, file912, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot912.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment912(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot912] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment912.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance912($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdFreeBreakfast", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdFreeBreakfast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance912, create_fragment912, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdFreeBreakfast",
      options,
      id: create_fragment912.name
    });
  }
};
var MdFreeBreakfast_default = MdFreeBreakfast;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGolfCourse.svelte
var file913 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGolfCourse.svelte";
function create_default_slot913(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file913, 4, 10, 151);
      attr_dev(path1, "d", "M17 5.92L9 2v18H7v-1.73c-1.79.35-3 .99-3 1.73 0 1.1 2.69 2 6 2s6-.9 6-2c0-.99-2.16-1.81-5-1.97V8.98l6-3.06z");
      add_location(path1, file913, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot913.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment913(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot913] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment913.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance913($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGolfCourse", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGolfCourse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance913, create_fragment913, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGolfCourse",
      options,
      id: create_fragment913.name
    });
  }
};
var MdGolfCourse_default = MdGolfCourse;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHotTub.svelte
var file914 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdHotTub.svelte";
function create_default_slot914(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file914, 4, 10, 151);
      attr_dev(path1, "d", "M11.15 12c-.31-.22-.59-.46-.82-.72l-1.4-1.55c-.19-.21-.43-.38-.69-.5-.29-.14-.62-.23-.96-.23h-.03C6.01 9 5 10.01 5 11.25V12H2v8c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-8H11.15zM7 20H5v-6h2v6zm4 0H9v-6h2v6zm4 0h-2v-6h2v6zm4 0h-2v-6h2v6zm-.35-14.14l-.07-.07c-.57-.62-.82-1.41-.67-2.2L18 3h-1.89l-.06.43c-.2 1.36.27 2.71 1.3 3.72l.07.06c.57.62.82 1.41.67 2.2l-.11.59h1.91l.06-.43c.21-1.36-.27-2.71-1.3-3.71zm-4 0l-.07-.07c-.57-.62-.82-1.41-.67-2.2L14 3h-1.89l-.06.43c-.2 1.36.27 2.71 1.3 3.72l.07.06c.57.62.82 1.41.67 2.2l-.11.59h1.91l.06-.43c.21-1.36-.27-2.71-1.3-3.71z");
      add_location(path1, file914, 5, 0, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot914.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment914(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot914] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment914.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance914($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdHotTub", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdHotTub = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance914, create_fragment914, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdHotTub",
      options,
      id: create_fragment914.name
    });
  }
};
var MdHotTub_default = MdHotTub;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKitchen.svelte
var file915 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdKitchen.svelte";
function create_default_slot915(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2.01L6 2c-1.1 0-2 .89-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.11-.9-1.99-2-1.99zM18 20H6v-9.02h12V20zm0-11H6V4h12v5zM8 5h2v3H8zm0 7h2v5H8z");
      add_location(path, file915, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot915.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment915(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot915] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment915.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance915($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdKitchen", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdKitchen = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance915, create_fragment915, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdKitchen",
      options,
      id: create_fragment915.name
    });
  }
};
var MdKitchen_default = MdKitchen;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPool.svelte
var file916 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPool.svelte";
function create_default_slot916(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M22 21c-1.11 0-1.73-.37-2.18-.64-.37-.22-.6-.36-1.15-.36-.56 0-.78.13-1.15.36-.46.27-1.07.64-2.18.64s-1.73-.37-2.18-.64c-.37-.22-.6-.36-1.15-.36-.56 0-.78.13-1.15.36-.46.27-1.08.64-2.19.64-1.11 0-1.73-.37-2.18-.64-.37-.23-.6-.36-1.15-.36s-.78.13-1.15.36c-.46.27-1.08.64-2.19.64v-2c.56 0 .78-.13 1.15-.36.46-.27 1.08-.64 2.19-.64s1.73.37 2.18.64c.37.23.59.36 1.15.36.56 0 .78-.13 1.15-.36.46-.27 1.08-.64 2.19-.64 1.11 0 1.73.37 2.18.64.37.22.6.36 1.15.36s.78-.13 1.15-.36c.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64c.37.23.59.36 1.15.36v2zm0-4.5c-1.11 0-1.73-.37-2.18-.64-.37-.22-.6-.36-1.15-.36-.56 0-.78.13-1.15.36-.45.27-1.07.64-2.18.64s-1.73-.37-2.18-.64c-.37-.22-.6-.36-1.15-.36-.56 0-.78.13-1.15.36-.45.27-1.07.64-2.18.64s-1.73-.37-2.18-.64c-.37-.22-.6-.36-1.15-.36s-.78.13-1.15.36c-.47.27-1.09.64-2.2.64v-2c.56 0 .78-.13 1.15-.36.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64c.37.22.6.36 1.15.36.56 0 .78-.13 1.15-.36.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64c.37.22.6.36 1.15.36s.78-.13 1.15-.36c.45-.27 1.07-.64 2.18-.64s1.73.37 2.18.64c.37.22.6.36 1.15.36v2zM8.67 12c.56 0 .78-.13 1.15-.36.46-.27 1.08-.64 2.19-.64 1.11 0 1.73.37 2.18.64.37.22.6.36 1.15.36s.78-.13 1.15-.36c.12-.07.26-.15.41-.23L10.48 5C8.93 3.45 7.5 2.99 5 3v2.5c1.82-.01 2.89.39 4 1.5l1 1-3.25 3.25c.31.12.56.27.77.39.37.23.59.36 1.15.36z");
      add_location(path0, file916, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file916, 5, 0, 1474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot916.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment916(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot916] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment916.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance916($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPool", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPool = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance916, create_fragment916, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPool",
      options,
      id: create_fragment916.name
    });
  }
};
var MdPool_default = MdPool;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRoomService.svelte
var file917 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRoomService.svelte";
function create_default_slot917(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 17h20v2H2zm11.84-9.21c.1-.24.16-.51.16-.79 0-1.1-.9-2-2-2s-2 .9-2 2c0 .28.06.55.16.79C6.25 8.6 3.27 11.93 3 16h18c-.27-4.07-3.25-7.4-7.16-8.21z");
      add_location(path, file917, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot917.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment917(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot917] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment917.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance917($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRoomService", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRoomService = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance917, create_fragment917, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRoomService",
      options,
      id: create_fragment917.name
    });
  }
};
var MdRoomService_default = MdRoomService;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmokeFree.svelte
var file918 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmokeFree.svelte";
function create_default_slot918(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 6l6.99 7H2v3h9.99l7 7 1.26-1.25-17-17zm18.5 7H22v3h-1.5zM18 13h1.5v3H18zm.85-8.12c.62-.61 1-1.45 1-2.38h-1.5c0 1.02-.83 1.85-1.85 1.85v1.5c2.24 0 4 1.83 4 4.07V12H22V9.92c0-2.23-1.28-4.15-3.15-5.04zM14.5 8.7h1.53c1.05 0 1.97.74 1.97 2.05V12h1.5v-1.59c0-1.8-1.6-3.16-3.47-3.16H14.5c-1.02 0-1.85-.98-1.85-2s.83-1.75 1.85-1.75V2c-1.85 0-3.35 1.5-3.35 3.35s1.5 3.35 3.35 3.35zm2.5 7.23V13h-2.93z");
      add_location(path, file918, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot918.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment918(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot918] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment918.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance918($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSmokeFree", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSmokeFree = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance918, create_fragment918, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSmokeFree",
      options,
      id: create_fragment918.name
    });
  }
};
var MdSmokeFree_default = MdSmokeFree;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmokingRooms.svelte
var file919 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSmokingRooms.svelte";
function create_default_slot919(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 16h15v3H2zm18.5 0H22v3h-1.5zM18 16h1.5v3H18zm.85-8.27c.62-.61 1-1.45 1-2.38C19.85 3.5 18.35 2 16.5 2v1.5c1.02 0 1.85.83 1.85 1.85S17.52 7.2 16.5 7.2v1.5c2.24 0 4 1.83 4 4.07V15H22v-2.24c0-2.22-1.28-4.14-3.15-5.03zm-2.82 2.47H14.5c-1.02 0-1.85-.98-1.85-2s.83-1.75 1.85-1.75v-1.5c-1.85 0-3.35 1.5-3.35 3.35s1.5 3.35 3.35 3.35h1.53c1.05 0 1.97.74 1.97 2.05V15h1.5v-1.64c0-1.81-1.6-3.16-3.47-3.16z");
      add_location(path, file919, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot919.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment919(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot919] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment919.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance919($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSmokingRooms", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSmokingRooms = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance919, create_fragment919, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSmokingRooms",
      options,
      id: create_fragment919.name
    });
  }
};
var MdSmokingRooms_default = MdSmokingRooms;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpa.svelte
var file920 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSpa.svelte";
function create_default_slot920(ctx) {
  let path0;
  let t;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t = space();
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M8.55 12c-1.07-.71-2.25-1.27-3.53-1.61 1.28.34 2.46.9 3.53 1.61zm10.43-1.61c-1.29.34-2.49.91-3.57 1.64 1.08-.73 2.28-1.3 3.57-1.64z");
      add_location(path0, file920, 4, 10, 151);
      attr_dev(path1, "d", "M15.49 9.63c-.18-2.79-1.31-5.51-3.43-7.63-2.14 2.14-3.32 4.86-3.55 7.63 1.28.68 2.46 1.56 3.49 2.63 1.03-1.06 2.21-1.94 3.49-2.63zm-6.5 2.65c-.14-.1-.3-.19-.45-.29.15.11.31.19.45.29zm6.42-.25c-.13.09-.27.16-.4.26.13-.1.27-.17.4-.26zM12 15.45C9.85 12.17 6.18 10 2 10c0 5.32 3.36 9.82 8.03 11.49.63.23 1.29.4 1.97.51.68-.12 1.33-.29 1.97-.51C18.64 19.82 22 15.32 22 10c-4.18 0-7.85 2.17-10 5.45z");
      add_location(path1, file920, 5, 0, 296);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t);
        detach_dev(path1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot920.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment920(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot920] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment920.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance920($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSpa", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSpa = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance920, create_fragment920, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSpa",
      options,
      id: create_fragment920.name
    });
  }
};
var MdSpa_default = MdSpa;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCake.svelte
var file921 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCake.svelte";
function create_default_slot921(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 6c1.11 0 2-.9 2-2 0-.38-.1-.73-.29-1.03L12 0l-1.71 2.97c-.19.3-.29.65-.29 1.03 0 1.1.9 2 2 2zm4.6 9.99l-1.07-1.07-1.08 1.07c-1.3 1.3-3.58 1.31-4.89 0l-1.07-1.07-1.09 1.07C6.75 16.64 5.88 17 4.96 17c-.73 0-1.4-.23-1.96-.61V21c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-4.61c-.56.38-1.23.61-1.96.61-.92 0-1.79-.36-2.44-1.01zM18 9h-5V7h-2v2H6c-1.66 0-3 1.34-3 3v1.54c0 1.08.88 1.96 1.96 1.96.52 0 1.02-.2 1.38-.57l2.14-2.13 2.13 2.13c.74.74 2.03.74 2.77 0l2.14-2.13 2.13 2.13c.37.37.86.57 1.38.57 1.08 0 1.96-.88 1.96-1.96V12C21 10.34 19.66 9 18 9z");
      add_location(path, file921, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot921.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment921(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot921] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment921.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance921($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCake", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCake = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance921, create_fragment921, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCake",
      options,
      id: create_fragment921.name
    });
  }
};
var MdCake_default = MdCake;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDomain.svelte
var file922 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdDomain.svelte";
function create_default_slot922(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z");
      add_location(path, file922, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot922.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment922(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot922] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment922.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance922($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdDomain", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdDomain = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance922, create_fragment922, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdDomain",
      options,
      id: create_fragment922.name
    });
  }
};
var MdDomain_default = MdDomain;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGroup.svelte
var file923 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGroup.svelte";
function create_default_slot923(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z");
      add_location(path, file923, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot923.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment923(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot923] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment923.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance923($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGroup", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance923, create_fragment923, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGroup",
      options,
      id: create_fragment923.name
    });
  }
};
var MdGroup_default = MdGroup;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGroupAdd.svelte
var file924 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdGroupAdd.svelte";
function create_default_slot924(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 10H5V7H3v3H0v2h3v3h2v-3h3v-2zm10 1c1.66 0 2.99-1.34 2.99-3S19.66 5 18 5c-.32 0-.63.05-.91.14.57.81.9 1.79.9 2.86s-.34 2.04-.9 2.86c.28.09.59.14.91.14zm-5 0c1.66 0 2.99-1.34 2.99-3S14.66 5 13 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm6.62 2.16c.83.73 1.38 1.66 1.38 2.84v2h3v-2c0-1.54-2.37-2.49-4.38-2.84zM13 13c-2 0-6 1-6 3v2h12v-2c0-2-4-3-6-3z");
      add_location(path, file924, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot924.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment924(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot924] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment924.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance924($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdGroupAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdGroupAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance924, create_fragment924, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdGroupAdd",
      options,
      id: create_fragment924.name
    });
  }
};
var MdGroupAdd_default = MdGroupAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationCity.svelte
var file925 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdLocationCity.svelte";
function create_default_slot925(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 11V5l-3-3-3 3v2H3v14h18V11h-6zm-8 8H5v-2h2v2zm0-4H5v-2h2v2zm0-4H5V9h2v2zm6 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V9h2v2zm0-4h-2V5h2v2zm6 12h-2v-2h2v2zm0-4h-2v-2h2v2z");
      add_location(path, file925, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot925.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment925(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot925] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment925.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance925($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdLocationCity", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdLocationCity = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance925, create_fragment925, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdLocationCity",
      options,
      id: create_fragment925.name
    });
  }
};
var MdLocationCity_default = MdLocationCity;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMood.svelte
var file926 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMood.svelte";
function create_default_slot926(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z");
      add_location(path, file926, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot926.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment926(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot926] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment926.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance926($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMood", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMood = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance926, create_fragment926, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMood",
      options,
      id: create_fragment926.name
    });
  }
};
var MdMood_default = MdMood;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoodBad.svelte
var file927 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdMoodBad.svelte";
function create_default_slot927(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 3c-2.33 0-4.31 1.46-5.11 3.5h10.22c-.8-2.04-2.78-3.5-5.11-3.5z");
      add_location(path, file927, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot927.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment927(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot927] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment927.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance927($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdMoodBad", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdMoodBad = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance927, create_fragment927, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdMoodBad",
      options,
      id: create_fragment927.name
    });
  }
};
var MdMoodBad_default = MdMoodBad;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotifications.svelte
var file928 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotifications.svelte";
function create_default_slot928(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z");
      add_location(path, file928, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot928.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment928(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot928] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment928.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance928($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNotifications", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNotifications = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance928, create_fragment928, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNotifications",
      options,
      id: create_fragment928.name
    });
  }
};
var MdNotifications_default = MdNotifications;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsActive.svelte
var file929 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsActive.svelte";
function create_default_slot929(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M7.58 4.08L6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2c.15-2.65 1.51-4.97 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43c2.02 1.45 3.39 3.77 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z");
      add_location(path, file929, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot929.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment929(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot929] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment929.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance929($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNotificationsActive", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNotificationsActive = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance929, create_fragment929, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNotificationsActive",
      options,
      id: create_fragment929.name
    });
  }
};
var MdNotificationsActive_default = MdNotificationsActive;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsNone.svelte
var file930 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsNone.svelte";
function create_default_slot930(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z");
      add_location(path, file930, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot930.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment930(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot930] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment930.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance930($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNotificationsNone", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNotificationsNone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance930, create_fragment930, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNotificationsNone",
      options,
      id: create_fragment930.name
    });
  }
};
var MdNotificationsNone_default = MdNotificationsNone;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsOff.svelte
var file931 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsOff.svelte";
function create_default_slot931(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 18.69L7.84 6.14 5.27 3.49 4 4.76l2.8 2.8v.01c-.52.99-.8 2.16-.8 3.42v5l-2 2v1h13.73l2 2L21 19.72l-1-1.03zM12 22c1.11 0 2-.89 2-2h-4c0 1.11.89 2 2 2zm6-7.32V11c0-3.08-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-.15.03-.29.08-.42.12-.1.03-.2.07-.3.11h-.01c-.01 0-.01 0-.02.01-.23.09-.46.2-.68.31 0 0-.01 0-.01.01L18 14.68z");
      add_location(path, file931, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot931.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment931(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot931] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment931.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance931($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNotificationsOff", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNotificationsOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance931, create_fragment931, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNotificationsOff",
      options,
      id: create_fragment931.name
    });
  }
};
var MdNotificationsOff_default = MdNotificationsOff;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsPaused.svelte
var file932 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdNotificationsPaused.svelte";
function create_default_slot932(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.93 6 11v5l-2 2v1h16v-1l-2-2zm-3.5-6.2l-2.8 3.4h2.8V15h-5v-1.8l2.8-3.4H9.5V8h5v1.8z");
      add_location(path, file932, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot932.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment932(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot932] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment932.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance932($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdNotificationsPaused", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdNotificationsPaused = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance932, create_fragment932, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdNotificationsPaused",
      options,
      id: create_fragment932.name
    });
  }
};
var MdNotificationsPaused_default = MdNotificationsPaused;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPages.svelte
var file933 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPages.svelte";
function create_default_slot933(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 5v6h5L7 7l4 1V3H5c-1.1 0-2 .9-2 2zm5 8H3v6c0 1.1.9 2 2 2h6v-5l-4 1 1-4zm9 4l-4-1v5h6c1.1 0 2-.9 2-2v-6h-5l1 4zm2-14h-6v5l4-1-1 4h5V5c0-1.1-.9-2-2-2z");
      add_location(path, file933, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot933.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment933(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot933] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment933.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance933($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPages", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPages = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance933, create_fragment933, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPages",
      options,
      id: create_fragment933.name
    });
  }
};
var MdPages_default = MdPages;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPartyMode.svelte
var file934 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPartyMode.svelte";
function create_default_slot934(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 3c1.63 0 3.06.79 3.98 2H12c-1.66 0-3 1.34-3 3 0 .35.07.69.18 1H7.1c-.06-.32-.1-.66-.1-1 0-2.76 2.24-5 5-5zm0 10c-1.63 0-3.06-.79-3.98-2H12c1.66 0 3-1.34 3-3 0-.35-.07-.69-.18-1h2.08c.07.32.1.66.1 1 0 2.76-2.24 5-5 5z");
      add_location(path, file934, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot934.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment934(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot934] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment934.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance934($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPartyMode", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPartyMode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance934, create_fragment934, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPartyMode",
      options,
      id: create_fragment934.name
    });
  }
};
var MdPartyMode_default = MdPartyMode;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPeople.svelte
var file935 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPeople.svelte";
function create_default_slot935(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z");
      add_location(path, file935, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot935.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment935(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot935] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment935.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance935($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPeople", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPeople = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance935, create_fragment935, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPeople",
      options,
      id: create_fragment935.name
    });
  }
};
var MdPeople_default = MdPeople;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPeopleOutline.svelte
var file936 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPeopleOutline.svelte";
function create_default_slot936(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16.5 13c-1.2 0-3.07.34-4.5 1-1.43-.67-3.3-1-4.5-1C5.33 13 1 14.08 1 16.25V19h22v-2.75c0-2.17-4.33-3.25-6.5-3.25zm-4 4.5h-10v-1.25c0-.54 2.56-1.75 5-1.75s5 1.21 5 1.75v1.25zm9 0H14v-1.25c0-.46-.2-.86-.52-1.22.88-.3 1.96-.53 3.02-.53 2.44 0 5 1.21 5 1.75v1.25zM7.5 12c1.93 0 3.5-1.57 3.5-3.5S9.43 5 7.5 5 4 6.57 4 8.5 5.57 12 7.5 12zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 5.5c1.93 0 3.5-1.57 3.5-3.5S18.43 5 16.5 5 13 6.57 13 8.5s1.57 3.5 3.5 3.5zm0-5.5c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z");
      add_location(path, file936, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot936.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment936(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot936] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment936.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance936($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPeopleOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPeopleOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance936, create_fragment936, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPeopleOutline",
      options,
      id: create_fragment936.name
    });
  }
};
var MdPeopleOutline_default = MdPeopleOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPerson.svelte
var file937 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPerson.svelte";
function create_default_slot937(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z");
      add_location(path, file937, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot937.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment937(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot937] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment937.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance937($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPerson", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPerson = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance937, create_fragment937, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPerson",
      options,
      id: create_fragment937.name
    });
  }
};
var MdPerson_default = MdPerson;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonAdd.svelte
var file938 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonAdd.svelte";
function create_default_slot938(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm-9-2V7H4v3H1v2h3v3h2v-3h3v-2H6zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z");
      add_location(path, file938, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot938.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment938(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot938] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment938.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance938($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPersonAdd", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPersonAdd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance938, create_fragment938, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPersonAdd",
      options,
      id: create_fragment938.name
    });
  }
};
var MdPersonAdd_default = MdPersonAdd;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonOutline.svelte
var file939 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPersonOutline.svelte";
function create_default_slot939(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z");
      add_location(path, file939, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot939.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment939(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot939] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment939.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance939($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPersonOutline", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPersonOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance939, create_fragment939, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPersonOutline",
      options,
      id: create_fragment939.name
    });
  }
};
var MdPersonOutline_default = MdPersonOutline;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlusOne.svelte
var file940 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPlusOne.svelte";
function create_default_slot940(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 8H8v4H4v2h4v4h2v-4h4v-2h-4zm4.5-1.92V7.9l2.5-.5V18h2V5z");
      add_location(path, file940, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot940.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment940(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot940] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment940.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance940($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPlusOne", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPlusOne = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance940, create_fragment940, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPlusOne",
      options,
      id: create_fragment940.name
    });
  }
};
var MdPlusOne_default = MdPlusOne;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPoll.svelte
var file941 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPoll.svelte";
function create_default_slot941(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z");
      add_location(path, file941, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot941.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment941(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot941] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment941.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance941($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPoll", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPoll = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance941, create_fragment941, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPoll",
      options,
      id: create_fragment941.name
    });
  }
};
var MdPoll_default = MdPoll;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPublic.svelte
var file942 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdPublic.svelte";
function create_default_slot942(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z");
      add_location(path, file942, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot942.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment942(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot942] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment942.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance942($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdPublic", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdPublic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance942, create_fragment942, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdPublic",
      options,
      id: create_fragment942.name
    });
  }
};
var MdPublic_default = MdPublic;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSchool.svelte
var file943 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSchool.svelte";
function create_default_slot943(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z");
      add_location(path, file943, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot943.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment943(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot943] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment943.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance943($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSchool", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSchool = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance943, create_fragment943, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSchool",
      options,
      id: create_fragment943.name
    });
  }
};
var MdSchool_default = MdSchool;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentDissatisfied.svelte
var file944 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentDissatisfied.svelte";
function create_default_slot944(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file944, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file944, 5, 0, 174);
      attr_dev(path2, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-6c-2.33 0-4.32 1.45-5.12 3.5h1.67c.69-1.19 1.97-2 3.45-2s2.75.81 3.45 2h1.67c-.8-2.05-2.79-3.5-5.12-3.5z");
      add_location(path2, file944, 6, 0, 197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot944.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment944(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot944] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment944.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance944($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSentimentDissatisfied", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSentimentDissatisfied = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance944, create_fragment944, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSentimentDissatisfied",
      options,
      id: create_fragment944.name
    });
  }
};
var MdSentimentDissatisfied_default = MdSentimentDissatisfied;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentNeutral.svelte
var file945 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentNeutral.svelte";
function create_default_slot945(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  let t2;
  let path3;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      t2 = space();
      path3 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      t2 = claim_space(nodes);
      path3 = claim_svg_element(nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M9 14h6v1.5H9z");
      add_location(path0, file945, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file945, 5, 0, 179);
      attr_dev(path2, "d", "undefined");
      add_location(path2, file945, 6, 0, 202);
      attr_dev(path3, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z");
      add_location(path3, file945, 7, 0, 225);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, path3, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
        detach_dev(t2);
        detach_dev(path3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot945.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment945(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot945] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment945.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance945($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSentimentNeutral", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSentimentNeutral = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance945, create_fragment945, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSentimentNeutral",
      options,
      id: create_fragment945.name
    });
  }
};
var MdSentimentNeutral_default = MdSentimentNeutral;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentSatisfied.svelte
var file946 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentSatisfied.svelte";
function create_default_slot946(ctx) {
  let path0;
  let t0;
  let path1;
  let t1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      t0 = space();
      path1 = svg_element("path");
      t1 = space();
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      t0 = claim_space(nodes);
      path1 = claim_svg_element(nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      t1 = claim_space(nodes);
      path2 = claim_svg_element(nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "undefined");
      add_location(path0, file946, 4, 10, 151);
      attr_dev(path1, "d", "undefined");
      add_location(path1, file946, 5, 0, 174);
      attr_dev(path2, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-4c-1.48 0-2.75-.81-3.45-2H6.88c.8 2.05 2.79 3.5 5.12 3.5s4.32-1.45 5.12-3.5h-1.67c-.7 1.19-1.97 2-3.45 2z");
      add_location(path2, file946, 6, 0, 197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path0);
        detach_dev(t0);
        detach_dev(path1);
        detach_dev(t1);
        detach_dev(path2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot946.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment946(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot946] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment946.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance946($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSentimentSatisfied", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSentimentSatisfied = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance946, create_fragment946, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSentimentSatisfied",
      options,
      id: create_fragment946.name
    });
  }
};
var MdSentimentSatisfied_default = MdSentimentSatisfied;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentVeryDissatisfied.svelte
var file947 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentVeryDissatisfied.svelte";
function create_default_slot947(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.47 2 12s4.47 10 9.99 10S22 17.53 22 12 17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm4.18-12.24l-1.06 1.06-1.06-1.06L13 8.82l1.06 1.06L13 10.94 14.06 12l1.06-1.06L16.18 12l1.06-1.06-1.06-1.06 1.06-1.06zM7.82 12l1.06-1.06L9.94 12 11 10.94 9.94 9.88 11 8.82 9.94 7.76 8.88 8.82 7.82 7.76 6.76 8.82l1.06 1.06-1.06 1.06zM12 14c-2.33 0-4.31 1.46-5.11 3.5h10.22c-.8-2.04-2.78-3.5-5.11-3.5z");
      add_location(path, file947, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot947.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment947(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot947] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment947.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance947($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSentimentVeryDissatisfied", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSentimentVeryDissatisfied = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance947, create_fragment947, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSentimentVeryDissatisfied",
      options,
      id: create_fragment947.name
    });
  }
};
var MdSentimentVeryDissatisfied_default = MdSentimentVeryDissatisfied;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentVerySatisfied.svelte
var file948 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdSentimentVerySatisfied.svelte";
function create_default_slot948(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.99 2C6.47 2 2 6.47 2 12s4.47 10 9.99 10S22 17.53 22 12 17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm1-10.06L14.06 11l1.06-1.06L16.18 11l1.06-1.06-2.12-2.12zm-4.12 0L9.94 11 11 9.94 8.88 7.82 6.76 9.94 7.82 11zM12 17.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z");
      add_location(path, file948, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot948.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment948(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot948] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment948.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance948($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdSentimentVerySatisfied", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdSentimentVerySatisfied = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance948, create_fragment948, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdSentimentVerySatisfied",
      options,
      id: create_fragment948.name
    });
  }
};
var MdSentimentVerySatisfied_default = MdSentimentVerySatisfied;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShare.svelte
var file949 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdShare.svelte";
function create_default_slot949(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z");
      add_location(path, file949, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot949.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment949(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot949] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment949.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance949($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdShare", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdShare = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance949, create_fragment949, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdShare",
      options,
      id: create_fragment949.name
    });
  }
};
var MdShare_default = MdShare;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWhatshot.svelte
var file950 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdWhatshot.svelte";
function create_default_slot950(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13.5.67s.74 2.65.74 4.8c0 2.06-1.35 3.73-3.41 3.73-2.07 0-3.63-1.67-3.63-3.73l.03-.36C5.21 7.51 4 10.62 4 14c0 4.42 3.58 8 8 8s8-3.58 8-8C20 8.61 17.41 3.8 13.5.67zM11.71 19c-1.78 0-3.22-1.4-3.22-3.14 0-1.62 1.05-2.76 2.81-3.12 1.77-.36 3.6-1.21 4.62-2.58.39 1.29.59 2.65.59 4.04 0 2.65-2.15 4.8-4.8 4.8z");
      add_location(path, file950, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot950.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment950(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot950] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment950.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance950($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdWhatshot", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdWhatshot = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance950, create_fragment950, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdWhatshot",
      options,
      id: create_fragment950.name
    });
  }
};
var MdWhatshot_default = MdWhatshot;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheckBox.svelte
var file951 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheckBox.svelte";
function create_default_slot951(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
      add_location(path, file951, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot951.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment951(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot951] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment951.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance951($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCheckBox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCheckBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance951, create_fragment951, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCheckBox",
      options,
      id: create_fragment951.name
    });
  }
};
var MdCheckBox_default = MdCheckBox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheckBoxOutlineBlank.svelte
var file952 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdCheckBoxOutlineBlank.svelte";
function create_default_slot952(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
      add_location(path, file952, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot952.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment952(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot952] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment952.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance952($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdCheckBoxOutlineBlank", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdCheckBoxOutlineBlank = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance952, create_fragment952, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdCheckBoxOutlineBlank",
      options,
      id: create_fragment952.name
    });
  }
};
var MdCheckBoxOutlineBlank_default = MdCheckBoxOutlineBlank;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdIndeterminateCheckBox.svelte
var file953 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdIndeterminateCheckBox.svelte";
function create_default_slot953(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z");
      add_location(path, file953, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot953.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment953(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot953] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment953.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance953($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdIndeterminateCheckBox", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdIndeterminateCheckBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance953, create_fragment953, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdIndeterminateCheckBox",
      options,
      id: create_fragment953.name
    });
  }
};
var MdIndeterminateCheckBox_default = MdIndeterminateCheckBox;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRadioButtonChecked.svelte
var file954 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRadioButtonChecked.svelte";
function create_default_slot954(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z");
      add_location(path, file954, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot954.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment954(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot954] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment954.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance954($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRadioButtonChecked", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRadioButtonChecked = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance954, create_fragment954, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRadioButtonChecked",
      options,
      id: create_fragment954.name
    });
  }
};
var MdRadioButtonChecked_default = MdRadioButtonChecked;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRadioButtonUnchecked.svelte
var file955 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdRadioButtonUnchecked.svelte";
function create_default_slot955(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z");
      add_location(path, file955, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot955.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment955(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot955] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment955.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance955($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdRadioButtonUnchecked", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdRadioButtonUnchecked = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance955, create_fragment955, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdRadioButtonUnchecked",
      options,
      id: create_fragment955.name
    });
  }
};
var MdRadioButtonUnchecked_default = MdRadioButtonUnchecked;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStar.svelte
var file956 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStar.svelte";
function create_default_slot956(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z");
      add_location(path, file956, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot956.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment956(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot956] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment956.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance956($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStar", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance956, create_fragment956, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStar",
      options,
      id: create_fragment956.name
    });
  }
};
var MdStar_default = MdStar;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStarBorder.svelte
var file957 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStarBorder.svelte";
function create_default_slot957(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z");
      add_location(path, file957, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot957.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment957(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot957] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment957.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance957($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStarBorder", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStarBorder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance957, create_fragment957, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStarBorder",
      options,
      id: create_fragment957.name
    });
  }
};
var MdStarBorder_default = MdStarBorder;

// node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStarHalf.svelte
var file958 = "node_modules/.pnpm/svelte-icons@2.1.0/node_modules/svelte-icons/md/MdStarHalf.svelte";
function create_default_slot958(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z");
      add_location(path, file958, 4, 10, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot958.name,
    type: "slot",
    source: '(4:8) <IconBase viewBox=\\"0 0 24 24\\" {...$$props}>',
    ctx
  });
  return block;
}
function create_fragment958(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 24 24" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot958] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(iconbase.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconbase.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment958.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance958($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MdStarHalf", slots, []);
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({ IconBase: IconBase_default });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var MdStarHalf = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance958, create_fragment958, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MdStarHalf",
      options,
      id: create_fragment958.name
    });
  }
};
var MdStarHalf_default = MdStarHalf;
export {
  Md3DRotation_default as Md3DRotation,
  MdAcUnit_default as MdAcUnit,
  MdAccessAlarm_default as MdAccessAlarm,
  MdAccessAlarms_default as MdAccessAlarms,
  MdAccessTime_default as MdAccessTime,
  MdAccessibility_default as MdAccessibility,
  MdAccessible_default as MdAccessible,
  MdAccountBalance_default as MdAccountBalance,
  MdAccountBalanceWallet_default as MdAccountBalanceWallet,
  MdAccountBox_default as MdAccountBox,
  MdAccountCircle_default as MdAccountCircle,
  MdAdb_default as MdAdb,
  MdAdd_default as MdAdd,
  MdAddAPhoto_default as MdAddAPhoto,
  MdAddAlarm_default as MdAddAlarm,
  MdAddAlert_default as MdAddAlert,
  MdAddBox_default as MdAddBox,
  MdAddCircle_default as MdAddCircle,
  MdAddCircleOutline_default as MdAddCircleOutline,
  MdAddLocation_default as MdAddLocation,
  MdAddShoppingCart_default as MdAddShoppingCart,
  MdAddToPhotos_default as MdAddToPhotos,
  MdAddToQueue_default as MdAddToQueue,
  MdAdjust_default as MdAdjust,
  MdAirlineSeatFlat_default as MdAirlineSeatFlat,
  MdAirlineSeatFlatAngled_default as MdAirlineSeatFlatAngled,
  MdAirlineSeatIndividualSuite_default as MdAirlineSeatIndividualSuite,
  MdAirlineSeatLegroomExtra_default as MdAirlineSeatLegroomExtra,
  MdAirlineSeatLegroomNormal_default as MdAirlineSeatLegroomNormal,
  MdAirlineSeatLegroomReduced_default as MdAirlineSeatLegroomReduced,
  MdAirlineSeatReclineExtra_default as MdAirlineSeatReclineExtra,
  MdAirlineSeatReclineNormal_default as MdAirlineSeatReclineNormal,
  MdAirplanemodeActive_default as MdAirplanemodeActive,
  MdAirplanemodeInactive_default as MdAirplanemodeInactive,
  MdAirplay_default as MdAirplay,
  MdAirportShuttle_default as MdAirportShuttle,
  MdAlarm_default as MdAlarm,
  MdAlarmAdd_default as MdAlarmAdd,
  MdAlarmOff_default as MdAlarmOff,
  MdAlarmOn_default as MdAlarmOn,
  MdAlbum_default as MdAlbum,
  MdAllInclusive_default as MdAllInclusive,
  MdAllOut_default as MdAllOut,
  MdAndroid_default as MdAndroid,
  MdAnnouncement_default as MdAnnouncement,
  MdApps_default as MdApps,
  MdArchive_default as MdArchive,
  MdArrowBack_default as MdArrowBack,
  MdArrowDownward_default as MdArrowDownward,
  MdArrowDropDown_default as MdArrowDropDown,
  MdArrowDropDownCircle_default as MdArrowDropDownCircle,
  MdArrowDropUp_default as MdArrowDropUp,
  MdArrowForward_default as MdArrowForward,
  MdArrowUpward_default as MdArrowUpward,
  MdArtTrack_default as MdArtTrack,
  MdAspectRatio_default as MdAspectRatio,
  MdAssessment_default as MdAssessment,
  MdAssignment_default as MdAssignment,
  MdAssignmentInd_default as MdAssignmentInd,
  MdAssignmentLate_default as MdAssignmentLate,
  MdAssignmentReturn_default as MdAssignmentReturn,
  MdAssignmentReturned_default as MdAssignmentReturned,
  MdAssignmentTurnedIn_default as MdAssignmentTurnedIn,
  MdAssistant_default as MdAssistant,
  MdAssistantPhoto_default as MdAssistantPhoto,
  MdAttachFile_default as MdAttachFile,
  MdAttachMoney_default as MdAttachMoney,
  MdAttachment_default as MdAttachment,
  MdAudiotrack_default as MdAudiotrack,
  MdAutorenew_default as MdAutorenew,
  MdAvTimer_default as MdAvTimer,
  MdBackspace_default as MdBackspace,
  MdBackup_default as MdBackup,
  MdBattery20_default as MdBattery20,
  MdBattery30_default as MdBattery30,
  MdBattery50_default as MdBattery50,
  MdBattery60_default as MdBattery60,
  MdBattery80_default as MdBattery80,
  MdBattery90_default as MdBattery90,
  MdBatteryAlert_default as MdBatteryAlert,
  MdBatteryCharging20_default as MdBatteryCharging20,
  MdBatteryCharging30_default as MdBatteryCharging30,
  MdBatteryCharging50_default as MdBatteryCharging50,
  MdBatteryCharging60_default as MdBatteryCharging60,
  MdBatteryCharging80_default as MdBatteryCharging80,
  MdBatteryCharging90_default as MdBatteryCharging90,
  MdBatteryChargingFull_default as MdBatteryChargingFull,
  MdBatteryFull_default as MdBatteryFull,
  MdBatteryStd_default as MdBatteryStd,
  MdBatteryUnknown_default as MdBatteryUnknown,
  MdBeachAccess_default as MdBeachAccess,
  MdBeenhere_default as MdBeenhere,
  MdBlock_default as MdBlock,
  MdBluetooth_default as MdBluetooth,
  MdBluetoothAudio_default as MdBluetoothAudio,
  MdBluetoothConnected_default as MdBluetoothConnected,
  MdBluetoothDisabled_default as MdBluetoothDisabled,
  MdBluetoothSearching_default as MdBluetoothSearching,
  MdBlurCircular_default as MdBlurCircular,
  MdBlurLinear_default as MdBlurLinear,
  MdBlurOff_default as MdBlurOff,
  MdBlurOn_default as MdBlurOn,
  MdBook_default as MdBook,
  MdBookmark_default as MdBookmark,
  MdBookmarkBorder_default as MdBookmarkBorder,
  MdBorderAll_default as MdBorderAll,
  MdBorderBottom_default as MdBorderBottom,
  MdBorderClear_default as MdBorderClear,
  MdBorderColor_default as MdBorderColor,
  MdBorderHorizontal_default as MdBorderHorizontal,
  MdBorderInner_default as MdBorderInner,
  MdBorderLeft_default as MdBorderLeft,
  MdBorderOuter_default as MdBorderOuter,
  MdBorderRight_default as MdBorderRight,
  MdBorderStyle_default as MdBorderStyle,
  MdBorderTop_default as MdBorderTop,
  MdBorderVertical_default as MdBorderVertical,
  MdBrandingWatermark_default as MdBrandingWatermark,
  MdBrightness1_default as MdBrightness1,
  MdBrightness2_default as MdBrightness2,
  MdBrightness3_default as MdBrightness3,
  MdBrightness4_default as MdBrightness4,
  MdBrightness5_default as MdBrightness5,
  MdBrightness6_default as MdBrightness6,
  MdBrightness7_default as MdBrightness7,
  MdBrightnessAuto_default as MdBrightnessAuto,
  MdBrightnessHigh_default as MdBrightnessHigh,
  MdBrightnessLow_default as MdBrightnessLow,
  MdBrightnessMedium_default as MdBrightnessMedium,
  MdBrokenImage_default as MdBrokenImage,
  MdBrush_default as MdBrush,
  MdBubbleChart_default as MdBubbleChart,
  MdBugReport_default as MdBugReport,
  MdBuild_default as MdBuild,
  MdBurstMode_default as MdBurstMode,
  MdBusiness_default as MdBusiness,
  MdBusinessCenter_default as MdBusinessCenter,
  MdCached_default as MdCached,
  MdCake_default as MdCake,
  MdCall_default as MdCall,
  MdCallEnd_default as MdCallEnd,
  MdCallMade_default as MdCallMade,
  MdCallMerge_default as MdCallMerge,
  MdCallMissed_default as MdCallMissed,
  MdCallMissedOutgoing_default as MdCallMissedOutgoing,
  MdCallReceived_default as MdCallReceived,
  MdCallSplit_default as MdCallSplit,
  MdCallToAction_default as MdCallToAction,
  MdCamera_default as MdCamera,
  MdCameraAlt_default as MdCameraAlt,
  MdCameraEnhance_default as MdCameraEnhance,
  MdCameraFront_default as MdCameraFront,
  MdCameraRear_default as MdCameraRear,
  MdCameraRoll_default as MdCameraRoll,
  MdCancel_default as MdCancel,
  MdCardGiftcard_default as MdCardGiftcard,
  MdCardMembership_default as MdCardMembership,
  MdCardTravel_default as MdCardTravel,
  MdCasino_default as MdCasino,
  MdCast_default as MdCast,
  MdCastConnected_default as MdCastConnected,
  MdCenterFocusStrong_default as MdCenterFocusStrong,
  MdCenterFocusWeak_default as MdCenterFocusWeak,
  MdChangeHistory_default as MdChangeHistory,
  MdChat_default as MdChat,
  MdChatBubble_default as MdChatBubble,
  MdChatBubbleOutline_default as MdChatBubbleOutline,
  MdCheck_default as MdCheck,
  MdCheckBox_default as MdCheckBox,
  MdCheckBoxOutlineBlank_default as MdCheckBoxOutlineBlank,
  MdCheckCircle_default as MdCheckCircle,
  MdChevronLeft_default as MdChevronLeft,
  MdChevronRight_default as MdChevronRight,
  MdChildCare_default as MdChildCare,
  MdChildFriendly_default as MdChildFriendly,
  MdChromeReaderMode_default as MdChromeReaderMode,
  MdClass_default as MdClass,
  MdClear_default as MdClear,
  MdClearAll_default as MdClearAll,
  MdClose_default as MdClose,
  MdClosedCaption_default as MdClosedCaption,
  MdCloud_default as MdCloud,
  MdCloudCircle_default as MdCloudCircle,
  MdCloudDone_default as MdCloudDone,
  MdCloudDownload_default as MdCloudDownload,
  MdCloudOff_default as MdCloudOff,
  MdCloudQueue_default as MdCloudQueue,
  MdCloudUpload_default as MdCloudUpload,
  MdCode_default as MdCode,
  MdCollections_default as MdCollections,
  MdCollectionsBookmark_default as MdCollectionsBookmark,
  MdColorLens_default as MdColorLens,
  MdColorize_default as MdColorize,
  MdComment_default as MdComment,
  MdCompare_default as MdCompare,
  MdCompareArrows_default as MdCompareArrows,
  MdComputer_default as MdComputer,
  MdConfirmationNumber_default as MdConfirmationNumber,
  MdContactMail_default as MdContactMail,
  MdContactPhone_default as MdContactPhone,
  MdContacts_default as MdContacts,
  MdContentCopy_default as MdContentCopy,
  MdContentCut_default as MdContentCut,
  MdContentPaste_default as MdContentPaste,
  MdControlPoint_default as MdControlPoint,
  MdControlPointDuplicate_default as MdControlPointDuplicate,
  MdCopyright_default as MdCopyright,
  MdCreate_default as MdCreate,
  MdCreateNewFolder_default as MdCreateNewFolder,
  MdCreditCard_default as MdCreditCard,
  MdCrop_default as MdCrop,
  MdCrop169_default as MdCrop169,
  MdCrop32_default as MdCrop32,
  MdCrop54_default as MdCrop54,
  MdCrop75_default as MdCrop75,
  MdCropDin_default as MdCropDin,
  MdCropFree_default as MdCropFree,
  MdCropLandscape_default as MdCropLandscape,
  MdCropOriginal_default as MdCropOriginal,
  MdCropPortrait_default as MdCropPortrait,
  MdCropRotate_default as MdCropRotate,
  MdCropSquare_default as MdCropSquare,
  MdDashboard_default as MdDashboard,
  MdDataUsage_default as MdDataUsage,
  MdDateRange_default as MdDateRange,
  MdDehaze_default as MdDehaze,
  MdDelete_default as MdDelete,
  MdDeleteForever_default as MdDeleteForever,
  MdDeleteSweep_default as MdDeleteSweep,
  MdDescription_default as MdDescription,
  MdDesktopMac_default as MdDesktopMac,
  MdDesktopWindows_default as MdDesktopWindows,
  MdDetails_default as MdDetails,
  MdDeveloperBoard_default as MdDeveloperBoard,
  MdDeveloperMode_default as MdDeveloperMode,
  MdDeviceHub_default as MdDeviceHub,
  MdDevices_default as MdDevices,
  MdDevicesOther_default as MdDevicesOther,
  MdDialerSip_default as MdDialerSip,
  MdDialpad_default as MdDialpad,
  MdDirections_default as MdDirections,
  MdDirectionsBike_default as MdDirectionsBike,
  MdDirectionsBoat_default as MdDirectionsBoat,
  MdDirectionsBus_default as MdDirectionsBus,
  MdDirectionsCar_default as MdDirectionsCar,
  MdDirectionsRailway_default as MdDirectionsRailway,
  MdDirectionsRun_default as MdDirectionsRun,
  MdDirectionsSubway_default as MdDirectionsSubway,
  MdDirectionsTransit_default as MdDirectionsTransit,
  MdDirectionsWalk_default as MdDirectionsWalk,
  MdDiscFull_default as MdDiscFull,
  MdDns_default as MdDns,
  MdDoNotDisturb_default as MdDoNotDisturb,
  MdDoNotDisturbAlt_default as MdDoNotDisturbAlt,
  MdDoNotDisturbOff_default as MdDoNotDisturbOff,
  MdDoNotDisturbOn_default as MdDoNotDisturbOn,
  MdDock_default as MdDock,
  MdDomain_default as MdDomain,
  MdDone_default as MdDone,
  MdDoneAll_default as MdDoneAll,
  MdDonutLarge_default as MdDonutLarge,
  MdDonutSmall_default as MdDonutSmall,
  MdDrafts_default as MdDrafts,
  MdDragHandle_default as MdDragHandle,
  MdDriveEta_default as MdDriveEta,
  MdDvr_default as MdDvr,
  MdEdit_default as MdEdit,
  MdEditLocation_default as MdEditLocation,
  MdEject_default as MdEject,
  MdEmail_default as MdEmail,
  MdEnhancedEncryption_default as MdEnhancedEncryption,
  MdEqualizer_default as MdEqualizer,
  MdError_default as MdError,
  MdErrorOutline_default as MdErrorOutline,
  MdEuroSymbol_default as MdEuroSymbol,
  MdEvStation_default as MdEvStation,
  MdEvent_default as MdEvent,
  MdEventAvailable_default as MdEventAvailable,
  MdEventBusy_default as MdEventBusy,
  MdEventNote_default as MdEventNote,
  MdEventSeat_default as MdEventSeat,
  MdExitToApp_default as MdExitToApp,
  MdExpandLess_default as MdExpandLess,
  MdExpandMore_default as MdExpandMore,
  MdExplicit_default as MdExplicit,
  MdExplore_default as MdExplore,
  MdExposure_default as MdExposure,
  MdExposureNeg1_default as MdExposureNeg1,
  MdExposureNeg2_default as MdExposureNeg2,
  MdExposurePlus1_default as MdExposurePlus1,
  MdExposurePlus2_default as MdExposurePlus2,
  MdExposureZero_default as MdExposureZero,
  MdExtension_default as MdExtension,
  MdFace_default as MdFace,
  MdFastForward_default as MdFastForward,
  MdFastRewind_default as MdFastRewind,
  MdFavorite_default as MdFavorite,
  MdFavoriteBorder_default as MdFavoriteBorder,
  MdFeaturedPlayList_default as MdFeaturedPlayList,
  MdFeaturedVideo_default as MdFeaturedVideo,
  MdFeedback_default as MdFeedback,
  MdFiberDvr_default as MdFiberDvr,
  MdFiberManualRecord_default as MdFiberManualRecord,
  MdFiberNew_default as MdFiberNew,
  MdFiberPin_default as MdFiberPin,
  MdFiberSmartRecord_default as MdFiberSmartRecord,
  MdFileDownload_default as MdFileDownload,
  MdFileUpload_default as MdFileUpload,
  MdFilter_default as MdFilter,
  MdFilter1_default as MdFilter1,
  MdFilter2_default as MdFilter2,
  MdFilter3_default as MdFilter3,
  MdFilter4_default as MdFilter4,
  MdFilter5_default as MdFilter5,
  MdFilter6_default as MdFilter6,
  MdFilter7_default as MdFilter7,
  MdFilter8_default as MdFilter8,
  MdFilter9_default as MdFilter9,
  MdFilter9Plus_default as MdFilter9Plus,
  MdFilterBAndW_default as MdFilterBAndW,
  MdFilterCenterFocus_default as MdFilterCenterFocus,
  MdFilterDrama_default as MdFilterDrama,
  MdFilterFrames_default as MdFilterFrames,
  MdFilterHdr_default as MdFilterHdr,
  MdFilterList_default as MdFilterList,
  MdFilterNone_default as MdFilterNone,
  MdFilterTiltShift_default as MdFilterTiltShift,
  MdFilterVintage_default as MdFilterVintage,
  MdFindInPage_default as MdFindInPage,
  MdFindReplace_default as MdFindReplace,
  MdFingerprint_default as MdFingerprint,
  MdFirstPage_default as MdFirstPage,
  MdFitnessCenter_default as MdFitnessCenter,
  MdFlag_default as MdFlag,
  MdFlare_default as MdFlare,
  MdFlashAuto_default as MdFlashAuto,
  MdFlashOff_default as MdFlashOff,
  MdFlashOn_default as MdFlashOn,
  MdFlight_default as MdFlight,
  MdFlightLand_default as MdFlightLand,
  MdFlightTakeoff_default as MdFlightTakeoff,
  MdFlip_default as MdFlip,
  MdFlipToBack_default as MdFlipToBack,
  MdFlipToFront_default as MdFlipToFront,
  MdFolder_default as MdFolder,
  MdFolderOpen_default as MdFolderOpen,
  MdFolderShared_default as MdFolderShared,
  MdFolderSpecial_default as MdFolderSpecial,
  MdFontDownload_default as MdFontDownload,
  MdFormatAlignCenter_default as MdFormatAlignCenter,
  MdFormatAlignJustify_default as MdFormatAlignJustify,
  MdFormatAlignLeft_default as MdFormatAlignLeft,
  MdFormatAlignRight_default as MdFormatAlignRight,
  MdFormatBold_default as MdFormatBold,
  MdFormatClear_default as MdFormatClear,
  MdFormatColorFill_default as MdFormatColorFill,
  MdFormatColorReset_default as MdFormatColorReset,
  MdFormatColorText_default as MdFormatColorText,
  MdFormatIndentDecrease_default as MdFormatIndentDecrease,
  MdFormatIndentIncrease_default as MdFormatIndentIncrease,
  MdFormatItalic_default as MdFormatItalic,
  MdFormatLineSpacing_default as MdFormatLineSpacing,
  MdFormatListBulleted_default as MdFormatListBulleted,
  MdFormatListNumbered_default as MdFormatListNumbered,
  MdFormatPaint_default as MdFormatPaint,
  MdFormatQuote_default as MdFormatQuote,
  MdFormatShapes_default as MdFormatShapes,
  MdFormatSize_default as MdFormatSize,
  MdFormatStrikethrough_default as MdFormatStrikethrough,
  MdFormatTextdirectionLToR_default as MdFormatTextdirectionLToR,
  MdFormatTextdirectionRToL_default as MdFormatTextdirectionRToL,
  MdFormatUnderlined_default as MdFormatUnderlined,
  MdForum_default as MdForum,
  MdForward_default as MdForward,
  MdForward10_default as MdForward10,
  MdForward30_default as MdForward30,
  MdForward5_default as MdForward5,
  MdFreeBreakfast_default as MdFreeBreakfast,
  MdFullscreen_default as MdFullscreen,
  MdFullscreenExit_default as MdFullscreenExit,
  MdFunctions_default as MdFunctions,
  MdGTranslate_default as MdGTranslate,
  MdGamepad_default as MdGamepad,
  MdGames_default as MdGames,
  MdGavel_default as MdGavel,
  MdGesture_default as MdGesture,
  MdGetApp_default as MdGetApp,
  MdGif_default as MdGif,
  MdGolfCourse_default as MdGolfCourse,
  MdGpsFixed_default as MdGpsFixed,
  MdGpsNotFixed_default as MdGpsNotFixed,
  MdGpsOff_default as MdGpsOff,
  MdGrade_default as MdGrade,
  MdGradient_default as MdGradient,
  MdGrain_default as MdGrain,
  MdGraphicEq_default as MdGraphicEq,
  MdGridOff_default as MdGridOff,
  MdGridOn_default as MdGridOn,
  MdGroup_default as MdGroup,
  MdGroupAdd_default as MdGroupAdd,
  MdGroupWork_default as MdGroupWork,
  MdHd_default as MdHd,
  MdHdrOff_default as MdHdrOff,
  MdHdrOn_default as MdHdrOn,
  MdHdrStrong_default as MdHdrStrong,
  MdHdrWeak_default as MdHdrWeak,
  MdHeadset_default as MdHeadset,
  MdHeadsetMic_default as MdHeadsetMic,
  MdHealing_default as MdHealing,
  MdHearing_default as MdHearing,
  MdHelp_default as MdHelp,
  MdHelpOutline_default as MdHelpOutline,
  MdHighQuality_default as MdHighQuality,
  MdHighlight_default as MdHighlight,
  MdHighlightOff_default as MdHighlightOff,
  MdHistory_default as MdHistory,
  MdHome_default as MdHome,
  MdHotTub_default as MdHotTub,
  MdHotel_default as MdHotel,
  MdHourglassEmpty_default as MdHourglassEmpty,
  MdHourglassFull_default as MdHourglassFull,
  MdHttp_default as MdHttp,
  MdHttps_default as MdHttps,
  MdImage_default as MdImage,
  MdImageAspectRatio_default as MdImageAspectRatio,
  MdImportContacts_default as MdImportContacts,
  MdImportExport_default as MdImportExport,
  MdImportantDevices_default as MdImportantDevices,
  MdInbox_default as MdInbox,
  MdIndeterminateCheckBox_default as MdIndeterminateCheckBox,
  MdInfo_default as MdInfo,
  MdInfoOutline_default as MdInfoOutline,
  MdInput_default as MdInput,
  MdInsertChart_default as MdInsertChart,
  MdInsertComment_default as MdInsertComment,
  MdInsertDriveFile_default as MdInsertDriveFile,
  MdInsertEmoticon_default as MdInsertEmoticon,
  MdInsertInvitation_default as MdInsertInvitation,
  MdInsertLink_default as MdInsertLink,
  MdInsertPhoto_default as MdInsertPhoto,
  MdInvertColors_default as MdInvertColors,
  MdInvertColorsOff_default as MdInvertColorsOff,
  MdIso_default as MdIso,
  MdKeyboard_default as MdKeyboard,
  MdKeyboardArrowDown_default as MdKeyboardArrowDown,
  MdKeyboardArrowLeft_default as MdKeyboardArrowLeft,
  MdKeyboardArrowRight_default as MdKeyboardArrowRight,
  MdKeyboardArrowUp_default as MdKeyboardArrowUp,
  MdKeyboardBackspace_default as MdKeyboardBackspace,
  MdKeyboardCapslock_default as MdKeyboardCapslock,
  MdKeyboardHide_default as MdKeyboardHide,
  MdKeyboardReturn_default as MdKeyboardReturn,
  MdKeyboardTab_default as MdKeyboardTab,
  MdKeyboardVoice_default as MdKeyboardVoice,
  MdKitchen_default as MdKitchen,
  MdLabel_default as MdLabel,
  MdLabelOutline_default as MdLabelOutline,
  MdLandscape_default as MdLandscape,
  MdLanguage_default as MdLanguage,
  MdLaptop_default as MdLaptop,
  MdLaptopChromebook_default as MdLaptopChromebook,
  MdLaptopMac_default as MdLaptopMac,
  MdLaptopWindows_default as MdLaptopWindows,
  MdLastPage_default as MdLastPage,
  MdLaunch_default as MdLaunch,
  MdLayers_default as MdLayers,
  MdLayersClear_default as MdLayersClear,
  MdLeakAdd_default as MdLeakAdd,
  MdLeakRemove_default as MdLeakRemove,
  MdLens_default as MdLens,
  MdLibraryAdd_default as MdLibraryAdd,
  MdLibraryBooks_default as MdLibraryBooks,
  MdLibraryMusic_default as MdLibraryMusic,
  MdLightbulbOutline_default as MdLightbulbOutline,
  MdLineStyle_default as MdLineStyle,
  MdLineWeight_default as MdLineWeight,
  MdLinearScale_default as MdLinearScale,
  MdLink_default as MdLink,
  MdLinkedCamera_default as MdLinkedCamera,
  MdList_default as MdList,
  MdLiveHelp_default as MdLiveHelp,
  MdLiveTv_default as MdLiveTv,
  MdLocalActivity_default as MdLocalActivity,
  MdLocalAirport_default as MdLocalAirport,
  MdLocalAtm_default as MdLocalAtm,
  MdLocalBar_default as MdLocalBar,
  MdLocalCafe_default as MdLocalCafe,
  MdLocalCarWash_default as MdLocalCarWash,
  MdLocalConvenienceStore_default as MdLocalConvenienceStore,
  MdLocalDining_default as MdLocalDining,
  MdLocalDrink_default as MdLocalDrink,
  MdLocalFlorist_default as MdLocalFlorist,
  MdLocalGasStation_default as MdLocalGasStation,
  MdLocalGroceryStore_default as MdLocalGroceryStore,
  MdLocalHospital_default as MdLocalHospital,
  MdLocalHotel_default as MdLocalHotel,
  MdLocalLaundryService_default as MdLocalLaundryService,
  MdLocalLibrary_default as MdLocalLibrary,
  MdLocalMall_default as MdLocalMall,
  MdLocalMovies_default as MdLocalMovies,
  MdLocalOffer_default as MdLocalOffer,
  MdLocalParking_default as MdLocalParking,
  MdLocalPharmacy_default as MdLocalPharmacy,
  MdLocalPhone_default as MdLocalPhone,
  MdLocalPizza_default as MdLocalPizza,
  MdLocalPlay_default as MdLocalPlay,
  MdLocalPostOffice_default as MdLocalPostOffice,
  MdLocalPrintshop_default as MdLocalPrintshop,
  MdLocalSee_default as MdLocalSee,
  MdLocalShipping_default as MdLocalShipping,
  MdLocalTaxi_default as MdLocalTaxi,
  MdLocationCity_default as MdLocationCity,
  MdLocationDisabled_default as MdLocationDisabled,
  MdLocationOff_default as MdLocationOff,
  MdLocationOn_default as MdLocationOn,
  MdLocationSearching_default as MdLocationSearching,
  MdLock_default as MdLock,
  MdLockOpen_default as MdLockOpen,
  MdLockOutline_default as MdLockOutline,
  MdLooks_default as MdLooks,
  MdLooks3_default as MdLooks3,
  MdLooks4_default as MdLooks4,
  MdLooks5_default as MdLooks5,
  MdLooks6_default as MdLooks6,
  MdLooksOne_default as MdLooksOne,
  MdLooksTwo_default as MdLooksTwo,
  MdLoop_default as MdLoop,
  MdLoupe_default as MdLoupe,
  MdLowPriority_default as MdLowPriority,
  MdLoyalty_default as MdLoyalty,
  MdMail_default as MdMail,
  MdMailOutline_default as MdMailOutline,
  MdMap_default as MdMap,
  MdMarkunread_default as MdMarkunread,
  MdMarkunreadMailbox_default as MdMarkunreadMailbox,
  MdMemory_default as MdMemory,
  MdMenu_default as MdMenu,
  MdMergeType_default as MdMergeType,
  MdMessage_default as MdMessage,
  MdMic_default as MdMic,
  MdMicNone_default as MdMicNone,
  MdMicOff_default as MdMicOff,
  MdMms_default as MdMms,
  MdModeComment_default as MdModeComment,
  MdModeEdit_default as MdModeEdit,
  MdMonetizationOn_default as MdMonetizationOn,
  MdMoneyOff_default as MdMoneyOff,
  MdMonochromePhotos_default as MdMonochromePhotos,
  MdMood_default as MdMood,
  MdMoodBad_default as MdMoodBad,
  MdMore_default as MdMore,
  MdMoreHoriz_default as MdMoreHoriz,
  MdMoreVert_default as MdMoreVert,
  MdMotorcycle_default as MdMotorcycle,
  MdMouse_default as MdMouse,
  MdMoveToInbox_default as MdMoveToInbox,
  MdMovie_default as MdMovie,
  MdMovieCreation_default as MdMovieCreation,
  MdMovieFilter_default as MdMovieFilter,
  MdMultilineChart_default as MdMultilineChart,
  MdMusicNote_default as MdMusicNote,
  MdMusicVideo_default as MdMusicVideo,
  MdMyLocation_default as MdMyLocation,
  MdNature_default as MdNature,
  MdNaturePeople_default as MdNaturePeople,
  MdNavigateBefore_default as MdNavigateBefore,
  MdNavigateNext_default as MdNavigateNext,
  MdNavigation_default as MdNavigation,
  MdNearMe_default as MdNearMe,
  MdNetworkCell_default as MdNetworkCell,
  MdNetworkCheck_default as MdNetworkCheck,
  MdNetworkLocked_default as MdNetworkLocked,
  MdNetworkWifi_default as MdNetworkWifi,
  MdNewReleases_default as MdNewReleases,
  MdNextWeek_default as MdNextWeek,
  MdNfc_default as MdNfc,
  MdNoEncryption_default as MdNoEncryption,
  MdNoSim_default as MdNoSim,
  MdNotInterested_default as MdNotInterested,
  MdNote_default as MdNote,
  MdNoteAdd_default as MdNoteAdd,
  MdNotifications_default as MdNotifications,
  MdNotificationsActive_default as MdNotificationsActive,
  MdNotificationsNone_default as MdNotificationsNone,
  MdNotificationsOff_default as MdNotificationsOff,
  MdNotificationsPaused_default as MdNotificationsPaused,
  MdOfflinePin_default as MdOfflinePin,
  MdOndemandVideo_default as MdOndemandVideo,
  MdOpacity_default as MdOpacity,
  MdOpenInBrowser_default as MdOpenInBrowser,
  MdOpenInNew_default as MdOpenInNew,
  MdOpenWith_default as MdOpenWith,
  MdPages_default as MdPages,
  MdPageview_default as MdPageview,
  MdPalette_default as MdPalette,
  MdPanTool_default as MdPanTool,
  MdPanorama_default as MdPanorama,
  MdPanoramaFishEye_default as MdPanoramaFishEye,
  MdPanoramaHorizontal_default as MdPanoramaHorizontal,
  MdPanoramaVertical_default as MdPanoramaVertical,
  MdPanoramaWideAngle_default as MdPanoramaWideAngle,
  MdPartyMode_default as MdPartyMode,
  MdPause_default as MdPause,
  MdPauseCircleFilled_default as MdPauseCircleFilled,
  MdPauseCircleOutline_default as MdPauseCircleOutline,
  MdPayment_default as MdPayment,
  MdPeople_default as MdPeople,
  MdPeopleOutline_default as MdPeopleOutline,
  MdPermCameraMic_default as MdPermCameraMic,
  MdPermContactCalendar_default as MdPermContactCalendar,
  MdPermDataSetting_default as MdPermDataSetting,
  MdPermDeviceInformation_default as MdPermDeviceInformation,
  MdPermIdentity_default as MdPermIdentity,
  MdPermMedia_default as MdPermMedia,
  MdPermPhoneMsg_default as MdPermPhoneMsg,
  MdPermScanWifi_default as MdPermScanWifi,
  MdPerson_default as MdPerson,
  MdPersonAdd_default as MdPersonAdd,
  MdPersonOutline_default as MdPersonOutline,
  MdPersonPin_default as MdPersonPin,
  MdPersonPinCircle_default as MdPersonPinCircle,
  MdPersonalVideo_default as MdPersonalVideo,
  MdPets_default as MdPets,
  MdPhone_default as MdPhone,
  MdPhoneAndroid_default as MdPhoneAndroid,
  MdPhoneBluetoothSpeaker_default as MdPhoneBluetoothSpeaker,
  MdPhoneForwarded_default as MdPhoneForwarded,
  MdPhoneInTalk_default as MdPhoneInTalk,
  MdPhoneIphone_default as MdPhoneIphone,
  MdPhoneLocked_default as MdPhoneLocked,
  MdPhoneMissed_default as MdPhoneMissed,
  MdPhonePaused_default as MdPhonePaused,
  MdPhonelink_default as MdPhonelink,
  MdPhonelinkErase_default as MdPhonelinkErase,
  MdPhonelinkLock_default as MdPhonelinkLock,
  MdPhonelinkOff_default as MdPhonelinkOff,
  MdPhonelinkRing_default as MdPhonelinkRing,
  MdPhonelinkSetup_default as MdPhonelinkSetup,
  MdPhoto_default as MdPhoto,
  MdPhotoAlbum_default as MdPhotoAlbum,
  MdPhotoCamera_default as MdPhotoCamera,
  MdPhotoFilter_default as MdPhotoFilter,
  MdPhotoLibrary_default as MdPhotoLibrary,
  MdPhotoSizeSelectActual_default as MdPhotoSizeSelectActual,
  MdPhotoSizeSelectLarge_default as MdPhotoSizeSelectLarge,
  MdPhotoSizeSelectSmall_default as MdPhotoSizeSelectSmall,
  MdPictureAsPdf_default as MdPictureAsPdf,
  MdPictureInPicture_default as MdPictureInPicture,
  MdPictureInPictureAlt_default as MdPictureInPictureAlt,
  MdPieChart_default as MdPieChart,
  MdPieChartOutlined_default as MdPieChartOutlined,
  MdPinDrop_default as MdPinDrop,
  MdPlace_default as MdPlace,
  MdPlayArrow_default as MdPlayArrow,
  MdPlayCircleFilled_default as MdPlayCircleFilled,
  MdPlayCircleOutline_default as MdPlayCircleOutline,
  MdPlayForWork_default as MdPlayForWork,
  MdPlaylistAdd_default as MdPlaylistAdd,
  MdPlaylistAddCheck_default as MdPlaylistAddCheck,
  MdPlaylistPlay_default as MdPlaylistPlay,
  MdPlusOne_default as MdPlusOne,
  MdPoll_default as MdPoll,
  MdPolymer_default as MdPolymer,
  MdPool_default as MdPool,
  MdPortableWifiOff_default as MdPortableWifiOff,
  MdPortrait_default as MdPortrait,
  MdPower_default as MdPower,
  MdPowerInput_default as MdPowerInput,
  MdPowerSettingsNew_default as MdPowerSettingsNew,
  MdPregnantWoman_default as MdPregnantWoman,
  MdPresentToAll_default as MdPresentToAll,
  MdPrint_default as MdPrint,
  MdPriorityHigh_default as MdPriorityHigh,
  MdPublic_default as MdPublic,
  MdPublish_default as MdPublish,
  MdQueryBuilder_default as MdQueryBuilder,
  MdQuestionAnswer_default as MdQuestionAnswer,
  MdQueue_default as MdQueue,
  MdQueueMusic_default as MdQueueMusic,
  MdQueuePlayNext_default as MdQueuePlayNext,
  MdRadio_default as MdRadio,
  MdRadioButtonChecked_default as MdRadioButtonChecked,
  MdRadioButtonUnchecked_default as MdRadioButtonUnchecked,
  MdRateReview_default as MdRateReview,
  MdReceipt_default as MdReceipt,
  MdRecentActors_default as MdRecentActors,
  MdRecordVoiceOver_default as MdRecordVoiceOver,
  MdRedeem_default as MdRedeem,
  MdRedo_default as MdRedo,
  MdRefresh_default as MdRefresh,
  MdRemove_default as MdRemove,
  MdRemoveCircle_default as MdRemoveCircle,
  MdRemoveCircleOutline_default as MdRemoveCircleOutline,
  MdRemoveFromQueue_default as MdRemoveFromQueue,
  MdRemoveRedEye_default as MdRemoveRedEye,
  MdRemoveShoppingCart_default as MdRemoveShoppingCart,
  MdReorder_default as MdReorder,
  MdRepeat_default as MdRepeat,
  MdRepeatOne_default as MdRepeatOne,
  MdReplay_default as MdReplay,
  MdReplay10_default as MdReplay10,
  MdReplay30_default as MdReplay30,
  MdReplay5_default as MdReplay5,
  MdReply_default as MdReply,
  MdReplyAll_default as MdReplyAll,
  MdReport_default as MdReport,
  MdReportProblem_default as MdReportProblem,
  MdRestaurant_default as MdRestaurant,
  MdRestaurantMenu_default as MdRestaurantMenu,
  MdRestore_default as MdRestore,
  MdRestorePage_default as MdRestorePage,
  MdRingVolume_default as MdRingVolume,
  MdRoom_default as MdRoom,
  MdRoomService_default as MdRoomService,
  MdRotate90DegreesCcw_default as MdRotate90DegreesCcw,
  MdRotateLeft_default as MdRotateLeft,
  MdRotateRight_default as MdRotateRight,
  MdRoundedCorner_default as MdRoundedCorner,
  MdRouter_default as MdRouter,
  MdRowing_default as MdRowing,
  MdRssFeed_default as MdRssFeed,
  MdRvHookup_default as MdRvHookup,
  MdSatellite_default as MdSatellite,
  MdSave_default as MdSave,
  MdScanner_default as MdScanner,
  MdSchedule_default as MdSchedule,
  MdSchool_default as MdSchool,
  MdScreenLockLandscape_default as MdScreenLockLandscape,
  MdScreenLockPortrait_default as MdScreenLockPortrait,
  MdScreenLockRotation_default as MdScreenLockRotation,
  MdScreenRotation_default as MdScreenRotation,
  MdScreenShare_default as MdScreenShare,
  MdSdCard_default as MdSdCard,
  MdSdStorage_default as MdSdStorage,
  MdSearch_default as MdSearch,
  MdSecurity_default as MdSecurity,
  MdSelectAll_default as MdSelectAll,
  MdSend_default as MdSend,
  MdSentimentDissatisfied_default as MdSentimentDissatisfied,
  MdSentimentNeutral_default as MdSentimentNeutral,
  MdSentimentSatisfied_default as MdSentimentSatisfied,
  MdSentimentVeryDissatisfied_default as MdSentimentVeryDissatisfied,
  MdSentimentVerySatisfied_default as MdSentimentVerySatisfied,
  MdSettings_default as MdSettings,
  MdSettingsApplications_default as MdSettingsApplications,
  MdSettingsBackupRestore_default as MdSettingsBackupRestore,
  MdSettingsBluetooth_default as MdSettingsBluetooth,
  MdSettingsBrightness_default as MdSettingsBrightness,
  MdSettingsCell_default as MdSettingsCell,
  MdSettingsEthernet_default as MdSettingsEthernet,
  MdSettingsInputAntenna_default as MdSettingsInputAntenna,
  MdSettingsInputComponent_default as MdSettingsInputComponent,
  MdSettingsInputComposite_default as MdSettingsInputComposite,
  MdSettingsInputHdmi_default as MdSettingsInputHdmi,
  MdSettingsInputSvideo_default as MdSettingsInputSvideo,
  MdSettingsOverscan_default as MdSettingsOverscan,
  MdSettingsPhone_default as MdSettingsPhone,
  MdSettingsPower_default as MdSettingsPower,
  MdSettingsRemote_default as MdSettingsRemote,
  MdSettingsSystemDaydream_default as MdSettingsSystemDaydream,
  MdSettingsVoice_default as MdSettingsVoice,
  MdShare_default as MdShare,
  MdShop_default as MdShop,
  MdShopTwo_default as MdShopTwo,
  MdShoppingBasket_default as MdShoppingBasket,
  MdShoppingCart_default as MdShoppingCart,
  MdShortText_default as MdShortText,
  MdShowChart_default as MdShowChart,
  MdShuffle_default as MdShuffle,
  MdSignalCellular0Bar_default as MdSignalCellular0Bar,
  MdSignalCellular1Bar_default as MdSignalCellular1Bar,
  MdSignalCellular2Bar_default as MdSignalCellular2Bar,
  MdSignalCellular3Bar_default as MdSignalCellular3Bar,
  MdSignalCellular4Bar_default as MdSignalCellular4Bar,
  MdSignalCellularConnectedNoInternet0Bar_default as MdSignalCellularConnectedNoInternet0Bar,
  MdSignalCellularConnectedNoInternet1Bar_default as MdSignalCellularConnectedNoInternet1Bar,
  MdSignalCellularConnectedNoInternet2Bar_default as MdSignalCellularConnectedNoInternet2Bar,
  MdSignalCellularConnectedNoInternet3Bar_default as MdSignalCellularConnectedNoInternet3Bar,
  MdSignalCellularConnectedNoInternet4Bar_default as MdSignalCellularConnectedNoInternet4Bar,
  MdSignalCellularNoSim_default as MdSignalCellularNoSim,
  MdSignalCellularNull_default as MdSignalCellularNull,
  MdSignalCellularOff_default as MdSignalCellularOff,
  MdSignalWifi0Bar_default as MdSignalWifi0Bar,
  MdSignalWifi1Bar_default as MdSignalWifi1Bar,
  MdSignalWifi1BarLock_default as MdSignalWifi1BarLock,
  MdSignalWifi2Bar_default as MdSignalWifi2Bar,
  MdSignalWifi2BarLock_default as MdSignalWifi2BarLock,
  MdSignalWifi3Bar_default as MdSignalWifi3Bar,
  MdSignalWifi3BarLock_default as MdSignalWifi3BarLock,
  MdSignalWifi4Bar_default as MdSignalWifi4Bar,
  MdSignalWifi4BarLock_default as MdSignalWifi4BarLock,
  MdSignalWifiOff_default as MdSignalWifiOff,
  MdSimCard_default as MdSimCard,
  MdSimCardAlert_default as MdSimCardAlert,
  MdSkipNext_default as MdSkipNext,
  MdSkipPrevious_default as MdSkipPrevious,
  MdSlideshow_default as MdSlideshow,
  MdSlowMotionVideo_default as MdSlowMotionVideo,
  MdSmartphone_default as MdSmartphone,
  MdSmokeFree_default as MdSmokeFree,
  MdSmokingRooms_default as MdSmokingRooms,
  MdSms_default as MdSms,
  MdSmsFailed_default as MdSmsFailed,
  MdSnooze_default as MdSnooze,
  MdSort_default as MdSort,
  MdSortByAlpha_default as MdSortByAlpha,
  MdSpa_default as MdSpa,
  MdSpaceBar_default as MdSpaceBar,
  MdSpeaker_default as MdSpeaker,
  MdSpeakerGroup_default as MdSpeakerGroup,
  MdSpeakerNotes_default as MdSpeakerNotes,
  MdSpeakerNotesOff_default as MdSpeakerNotesOff,
  MdSpeakerPhone_default as MdSpeakerPhone,
  MdSpellcheck_default as MdSpellcheck,
  MdStar_default as MdStar,
  MdStarBorder_default as MdStarBorder,
  MdStarHalf_default as MdStarHalf,
  MdStars_default as MdStars,
  MdStayCurrentLandscape_default as MdStayCurrentLandscape,
  MdStayCurrentPortrait_default as MdStayCurrentPortrait,
  MdStayPrimaryLandscape_default as MdStayPrimaryLandscape,
  MdStayPrimaryPortrait_default as MdStayPrimaryPortrait,
  MdStop_default as MdStop,
  MdStopScreenShare_default as MdStopScreenShare,
  MdStorage_default as MdStorage,
  MdStore_default as MdStore,
  MdStoreMallDirectory_default as MdStoreMallDirectory,
  MdStraighten_default as MdStraighten,
  MdStreetview_default as MdStreetview,
  MdStrikethroughS_default as MdStrikethroughS,
  MdStyle_default as MdStyle,
  MdSubdirectoryArrowLeft_default as MdSubdirectoryArrowLeft,
  MdSubdirectoryArrowRight_default as MdSubdirectoryArrowRight,
  MdSubject_default as MdSubject,
  MdSubscriptions_default as MdSubscriptions,
  MdSubtitles_default as MdSubtitles,
  MdSubway_default as MdSubway,
  MdSupervisorAccount_default as MdSupervisorAccount,
  MdSurroundSound_default as MdSurroundSound,
  MdSwapCalls_default as MdSwapCalls,
  MdSwapHoriz_default as MdSwapHoriz,
  MdSwapVert_default as MdSwapVert,
  MdSwapVerticalCircle_default as MdSwapVerticalCircle,
  MdSwitchCamera_default as MdSwitchCamera,
  MdSwitchVideo_default as MdSwitchVideo,
  MdSync_default as MdSync,
  MdSyncDisabled_default as MdSyncDisabled,
  MdSyncProblem_default as MdSyncProblem,
  MdSystemUpdate_default as MdSystemUpdate,
  MdSystemUpdateAlt_default as MdSystemUpdateAlt,
  MdTab_default as MdTab,
  MdTabUnselected_default as MdTabUnselected,
  MdTablet_default as MdTablet,
  MdTabletAndroid_default as MdTabletAndroid,
  MdTabletMac_default as MdTabletMac,
  MdTagFaces_default as MdTagFaces,
  MdTapAndPlay_default as MdTapAndPlay,
  MdTerrain_default as MdTerrain,
  MdTextFields_default as MdTextFields,
  MdTextFormat_default as MdTextFormat,
  MdTextsms_default as MdTextsms,
  MdTexture_default as MdTexture,
  MdTheaters_default as MdTheaters,
  MdThumbDown_default as MdThumbDown,
  MdThumbUp_default as MdThumbUp,
  MdThumbsUpDown_default as MdThumbsUpDown,
  MdTimeToLeave_default as MdTimeToLeave,
  MdTimelapse_default as MdTimelapse,
  MdTimeline_default as MdTimeline,
  MdTimer_default as MdTimer,
  MdTimer10_default as MdTimer10,
  MdTimer3_default as MdTimer3,
  MdTimerOff_default as MdTimerOff,
  MdTitle_default as MdTitle,
  MdToc_default as MdToc,
  MdToday_default as MdToday,
  MdToll_default as MdToll,
  MdTonality_default as MdTonality,
  MdTouchApp_default as MdTouchApp,
  MdToys_default as MdToys,
  MdTrackChanges_default as MdTrackChanges,
  MdTraffic_default as MdTraffic,
  MdTrain_default as MdTrain,
  MdTram_default as MdTram,
  MdTransferWithinAStation_default as MdTransferWithinAStation,
  MdTransform_default as MdTransform,
  MdTranslate_default as MdTranslate,
  MdTrendingDown_default as MdTrendingDown,
  MdTrendingFlat_default as MdTrendingFlat,
  MdTrendingUp_default as MdTrendingUp,
  MdTune_default as MdTune,
  MdTurnedIn_default as MdTurnedIn,
  MdTurnedInNot_default as MdTurnedInNot,
  MdTv_default as MdTv,
  MdUnarchive_default as MdUnarchive,
  MdUndo_default as MdUndo,
  MdUnfoldLess_default as MdUnfoldLess,
  MdUnfoldMore_default as MdUnfoldMore,
  MdUpdate_default as MdUpdate,
  MdUsb_default as MdUsb,
  MdVerifiedUser_default as MdVerifiedUser,
  MdVerticalAlignBottom_default as MdVerticalAlignBottom,
  MdVerticalAlignCenter_default as MdVerticalAlignCenter,
  MdVerticalAlignTop_default as MdVerticalAlignTop,
  MdVibration_default as MdVibration,
  MdVideoCall_default as MdVideoCall,
  MdVideoLabel_default as MdVideoLabel,
  MdVideoLibrary_default as MdVideoLibrary,
  MdVideocam_default as MdVideocam,
  MdVideocamOff_default as MdVideocamOff,
  MdVideogameAsset_default as MdVideogameAsset,
  MdViewAgenda_default as MdViewAgenda,
  MdViewArray_default as MdViewArray,
  MdViewCarousel_default as MdViewCarousel,
  MdViewColumn_default as MdViewColumn,
  MdViewComfy_default as MdViewComfy,
  MdViewCompact_default as MdViewCompact,
  MdViewDay_default as MdViewDay,
  MdViewHeadline_default as MdViewHeadline,
  MdViewList_default as MdViewList,
  MdViewModule_default as MdViewModule,
  MdViewQuilt_default as MdViewQuilt,
  MdViewStream_default as MdViewStream,
  MdViewWeek_default as MdViewWeek,
  MdVignette_default as MdVignette,
  MdVisibility_default as MdVisibility,
  MdVisibilityOff_default as MdVisibilityOff,
  MdVoiceChat_default as MdVoiceChat,
  MdVoicemail_default as MdVoicemail,
  MdVolumeDown_default as MdVolumeDown,
  MdVolumeMute_default as MdVolumeMute,
  MdVolumeOff_default as MdVolumeOff,
  MdVolumeUp_default as MdVolumeUp,
  MdVpnKey_default as MdVpnKey,
  MdVpnLock_default as MdVpnLock,
  MdWallpaper_default as MdWallpaper,
  MdWarning_default as MdWarning,
  MdWatch_default as MdWatch,
  MdWatchLater_default as MdWatchLater,
  MdWbAuto_default as MdWbAuto,
  MdWbCloudy_default as MdWbCloudy,
  MdWbIncandescent_default as MdWbIncandescent,
  MdWbIridescent_default as MdWbIridescent,
  MdWbSunny_default as MdWbSunny,
  MdWc_default as MdWc,
  MdWeb_default as MdWeb,
  MdWebAsset_default as MdWebAsset,
  MdWeekend_default as MdWeekend,
  MdWhatshot_default as MdWhatshot,
  MdWidgets_default as MdWidgets,
  MdWifi_default as MdWifi,
  MdWifiLock_default as MdWifiLock,
  MdWifiTethering_default as MdWifiTethering,
  MdWork_default as MdWork,
  MdWrapText_default as MdWrapText,
  MdYoutubeSearchedFor_default as MdYoutubeSearchedFor,
  MdZoomIn_default as MdZoomIn,
  MdZoomOut_default as MdZoomOut,
  MdZoomOutMap_default as MdZoomOutMap
};
//# sourceMappingURL=svelte-icons_md.js.map
